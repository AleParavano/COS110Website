<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pointers Part 2 - COS110 OOP Study Website</title>
    <link rel="stylesheet" href="../../css/style.css">
</head>
<body>
    <nav class="navbar">
        <a href="../../index.html" class="navbar-brand">üìö COS110 OOP</a>
        <div class="navbar-search"><input type="text" placeholder="Search topics..."></div>
    </nav>

    <div class="container">
        <aside class="sidebar">
            <div class="sidebar-title">üìå Foundations</div>
            <a href="part1.html" class="sidebar-item">Pointers Part 1</a>
            <a href="part2.html" class="sidebar-item active">Pointers Part 2</a>
            <div class="sidebar-title">üèóÔ∏è Classes & Objects</div>
            <a href="../02-classes/basics.html" class="sidebar-item">Classes Basics</a>
        </aside>

        <main class="main-content">
            <h1>üîç Understanding Pointers - Part 2: Advanced Concepts</h1>

            <section class="section">
                <div class="section-title">üìö Explanation</div>
                <div class="explanation">
                    <h3 style="color: var(--primary);">Dynamic Memory Allocation</h3>
                    <p>Dynamic memory allocation allows you to create variables during runtime using the new operator. Unlike stack-based variables that are automatically deleted when they go out of scope, dynamically allocated memory persists until you explicitly free it with delete.</p>

                    <h3 style="color: var(--primary); margin-top: 20px;">The new Operator</h3>
                    <p>The new operator allocates memory on the heap and returns a pointer to that memory. For example: int* ptr = new int; creates an integer on the heap and ptr holds its address. You must remember to free this memory with delete ptr;</p>

                    <h3 style="color: var(--primary); margin-top: 20px;">The delete Operator</h3>
                    <p>The delete operator deallocates memory that was allocated with new. After deletion, the pointer becomes a dangling pointer - it still holds an address but the memory is no longer valid. Always set pointers to nullptr after deletion to avoid accidental use.</p>

                    <h3 style="color: var(--primary); margin-top: 20px;">Memory Leaks</h3>
                    <p>A memory leak occurs when you allocate memory with new but forget to delete it. The memory remains allocated but inaccessible, wasting system resources. With modern C++, using smart pointers (unique_ptr, shared_ptr) helps prevent memory leaks automatically.</p>

                    <h3 style="color: var(--primary); margin-top: 20px;">Null Pointers</h3>
                    <p>A null pointer is one that doesn't point to any valid memory location. It's used to indicate "no address". Always check if a pointer is nullptr before dereferencing it to avoid crashes.</p>
                </div>
            </section>

            <section class="section">
                <div class="section-title">üíª Code Examples</div>

                <div class="code-example">
                    <div class="code-tabs">
                        <button class="code-tab active" data-tab="simple1">Simple Snippet</button>
                        <button class="code-tab" data-tab="full1">Full Program</button>
                    </div>
                    <div data-tab-content="simple1" class="code-editor">
int* ptr = new int;
*ptr = 42;
cout << *ptr << endl;
delete ptr;
ptr = nullptr;
                    </div>
                    <div data-tab-content="full1" style="display: none;">
                        <textarea class="code-editor" id="code1">#include <iostream>
using namespace std;

int main() {
    int* ptr = new int;
    *ptr = 42;
    
    cout << "Value: " << *ptr << endl;
    cout << "Address: " << ptr << endl;
    
    delete ptr;
    ptr = nullptr;
    
    if(ptr == nullptr) {
        cout << "Pointer safely set to nullptr" << endl;
    }
    
    return 0;
}
                        </textarea>
                    </div>
                    <div class="code-buttons">
                        <button class="btn btn-primary" onclick="runCode(document.getElementById('code1'), document.getElementById('output1'))">‚ñ∂ Run Code</button>
                        <button class="btn btn-secondary" onclick="downloadCode(document.getElementById('code1').value, 'dynamic_memory.cpp')">‚¨á Download</button>
                    </div>
                    <div class="output-box" id="output1">Click "Run Code" to execute...</div>
                </div>

                <div class="code-example">
                    <div class="code-tabs">
                        <button class="code-tab active" data-tab="simple2">Simple Snippet</button>
                        <button class="code-tab" data-tab="full2">Full Program</button>
                    </div>
                    <div data-tab-content="simple2" class="code-editor">
int* arr = new int[5];
arr[0] = 10;
arr[1] = 20;
cout << arr[0] + arr[1] << endl;
delete[] arr;
                    </div>
                    <div data-tab-content="full2" style="display: none;">
                        <textarea class="code-editor" id="code2">#include <iostream>
using namespace std;

int main() {
    int* arr = new int[5];
    
    for(int i = 0; i < 5; i++) {
        arr[i] = (i + 1) * 10;
    }
    
    cout << "Dynamic array values:" << endl;
    for(int i = 0; i < 5; i++) {
        cout << "arr[" << i << "] = " << arr[i] << endl;
    }
    
    delete[] arr;
    arr = nullptr;
    
    return 0;
}
                        </textarea>
                    </div>
                    <div class="code-buttons">
                        <button class="btn btn-primary" onclick="runCode(document.getElementById('code2'), document.getElementById('output2'))">‚ñ∂ Run Code</button>
                        <button class="btn btn-secondary" onclick="downloadCode(document.getElementById('code2').value, 'dynamic_array.cpp')">‚¨á Download</button>
                    </div>
                    <div class="output-box" id="output2">Click "Run Code" to execute...</div>
                </div>

                <div class="code-example">
                    <div class="code-tabs">
                        <button class="code-tab active" data-tab="simple3">Simple Snippet</button>
                        <button class="code-tab" data-tab="full3">Full Program</button>
                    </div>
                    <div data-tab-content="simple3" class="code-editor">
struct Node {
    int data;
    Node* next;
};

Node* head = new Node();
head->data = 10;
head->next = nullptr;
                    </div>
                    <div data-tab-content="full3" style="display: none;">
                        <textarea class="code-editor" id="code3">#include <iostream>
using namespace std;

struct Node {
    int data;
    Node* next;
};

int main() {
    Node* head = new Node();
    head->data = 10;
    head->next = nullptr;
    
    Node* second = new Node();
    second->data = 20;
    second->next = nullptr;
    head->next = second;
    
    cout << "First node data: " << head->data << endl;
    cout << "Second node data: " << head->next->data << endl;
    
    delete second;
    delete head;
    
    return 0;
}
                        </textarea>
                    </div>
                    <div class="code-buttons">
                        <button class="btn btn-primary" onclick="runCode(document.getElementById('code3'), document.getElementById('output3'))">‚ñ∂ Run Code</button>
                        <button class="btn btn-secondary" onclick="downloadCode(document.getElementById('code3').value, 'linked_list.cpp')">‚¨á Download</button>
                    </div>
                    <div class="output-box" id="output3">Click "Run Code" to execute...</div>
                </div>
            </section>

            <section class="section">
                <div class="section-title">‚úçÔ∏è Coding Activities</div>

                <div class="activity">
                    <div class="activity-title">‚ö° Intermediate Challenge: Create a Simple Linked List</div>
                    <p>Create a linked list with a Node struct that has data and next pointer. Add three nodes with values 10, 20, 30 and print them.</p>
                    <button class="btn btn-secondary" onclick="downloadCode(`#include <iostream>
using namespace std;

struct Node {
    int data;
    Node* next;
};

int main() {
    // TODO: Create three nodes and link them
    // TODO: Print the values
    
    return 0;
}`, 'linked_list_activity.cpp')">‚¨á Download Skeleton</button>
                    <button class="collapsible">‚ñº Show Solution</button>
                    <div class="collapsible-content">
                        <div class="code-editor">
#include <iostream>
using namespace std;

struct Node {
    int data;
    Node* next;
};

int main() {
    Node* head = new Node();
    head->data = 10;
    
    Node* second = new Node();
    second->data = 20;
    head->next = second;
    
    Node* third = new Node();
    third->data = 30;
    second->next = third;
    third->next = nullptr;
    
    Node* current = head;
    while(current != nullptr) {
        cout << current->data << " ";
        current = current->next;
    }
    cout << endl;
    
    delete third;
    delete second;
    delete head;
    
    return 0;
}
                        </div>
                    </div>
                </div>

                <div class="activity">
                    <div class="activity-title">üî• Advanced Challenge: Dynamic 2D Array</div>
                    <p>Allocate a 3x3 dynamic 2D array, fill it with values, print it, and deallocate properly.</p>
                    <button class="btn btn-secondary" onclick="downloadCode(`#include <iostream>
using namespace std;

int main() {
    int rows = 3, cols = 3;
    
    // TODO: Allocate 2D array
    // TODO: Fill with values
    // TODO: Print the array
    // TODO: Delete properly
    
    return 0;
}`, 'dynamic_2d.cpp')">‚¨á Download Skeleton</button>
                    <button class="collapsible">‚ñº Show Solution</button>
                    <div class="collapsible-content">
                        <div class="code-editor">
#include <iostream>
using namespace std;

int main() {
    int rows = 3, cols = 3;
    
    int** arr = new int*[rows];
    for(int i = 0; i < rows; i++) {
        arr[i] = new int[cols];
    }
    
    int val = 1;
    for(int i = 0; i < rows; i++) {
        for(int j = 0; j < cols; j++) {
            arr[i][j] = val++;
        }
    }
    
    cout << "2D Array:" << endl;
    for(int i = 0; i < rows; i++) {
        for(int j = 0; j < cols; j++) {
            cout << arr[i][j] << " ";
        }
        cout << endl;
    }
    
    for(int i = 0; i < rows; i++) {
        delete[] arr[i];
    }
    delete[] arr;
    
    return 0;
}
                        </div>
                    </div>
                </div>
            </section>

            <section class="section">
                <div class="section-title">üìù Knowledge Check Quiz</div>
                <div class="quiz-container">
                    <button class="quiz-btn" onclick="initializeQuiz()">‚ñ∂ Start Quiz</button>
                </div>
            </section>
        </main>
    </div>

    <footer><p>COS110 OOP Study Website | November 2025</p></footer>

    <script src="../../js/main.js"></script>
    <script src="../../js/compiler.js"></script>
    <script src="../../js/quiz.js"></script>

    <script>
        function initializeQuiz() {
            const questions = [
                {type: 'multiple-choice', question: 'What does the new operator do?', options: ['Deletes memory', 'Allocates memory on the heap', 'Creates a stack variable', 'Prints to console'], correctAnswer: 'B', explanation: 'The new operator allocates memory on the heap and returns a pointer.'},
                {type: 'true-false', question: 'You must use delete[] for arrays and delete for single values.', correctAnswer: 'true', explanation: 'Yes! Always use delete[] for arrays allocated with new[] and delete for single values.'},
                {type: 'multiple-choice', question: 'What is a memory leak?', options: ['A pointer that leaks data', 'Allocated memory that is never freed', 'A null pointer', 'A deleted pointer'], correctAnswer: 'B', explanation: 'A memory leak occurs when allocated memory is not freed.'},
                {type: 'true-false', question: 'After calling delete, you can safely use the pointer again.', correctAnswer: 'false', explanation: 'After delete, the pointer becomes invalid. You should set it to nullptr.'},
                {type: 'fill-in', question: 'To allocate a dynamic integer, use:', context: 'int* ptr = <span style="color: red;">_______</span>;', hint: 'new type', acceptableAnswers: ['new int', 'new int()', 'new int;'], explanation: 'new int allocates space for an integer on the heap.'},
                {type: 'multiple-choice', question: 'How do you deallocate an array?', options: ['delete arr;', 'delete[] arr;', 'free arr;', 'remove arr;'], correctAnswer: 'B', explanation: 'Use delete[] for arrays, not delete.'},
                {type: 'true-false', question: 'Nullptr and NULL are the same thing.', correctAnswer: 'true', explanation: 'Both represent the null pointer, though nullptr is preferred in modern C++.'},
                {type: 'multiple-choice', question: 'What is a dangling pointer?', options: ['A pointer that points to deleted memory', 'A pointer that swings back and forth', 'A pointer to nullptr', 'An uninitialized pointer'], correctAnswer: 'A', explanation: 'A dangling pointer points to memory that has been freed.'},
                {type: 'true-false', question: 'Dynamic arrays use bracket notation like static arrays.', correctAnswer: 'true', explanation: 'Yes! Dynamic arrays can be accessed using bracket notation arr[i].'},
                {type: 'multiple-choice', question: 'In a linked list, what does the next pointer do?', options: ['Points to the previous node', 'Points to the next node', 'Points to the data', 'Points to the head'], correctAnswer: 'B', explanation: 'The next pointer in a linked list node points to the next node in the list.'},
                {type: 'fill-in', question: 'To deallocate memory:', context: '<span style="color: red;">_______</span> ptr;', hint: 'keyword', acceptableAnswers: ['delete', 'delete '], explanation: 'Use delete to deallocate single values.'},
                {type: 'true-false', question: 'Heap memory is slower to access than stack memory.', correctAnswer: 'true', explanation: 'Yes, heap access is slower but provides more flexibility and larger allocation sizes.'},
                {type: 'multiple-choice', question: 'What is the size of a pointer?', options: ['Always 4 bytes', 'Always 8 bytes', 'Depends on system', 'Depends on what it points to'], correctAnswer: 'C', explanation: 'Pointer size depends on architecture (typically 4 or 8 bytes).'},
                {type: 'true-false', question: 'You can initialize a pointer with new when declaring.', correctAnswer: 'true', explanation: 'Yes: int* ptr = new int(42) is valid.'},
                {type: 'multiple-choice', question: 'What happens with double delete?', options: ['Freed twice', 'Undefined behavior/crash', 'Sets to nullptr', 'No problem'], correctAnswer: 'B', explanation: 'Double deletion causes undefined behavior and crashes.'},
                {type: 'fill-in', question: 'To allocate array of 10 ints:', context: 'int* arr = <span style="color: red;">_______</span>;', hint: 'new with brackets', acceptableAnswers: ['new int[10]', 'new int[10];'], explanation: 'new int[10] allocates an array of 10 integers on the heap.'},
                {type: 'true-false', question: 'Pointers can be passed to functions by reference.', correctAnswer: 'true', explanation: 'Yes, this allows functions to change what the pointer points to.'},
                {type: 'multiple-choice', question: 'When should you use dynamic allocation?', options: ['Always', 'Only for arrays', 'When size unknown at compile time', 'Never'], correctAnswer: 'C', explanation: 'Dynamic allocation is useful when size is determined at runtime.'},
                {type: 'true-false', question: 'Stack overflow can happen with dynamic memory.', correctAnswer: 'false', explanation: 'Stack overflow is about stack, not heap. Heap can run out of memory though.'},
                {type: 'multiple-choice', question: 'The best practice for deleted pointers is:', options: ['Leave as is', 'Set to nullptr', 'Wrap in try-catch', 'Reuse immediately'], correctAnswer: 'B', explanation: 'Always set deleted pointers to nullptr to prevent dangling pointer bugs.'}
            ];

            window.quizSystem = new QuizSystem('Pointers Part 2', questions);
            openQuizModal();
        }

        if (!document.getElementById('quizModal')) {
            const modal = document.createElement('div');
            modal.id = 'quizModal';
            modal.className = 'quiz-modal';
            modal.innerHTML = `<div class="quiz-modal-content"><div class="quiz-header"><div><div class="quiz-question-number">Quiz: Pointers Part 2</div><div class="quiz-progress">Question 1 of 20</div></div><button class="quiz-close" onclick="closeQuizModal()">‚úï</button></div><div class="quiz-questions-container"></div></div>`;
            document.body.appendChild(modal);
        }
    </script>
</body>
</html>