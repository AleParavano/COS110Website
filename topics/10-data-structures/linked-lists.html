<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Linked Lists - COS110 OOP Study Website</title>
    <link rel="stylesheet" href="../../css/style.css">
</head>
<body>
    <nav class="navbar">
        <a href="../../index.html" class="navbar-brand">📚 COS110 OOP</a>
        <div class="navbar-search"><input type="text" placeholder="Search topics..."></div>
    </nav>

    <div class="container">
        <aside class="sidebar">
            <div class="sidebar-title">📌 Foundations</div>
            <a href="../01-pointers/part1.html" class="sidebar-item">Pointers Part 1</a>
            <a href="../01-pointers/part2.html" class="sidebar-item">Pointers Part 2</a>

            <div class="sidebar-title">🏗️ Classes & Objects</div>
            <a href="../02-classes/basics.html" class="sidebar-item">Classes Basics</a>
            <a href="../02-classes/advanced.html" class="sidebar-item">Classes Advanced</a>
            <a href="../02-classes/more.html" class="sidebar-item">Classes More</a>

            <div class="sidebar-title">🔧 Constructors</div>
            <a href="../03-copy-constructors.html" class="sidebar-item">Copy Constructors</a>
            <a href="../04-assignment-operator.html" class="sidebar-item">Assignment Operator</a>

            <div class="sidebar-title">➕ Operators</div>
            <a href="../05-operator-overloading/basics.html" class="sidebar-item">Overloading Basics</a>
            <a href="../05-operator-overloading/friends.html" class="sidebar-item">Friends</a>
            <a href="../05-operator-overloading/references.html" class="sidebar-item">References/IO</a>
            <a href="../05-operator-overloading/increment.html" class="sidebar-item">Inc/Dec/Subscript</a>

            <div class="sidebar-title">⚠️ Exception Handling</div>
            <a href="../06-exception-handling/basics.html" class="sidebar-item">Basics</a>
            <a href="../06-exception-handling/hierarchies.html" class="sidebar-item">Hierarchies</a>

            <div class="sidebar-title">👨‍👧 Inheritance</div>
            <a href="../07-inheritance/basics.html" class="sidebar-item">Basics</a>
            <a href="../07-inheritance/redefining.html" class="sidebar-item">Redefining</a>
            <a href="../07-inheritance/aggregation.html" class="sidebar-item">Aggregation</a>

            <div class="sidebar-title">🔄 Polymorphism</div>
            <a href="../08-polymorphism/virtual-functions.html" class="sidebar-item">Virtual Functions</a>
            <a href="../08-polymorphism/pointers.html" class="sidebar-item">Pointers</a>

            <div class="sidebar-title">🎨 Templates</div>
            <a href="../09-templates/classes.html" class="sidebar-item">Classes</a>
            <a href="../09-templates/functions.html" class="sidebar-item">Functions</a>

            <div class="sidebar-title">📊 Data Structures</div>
            <a href="linked-lists.html" class="sidebar-item">Linked Lists</a>
            <a href="doubly-linked.html" class="sidebar-item">Doubly Linked</a>
            <a href="circular-lists.html" class="sidebar-item">Circular Lists</a>
            <a href="stacks.html" class="sidebar-item">Stacks</a>
            <a href="queues.html" class="sidebar-item">Queues</a>
            <a href="stl.html" class="sidebar-item">STL</a>
        </aside>

        <main class="main-content">
            <h1>🔗 Linked Lists - Fundamentals</h1>

            <section class="section">
                <div class="section-title">📚 Explanation</div>
                <div class="explanation">
                    <h3 style="color: var(--primary);">What is a Linked List?</h3>
                    <p>A linked list is a dynamic data structure where data elements are stored in <strong>nodes</strong> scattered throughout memory, connected via <strong>pointers</strong> rather than contiguous storage. This fundamental difference from arrays makes linked lists ideal for scenarios with frequent insertions/deletions, as they require no memory reallocation.</p>
                    
                    <div style="background: #f0f0f0; padding: 15px; border-radius: 8px; margin: 15px 0; font-family: 'Courier New', monospace; line-height: 1.4; color: #333;">
                    <strong>Visual: A Singly Linked List with 3 Elements</strong><br><br>
                    Memory Layout (Non-Contiguous):<br>
                    head ──→ [10|0x2000] ──→ [20|0x3500] ──→ [30|nullptr]<br><br>
                    In Memory:<br>
                    Address 0x1000: [10|0x2000]  ← head points here<br>
                    Address 0x2000: [20|0x3500]  ← reached via first node's pointer<br>
                    Address 0x3500: [30|nullptr] ← reached via second node's pointer<br>
                    <br><strong>Key Insight:</strong> Nodes don't need adjacent memory! Each node stores its value AND address of the next node.
                    </div>

                    <h3 style="color: var(--primary); margin-top: 25px;">Core Concepts: Memory Allocation</h3>
                    <p><strong>Dynamic Allocation:</strong> Each node is created individually with <code>new</code>, allowing the list to grow at runtime without pre-allocating space. This contrasts with arrays, which need fixed sizes or expensive reallocation. <strong>No Cache Locality:</strong> Scattered memory means worse CPU cache performance than arrays, but perfect flexibility for dynamic sizes.</p>

                    <h3 style="color: var(--primary); margin-top: 20px;">Node Structure - The Building Block</h3>
                    <div style="background: #f0f0f0; padding: 15px; border-radius: 8px; margin: 15px 0; font-family: 'Courier New', monospace; color: #333;">
                    <strong>Node Anatomy:</strong><br>
                    ┌──────────────────┐<br>
                    │  [data] [next*]  │  ← Single node contains two fields<br>
                    └──────────────────┘<br>
                                ↓<br>
                    Points to next node or nullptr if last
                    </div>
                    <p>Each node contains: (1) <strong>Data field</strong> - stores the actual value (int, string, object, etc.), (2) <strong>Pointer field</strong> - stores address of next node. The <strong>head pointer</strong> (external to any node) marks the list's beginning. An <strong>empty list</strong> has head = nullptr.</p>

                    <h3 style="color: var(--primary); margin-top: 20px;">Insertion Operations - Adding Elements</h3>
                    
                    <strong>Case 1: Insert at Beginning (O(1))</strong>
                    <div style="background: #e8f4f8; padding: 15px; border-radius: 8px; margin: 10px 0; font-family: 'Courier New', monospace; color: #333;">
                    Before: head ──→ [10|→] ──→ [20|→] ──→ [30|nullptr]<br><br>
                    After inserting 5 at beginning:<br>
                    head ──→ [5|→] ──→ [10|→] ──→ [20|→] ──→ [30|nullptr]<br><br>
                    <strong>Mechanism:</strong><br>
                    1. Create new node with value 5<br>
                    2. Set new_node->next = head  (link new node to old head)<br>
                    3. head = new_node  (update head to point to new node)<br>
                    <strong>Time: O(1)</strong> - constant time, no traversal needed!
                    </div>

                    <strong>Case 2: Insert at End (O(n))</strong>
                    <div style="background: #f0f0f0; padding: 15px; border-radius: 8px; margin: 10px 0; font-family: 'Courier New', monospace; color: #333;">
                    Before: head ──→ [10|→] ──→ [20|→] ──→ [30|nullptr]<br><br>
                    After inserting 40 at end:<br>
                    head ──→ [10|→] ──→ [20|→] ──→ [30|→] ──→ [40|nullptr]<br><br>
                    <strong>Mechanism:</strong><br>
                    1. Traverse to last node (30) by following pointers<br>
                    2. Create new node (40)<br>
                    3. Set last_node->next = new_node<br>
                    <strong>Time: O(n)</strong> - must find last node first!
                    </div>

                    <h3 style="color: var(--primary); margin-top: 20px;">Deletion Operations - Removing Elements</h3>
                    
                    <strong>Critical Challenge: Singly Linked Lists Require Predecessor</strong>
                    <div style="background: #ffe8e8; padding: 15px; border-radius: 8px; margin: 10px 0; font-family: 'Courier New', monospace; color: #333;">
                    <strong>Why delete is expensive:</strong> When you want to delete a node, you must update the <strong>previous node's</strong> next pointer. But in a singly linked list, you can't move backwards! So even if you have a pointer to the target node, you must traverse from head to find its predecessor.<br><br>
                    Example: Delete node with value 20<br>
                    Before: head ──→ [10|→] ──→ [20|→] ──→ [30|nullptr]<br><br>
                    Steps:<br>
                    1. Start at head, traverse until curr->next points to target (find 10)<br>
                    2. Set curr->next = curr->next->next  (10 now points to 30)<br>
                    3. Delete target node<br>
                    4. Result: head ──→ [10|→] ──→ [30|nullptr]<br><br>
                    <strong>Time: O(n)</strong> - Must traverse to find predecessor
                    </div>

                    <h3 style="color: var(--primary); margin-top: 20px;">Traversal and Search - Finding Data</h3>
                    <div style="background: #f0f0f0; padding: 15px; border-radius: 8px; margin: 10px 0; font-family: 'Courier New', monospace; color: #333;">
                    <strong>Traversal Pattern:</strong><br>
                    Node* curr = head;<br>
                    while(curr != nullptr) {<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;// Process curr->data<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;curr = curr->next;  // Move to next node<br>
                    }<br><br>
                    <strong>Why O(n)?</strong> No random access! Must follow pointers sequentially from head. Cannot jump to middle like arrays.
                    </div>

                    <h3 style="color: var(--primary); margin-top: 20px;">Complexity Analysis Summary</h3>
                    <table style="width: 100%; border-collapse: collapse; margin: 15px 0;">
                    <tr style="background: var(--primary); color: white;">
                        <th style="padding: 10px; border: 1px solid #999;">Operation</th>
                        <th style="padding: 10px; border: 1px solid #999;">Time</th>
                        <th style="padding: 10px; border: 1px solid #999;">Reason</th>
                    </tr>
                    <tr style="background: #f9f9f9;">
                        <td style="padding: 10px; border: 1px solid #ddd;"><strong>Insert at Head</strong></td>
                        <td style="padding: 10px; border: 1px solid #ddd;"><strong>O(1)</strong></td>
                        <td style="padding: 10px; border: 1px solid #ddd;">Direct pointer update</td>
                    </tr>
                    <tr>
                        <td style="padding: 10px; border: 1px solid #ddd;"><strong>Insert at End</strong></td>
                        <td style="padding: 10px; border: 1px solid #ddd;"><strong>O(n)</strong></td>
                        <td style="padding: 10px; border: 1px solid #ddd;">Must traverse to find last</td>
                    </tr>
                    <tr style="background: #f9f9f9;">
                        <td style="padding: 10px; border: 1px solid #ddd;"><strong>Delete Head</strong></td>
                        <td style="padding: 10px; border: 1px solid #ddd;"><strong>O(1)</strong></td>
                        <td style="padding: 10px; border: 1px solid #ddd;">Update head pointer directly</td>
                    </tr>
                    <tr>
                        <td style="padding: 10px; border: 1px solid #ddd;"><strong>Delete Middle/End</strong></td>
                        <td style="padding: 10px; border: 1px solid #ddd;"><strong>O(n)</strong></td>
                        <td style="padding: 10px; border: 1px solid #ddd;">Must find predecessor node</td>
                    </tr>
                    <tr style="background: #f9f9f9;">
                        <td style="padding: 10px; border: 1px solid #ddd;"><strong>Search/Access</strong></td>
                        <td style="padding: 10px; border: 1px solid #ddd;"><strong>O(n)</strong></td>
                        <td style="padding: 10px; border: 1px solid #ddd;">No random access capability</td>
                    </tr>
                    </table>

                    <h3 style="color: var(--primary); margin-top: 20px;">When to Use Linked Lists</h3>
                    <p><strong>✓ Best for:</strong> Frequent insertions/deletions anywhere in the list, memory-constrained systems (no array reallocation), implementing stacks and queues efficiently.</p>
                    <p><strong>✗ Avoid for:</strong> Random access patterns, read-heavy applications, cache-sensitive performance, small datasets (array overhead matters).</p>
                </div>
            </section>

            <section class="section">
                <div class="section-title">💻 Code Examples</div>

                <div class="code-example">
                    <div class="code-tabs">
                        <button class="code-tab active" data-tab="simple1">Basic Linked List</button>
                        <button class="code-tab" data-tab="full1">Full Program</button>
                    </div>
                    <div data-tab-content="simple1" class="code-editor">
struct Node {
    int data;
    Node* next;
    Node(int val) : data(val), next(nullptr) {}
};

class LinkedList {
private:
    Node* head;
public:
    LinkedList() : head(nullptr) {}
    
    void insertAtBegin(int val) {
        Node* newNode = new Node(val);
        newNode->next = head;
        head = newNode;
    }
    
    void display() {
        Node* curr = head;
        while(curr != nullptr) {
            cout << curr->data << " -> ";
            curr = curr->next;
        }
        cout << "NULL" << endl;
    }
};

LinkedList list;
list.insertAtBegin(3);
list.insertAtBegin(2);
list.insertAtBegin(1);
list.display();  // 1 -> 2 -> 3 -> NULL
                    </div>
                    <div data-tab-content="full1" style="display: none;">
                        <textarea class="code-editor" id="code1">#include <iostream>
using namespace std;

// ===== NODE STRUCTURE =====
// Each node is a building block with data and pointer to next node
struct Node {
    int data;           // Stores the actual value
    Node* next;         // Points to next node in chain
    
    // Constructor initializes the node
    Node(int val) : data(val), next(nullptr) {
        cout << "Node created: " << val << endl;
    }
};

// ===== LINKED LIST CLASS =====
class LinkedList {
private:
    Node* head;         // External pointer tracking list's beginning
    
public:
    // Constructor: creates empty list with head = nullptr
    LinkedList() : head(nullptr) {
        cout << "List created" << endl;
    }
    
    // O(1) - Insert at beginning (constant time, no traversal needed!)
    void insertAtBegin(int val) {
        Node* newNode = new Node(val);      // Step 1: Create new node dynamically
        newNode->next = head;               // Step 2: Link new node to old head
        head = newNode;                     // Step 3: Move head to new node
    }
    
    // O(n) - Insert at end (must traverse to find last node)
    void insertAtEnd(int val) {
        Node* newNode = new Node(val);      // Create new node
        
        // Edge case: Empty list - new node becomes head
        if(head == nullptr) {
            head = newNode;
            return;
        }
        
        // Traverse to find the last node (whose next is nullptr)
        Node* curr = head;                  // Start at head
        while(curr->next != nullptr) {      // Keep going until we find last node
            curr = curr->next;              // Move to next node
        }
        
        // curr now points to last node - attach new node here
        curr->next = newNode;
    }
    
    // O(n) - Display entire list by traversing from head to nullptr
    void display() {
        cout << "List: ";
        Node* curr = head;                  // Start at head
        
        // Traverse using a loop pointer (don't modify head!)
        while(curr != nullptr) {
            cout << curr->data << " -> ";   // Print current node's data
            curr = curr->next;              // Move to next node
        }
        cout << "NULL" << endl;             // nullptr represented as NULL
    }
    
    // Destructor: CRITICAL - must free all nodes to prevent memory leak
    ~LinkedList() {
        Node* curr = head;                  // Start at head
        while(curr != nullptr) {
            Node* temp = curr;              // Save current node
            curr = curr->next;              // Move to next (before deleting curr!)
            delete temp;                    // Free the saved node
        }
        cout << "List destroyed" << endl;
    }
};

int main() {
    LinkedList list;
    
    // ===== DEMONSTRATE INSERT AT END =====
    cout << "\n=== Insert at End ===" << endl;
    list.insertAtEnd(10);                   // 10 becomes first node
    list.insertAtEnd(20);                   // Traverse to 10, link 20
    list.insertAtEnd(30);                   // Traverse through 10->20, link 30
    list.display();                         // Output: 10 -> 20 -> 30 -> NULL
    
    // ===== DEMONSTRATE INSERT AT BEGIN =====
    cout << "\n=== Insert at Begin ===" << endl;
    list.insertAtBegin(5);                  // 5 becomes new head, points to old head (10)
    list.insertAtBegin(1);                  // 1 becomes new head, points to 5
    list.display();                         // Output: 1 -> 5 -> 10 -> 20 -> 30 -> NULL
    
    return 0;
}
                        </textarea>
                    </div>
                    <div class="code-buttons">
                        <button class="btn btn-primary" onclick="runCode(document.getElementById('code1'), document.getElementById('output1'))">▶ Run Code</button>
                        <button class="btn btn-secondary" onclick="downloadCode(document.getElementById('code1'))">⬇ Download Code</button>
                    </div>
                    <div class="output-box" id="output1">Click "Run Code" to execute...</div>
                </div>

                <div class="code-example">
                    <div class="code-tabs">
                        <button class="code-tab active" data-tab="simple2">Deletion</button>
                        <button class="code-tab" data-tab="full2">Full Program</button>
                    </div>
                    <div data-tab-content="simple2" class="code-editor">
void deleteFromBegin() {
    if(head == nullptr) return;
    Node* temp = head;
    head = head->next;
    delete temp;
}

void deleteFromEnd() {
    if(head == nullptr) return;
    if(head->next == nullptr) {
        delete head;
        head = nullptr;
        return;
    }
    Node* curr = head;
    while(curr->next->next != nullptr) {
        curr = curr->next;
    }
    delete curr->next;
    curr->next = nullptr;
}
                    </div>
                    <div data-tab-content="full2" style="display: none;">
                        <textarea class="code-editor" id="code2">#include <iostream>
using namespace std;

// ===== NODE STRUCTURE =====
struct Node {
    int data;
    Node* next;
    Node(int val) : data(val), next(nullptr) {}
};

// ===== LINKED LIST CLASS =====
class LinkedList {
private:
    Node* head;
public:
    LinkedList() : head(nullptr) {}
    
    // O(n) - Insert at end (traverses entire list)
    void insert(int val) {
        Node* newNode = new Node(val);
        if(head == nullptr) {               // Empty list case
            head = newNode;
            return;
        }
        Node* curr = head;
        while(curr->next != nullptr) {      // Find last node
            curr = curr->next;
        }
        curr->next = newNode;               // Attach new node to end
    }
    
    // O(1) - Delete from beginning (constant time, just update head)
    void deleteFromBegin() {
        if(head == nullptr) {               // Guard: empty list
            cout << "List empty" << endl;
            return;
        }
        cout << "Deleting: " << head->data << endl;
        
        Node* temp = head;                  // Save pointer to head node
        head = head->next;                  // Move head to next node (or nullptr if was last)
        delete temp;                        // Free the old head node
    }
    
    // O(n) - Delete from end (must find second-to-last node)
    void deleteFromEnd() {
        if(head == nullptr) {               // Guard: empty list
            cout << "List empty" << endl;
            return;
        }
        
        // Edge case: Only one node in list
        if(head->next == nullptr) {
            cout << "Deleting: " << head->data << endl;
            delete head;                    // Delete the only node
            head = nullptr;                 // Mark list as empty
            return;
        }
        
        // Find second-to-last node
        Node* curr = head;
        // KEY INSIGHT: while(curr->next->next != nullptr) stops when curr is second-to-last
        // This prevents accessing curr->next after deletion
        while(curr->next->next != nullptr) {    // Stop when curr->next is the last node
            curr = curr->next;              // Move forward
        }
        
        cout << "Deleting: " << curr->next->data << endl;
        delete curr->next;                  // Free the last node
        curr->next = nullptr;               // Update second-to-last node to point to nullptr
    }
    
    // O(n) - Display entire list
    void display() {
        cout << "List: ";
        Node* curr = head;
        while(curr != nullptr) {
            cout << curr->data << " -> ";
            curr = curr->next;
        }
        cout << "NULL" << endl;
    }
    
    // Destructor: Clean up all nodes
    ~LinkedList() {
        while(head != nullptr) {            // Keep deleting from beginning until empty
            deleteFromBegin();
        }
    }
};

int main() {
    LinkedList list;
    
    // ===== INSERT ELEMENTS =====
    cout << "=== Inserting ===" << endl;
    for(int i = 10; i <= 50; i += 10) {
        list.insert(i);                     // Insert 10, 20, 30, 40, 50
    }
    list.display();                         // Output: 10 -> 20 -> 30 -> 40 -> 50 -> NULL
    
    // ===== DELETE FROM BEGIN =====
    cout << "\n=== Delete from Begin ===" << endl;
    list.deleteFromBegin();                 // Delete 10, head now points to 20
    list.display();                         // Output: 20 -> 30 -> 40 -> 50 -> NULL
    
    // ===== DELETE FROM END =====
    cout << "\n=== Delete from End ===" << endl;
    list.deleteFromEnd();                   // Delete 50, last node now 40
    list.display();                         // Output: 20 -> 30 -> 40 -> NULL
    
    return 0;
}
                        </textarea>
                    </div>
                    <div class="code-buttons">
                        <button class="btn btn-primary" onclick="runCode(document.getElementById('code2'), document.getElementById('output2'))">▶ Run Code</button>
                        <button class="btn btn-secondary" onclick="downloadCode(document.getElementById('code2'))">⬇ Download Code</button>
                    </div>
                    <div class="output-box" id="output2">Click "Run Code" to execute...</div>
                </div>

                <div class="code-example">
                    <div class="code-tabs">
                        <button class="code-tab active" data-tab="simple3">Search & Count</button>
                        <button class="code-tab" data-tab="full3">Full Program</button>
                    </div>
                    <div data-tab-content="simple3" class="code-editor">
bool search(int key) {
    Node* curr = head;
    while(curr != nullptr) {
        if(curr->data == key) return true;
        curr = curr->next;
    }
    return false;
}

int count() {
    int cnt = 0;
    Node* curr = head;
    while(curr != nullptr) {
        cnt++;
        curr = curr->next;
    }
    return cnt;
}

list.search(25);  // true or false
cout << "Size: " << list.count() << endl;
                    </div>
                    <div data-tab-content="full3" style="display: none;">
                        <textarea class="code-editor" id="code3">#include <iostream>
using namespace std;

struct Node {
    int data;
    Node* next;
    Node(int val) : data(val), next(nullptr) {}
};

class LinkedList {
private:
    Node* head;
public:
    LinkedList() : head(nullptr) {}
    
    void insert(int val) {
        Node* newNode = new Node(val);
        if(head == nullptr) {
            head = newNode;
            return;
        }
        Node* curr = head;
        while(curr->next != nullptr) {
            curr = curr->next;
        }
        curr->next = newNode;
    }
    
    bool search(int key) {
        Node* curr = head;
        while(curr != nullptr) {
            if(curr->data == key) {
                return true;
            }
            curr = curr->next;
        }
        return false;
    }
    
    int count() {
        int cnt = 0;
        Node* curr = head;
        while(curr != nullptr) {
            cnt++;
            curr = curr->next;
        }
        return cnt;
    }
    
    void display() {
        cout << "List: ";
        Node* curr = head;
        while(curr != nullptr) {
            cout << curr->data << " -> ";
            curr = curr->next;
        }
        cout << "NULL" << endl;
    }
    
    ~LinkedList() {
        Node* curr = head;
        while(curr != nullptr) {
            Node* temp = curr;
            curr = curr->next;
            delete temp;
        }
    }
};

int main() {
    LinkedList list;
    
    cout << "=== Building List ===" << endl;
    for(int i = 1; i <= 5; i++) {
        list.insert(i * 10);
    }
    list.display();
    
    cout << "\n=== Search Operations ===" << endl;
    cout << "Search 30: " 
         << (list.search(30) ? "Found" : "Not found") << endl;
    cout << "Search 99: " 
         << (list.search(99) ? "Found" : "Not found") << endl;
    cout << "Search 10: " 
         << (list.search(10) ? "Found" : "Not found") << endl;
    
    cout << "\n=== Count ===" << endl;
    cout << "List size: " << list.count() << endl;
    
    return 0;
}
                        </textarea>
                    </div>
                    <div class="code-buttons">
                        <button class="btn btn-primary" onclick="runCode(document.getElementById('code3'), document.getElementById('output3'))">▶ Run Code</button>
                        <button class="btn btn-secondary" onclick="downloadCode(document.getElementById('code3'))">⬇ Download Code</button>
                    </div>
                    <div class="output-box" id="output3">Click "Run Code" to execute...</div>
                </div>
            </section>

            <section class="section">
                <div class="section-title">✍️ Coding Activities</div>

                <div class="activity">
                    <div class="activity-title">⚡ Intermediate Challenge: Insert at Position</div>
                    <p>Add method to insert at specific position in linked list.</p>
                    <button class="btn btn-secondary" onclick="downloadLinkedListInsertSkeleton()">⬇ Download Skeleton</button>
                    <button class="collapsible">▼ Show Solution</button>
                    <div class="collapsible-content">
                        <div class="code-editor">
#include <iostream>
using namespace std;

struct Node {
    int data;
    Node* next;
    Node(int val) : data(val), next(nullptr) {}
};

class LinkedList {
private:
    Node* head;
public:
    LinkedList() : head(nullptr) {}
    
    void insert(int val) {
        Node* newNode = new Node(val);
        if(head == nullptr) {
            head = newNode;
            return;
        }
        Node* curr = head;
        while(curr->next != nullptr) {
            curr = curr->next;
        }
        curr->next = newNode;
    }
    
    void insertAt(int pos, int val) {
        if(pos < 1) {
            cout << "Invalid position" << endl;
            return;
        }
        
        Node* newNode = new Node(val);
        
        if(pos == 1) {
            newNode->next = head;
            head = newNode;
            return;
        }
        
        Node* curr = head;
        for(int i = 1; i < pos - 1 && curr != nullptr; i++) {
            curr = curr->next;
        }
        
        if(curr == nullptr) {
            cout << "Position out of range" << endl;
            return;
        }
        
        newNode->next = curr->next;
        curr->next = newNode;
    }
    
    void display() {
        cout << "List: ";
        Node* curr = head;
        while(curr != nullptr) {
            cout << curr->data << " -> ";
            curr = curr->next;
        }
        cout << "NULL" << endl;
    }
    
    ~LinkedList() {
        Node* curr = head;
        while(curr != nullptr) {
            Node* temp = curr;
            curr = curr->next;
            delete temp;
        }
    }
};

int main() {
    LinkedList list;
    
    cout << "=== Initial List ===" << endl;
    list.insert(10);
    list.insert(20);
    list.insert(40);
    list.display();
    
    cout << "\n=== Insert 30 at position 3 ===" << endl;
    list.insertAt(3, 30);
    list.display();
    
    cout << "\n=== Insert 5 at position 1 ===" << endl;
    list.insertAt(1, 5);
    list.display();
    
    cout << "\n=== Insert 50 at end ===" << endl;
    list.insertAt(6, 50);
    list.display();
    
    return 0;
}
                        </div>
                    </div>
                </div>

                <div class="activity">
                    <div class="activity-title">🔥 Advanced Challenge: Reverse Linked List</div>
                    <p>Implement method to reverse entire linked list in-place.</p>
                    <button class="btn btn-secondary" onclick="downloadLinkedListReverseSkeleton()">⬇ Download Skeleton</button>
                    <button class="collapsible">▼ Show Solution</button>
                    <div class="collapsible-content">
                        <div class="code-editor">
#include <iostream>
using namespace std;

struct Node {
    int data;
    Node* next;
    Node(int val) : data(val), next(nullptr) {}
};

class LinkedList {
private:
    Node* head;
public:
    LinkedList() : head(nullptr) {}
    
    void insert(int val) {
        Node* newNode = new Node(val);
        if(head == nullptr) {
            head = newNode;
            return;
        }
        Node* curr = head;
        while(curr->next != nullptr) {
            curr = curr->next;
        }
        curr->next = newNode;
    }
    
    void reverse() {
        Node* prev = nullptr;
        Node* curr = head;
        Node* next = nullptr;
        
        while(curr != nullptr) {
            next = curr->next;
            curr->next = prev;
            prev = curr;
            curr = next;
        }
        
        head = prev;
    }
    
    void display() {
        cout << "List: ";
        Node* curr = head;
        while(curr != nullptr) {
            cout << curr->data << " -> ";
            curr = curr->next;
        }
        cout << "NULL" << endl;
    }
    
    ~LinkedList() {
        Node* curr = head;
        while(curr != nullptr) {
            Node* temp = curr;
            curr = curr->next;
            delete temp;
        }
    }
};

int main() {
    LinkedList list;
    
    cout << "=== Building List ===" << endl;
    for(int i = 1; i <= 5; i++) {
        list.insert(i);
    }
    list.display();
    
    cout << "\n=== After Reverse ===" << endl;
    list.reverse();
    list.display();
    
    cout << "\n=== Reverse Again ===" << endl;
    list.reverse();
    list.display();
    
    return 0;
}
                        </div>
                    </div>
                </div>
            </section>

            <section class="section">
                <div class="section-title">📝 Knowledge Check Quiz</div>
                <div class="quiz-container">
                    <button class="quiz-btn" onclick="initializeQuiz()">▶ Start Quiz</button>
                </div>
            </section>
        </main>
    </div>

    <footer><p>COS110 OOP Study Website | November 2025</p></footer>

    <script src="../../js/main.js"></script>
    <script src="../../js/compiler.js"></script>
    <script src="../../js/quiz.js"></script>

    <script>
        // Skeleton download functions
        function downloadLinkedListInsertSkeleton() {
            const code = `#include <iostream>
using namespace std;

struct Node {
    int data;
    Node* next;
    Node(int val) : data(val), next(nullptr) {}
};

class LinkedList {
private:
    Node* head;
public:
    LinkedList() : head(nullptr) {}
    
    void insert(int val) { 
        Node* newNode = new Node(val);
        if(head == nullptr) {
            head = newNode;
            return;
        }
        Node* curr = head;
        while(curr->next != nullptr) curr = curr->next;
        curr->next = newNode;
    }
    
    // TODO: void insertAt(int pos, int val)
    // Insert element at specific position (0-based index)
    // HINT: Traverse to position-1, then insert
    void insertAt(int pos, int val) {
        // YOUR CODE HERE
    }
    
    void display() { 
        Node* curr = head;
        cout << "List: ";
        while(curr != nullptr) {
            cout << curr->data << " -> ";
            curr = curr->next;
        }
        cout << "nullptr" << endl;
    }
    
    ~LinkedList() {
        Node* curr = head;
        while(curr != nullptr) {
            Node* temp = curr;
            curr = curr->next;
            delete temp;
        }
    }
};

int main() {
    LinkedList list;
    list.insert(10);
    list.insert(20);
    list.insert(40);
    
    cout << "Before: ";
    list.display();
    
    list.insertAt(2, 30);  // Insert 30 at index 2
    
    cout << "After:  ";
    list.display();  // Should be 10 -> 20 -> 30 -> 40
    
    return 0;
}`;
            downloadSkeleton(code, 'linked_list_insert_pos.cpp');
        }
        
        function downloadLinkedListReverseSkeleton() {
            const code = `#include <iostream>
using namespace std;

struct Node {
    int data;
    Node* next;
    Node(int val) : data(val), next(nullptr) {}
};

class LinkedList {
private:
    Node* head;
public:
    LinkedList() : head(nullptr) {}
    
    void insert(int val) { 
        Node* newNode = new Node(val);
        if(head == nullptr) {
            head = newNode;
            return;
        }
        Node* curr = head;
        while(curr->next != nullptr) curr = curr->next;
        curr->next = newNode;
    }
    
    // TODO: void reverse() - Reverse entire list in-place
    // HINT: Use three pointers: prev, curr, next
    // Algorithm:
    // 1. Initialize: prev=nullptr, curr=head, next=nullptr
    // 2. Loop through list:
    //    - Save curr->next in next
    //    - Reverse link: curr->next = prev
    //    - Move prev and curr forward
    // 3. Update head to prev (the new head)
    void reverse() {
        // YOUR CODE HERE
    }
    
    void display() { 
        Node* curr = head;
        cout << "List: ";
        while(curr != nullptr) {
            cout << curr->data << " -> ";
            curr = curr->next;
        }
        cout << "nullptr" << endl;
    }
    
    ~LinkedList() {
        Node* curr = head;
        while(curr != nullptr) {
            Node* temp = curr;
            curr = curr->next;
            delete temp;
        }
    }
};

int main() {
    LinkedList list;
    list.insert(1);
    list.insert(2);
    list.insert(3);
    
    cout << "Before reverse: ";
    list.display();  // Should be: 1 -> 2 -> 3 -> nullptr
    
    list.reverse();
    
    cout << "After reverse:  ";
    list.display();  // Should be: 3 -> 2 -> 1 -> nullptr
    
    return 0;
}`;
            downloadSkeleton(code, 'linked_list_reverse.cpp');
        }

        function initializeQuiz() {
            const questions = [
                {type: 'multiple-choice', question: 'You need to insert a node at position k in a singly linked list. Why does insertion at the beginning (k=1) have different pointer mechanics than insertion at the middle?', options: ['Beginning insertion requires updating the head pointer; middle insertion only updates next pointers between existing nodes', 'All insertions use identical mechanics; position is irrelevant', 'Middle insertion is more efficient because it avoids head pointer modification', 'Position k determines memory allocation strategy'], correctAnswer: 'A', explanation: 'At the beginning, you must update the external head pointer reference, while middle insertion only affects internal node pointers. This distinction is critical for proper list management.'},
                {type: 'true-false', question: 'Deleting a node in a singly linked list requires knowledge of the previous node, making deletion O(n) even when you have a pointer to the target node.', correctAnswer: 'true', explanation: 'True. With only a forward pointer, you cannot access the predecessor without traversing from the head. This is why doubly linked lists solve this problem.'},
                {type: 'fill-in', question: 'Memory Layout Understanding: If a linked list with 1000 nodes uses non-contiguous memory, what is the primary performance trade-off compared to an array?', context: 'Arrays provide O(1) random access, but linked lists have O(n) access due to <span style="color: red;">_______</span>', hint: 'sequential traversal or pointer following', acceptableAnswers: ['sequential traversal', 'pointer following', 'traversal', 'linear traversal', 'following pointers'], explanation: 'The scattered memory layout requires sequential pointer traversal rather than direct address calculation, fundamentally changing access characteristics.'},
                {type: 'multiple-choice', question: 'Consider a scenario where you need to find the middle element of a linked list without knowing its length. Which approach is most efficient and why?', options: ['Traverse to end to find length, then traverse again to middle - ensures accuracy', 'Use slow and fast pointers simultaneously; slow moves 1 step, fast moves 2 steps - O(n) with single pass', 'Use recursion to measure depth while traversing - more intuitive', 'All approaches have identical efficiency'], correctAnswer: 'B', explanation: 'The tortoise-hare algorithm efficiently finds the middle in one pass by maintaining speed differential. When fast reaches end, slow is at middle. This demonstrates algorithmic thinking beyond basic traversal.'},
                {type: 'true-false', question: 'A linked list implementation requires checking for nullptr before every pointer dereference to guarantee memory safety.', correctAnswer: 'true', explanation: 'Yes. Accessing members of a nullptr causes undefined behavior. Defensive null-checking is essential in linked list operations.'},
                {type: 'short-answer', question: 'Explain why a linked list can be more memory-efficient than a dynamically allocated array for certain insertion/deletion patterns, despite having pointer overhead.', context: 'Consider a scenario with frequent insertions at random positions. Array resizing requires <span style="color: red;">_______</span>, but linked lists only require pointer updates.', hint: 'O(n) copying', acceptableAnswers: ['O(n) copying', 'element copying', 'reallocating memory', 'data copying'], explanation: 'Arrays must copy all elements when resizing, while linked lists insert with just pointer manipulation. For insertion-heavy workloads, this overhead matters significantly.'},
                {type: 'multiple-choice', question: 'Reversing a singly linked list requires careful pointer manipulation. During reversal, what critical error occurs if you don\'t save the next pointer before updating current->next?', options: ['Memory leak occurs; the remaining list becomes inaccessible', 'The program crashes immediately', 'Elements are duplicated in the reversed list', 'Cache efficiency decreases'], correctAnswer: 'A', explanation: 'Without saving next, you break the chain link after reassigning current->next, orphaning the rest of the list. This demonstrates why algorithm design must prevent resource loss.'},
                {type: 'true-false', question: 'In a linked list, searching for a value is always O(n) regardless of whether the list is sorted or unsorted.', correctAnswer: 'true', explanation: 'Correct. Linked lists don\'t support binary search due to lack of random access. Even sorted linked lists require linear traversal.'},
                {type: 'fill-in', question: 'When copying a linked list, what structural trap occurs if you only copy the head pointer without deep copying all nodes?', context: 'Both lists would reference the <span style="color: red;">_______</span> underlying nodes, causing modifications to affect both lists.', hint: 'same', acceptableAnswers: ['same', 'identical', 'same underlying', 'shared'], explanation: 'Shallow copy creates aliasing; both list objects point to identical node chain. Modifications through one list affect the other—a classic deep vs. shallow copy issue.'},
                {type: 'multiple-choice', question: 'A linked list node has a self-referential pointer: Node* next. What potential issue arises from circular self-reference (node->next = node)?', options: ['Creates useful structure for round-robin scheduling', 'Causes infinite loop in traversal unless explicit termination condition added', 'Memory is automatically freed due to garbage collection', 'Performance improves due to cache locality'], correctAnswer: 'B', explanation: 'A node pointing to itself creates infinite traversal without explicit boundary checking, highlighting why loops in linked structures require careful termination logic.'},
                {type: 'true-false', question: 'A linked list with n nodes can be searched in logarithmic O(log n) time if the list is sorted and you implement binary search with pointer arithmetic.', correctAnswer: 'false', explanation: 'False. Pointer arithmetic doesn\'t work with non-contiguous memory. You cannot perform binary search on linked lists efficiently; linear traversal is required.'},
                {type: 'multiple-choice', question: 'When implementing insert at position i in a linked list, what is the minimum number of pointer dereferences needed in the worst case?', options: ['1 dereference regardless of position', 'i dereferences to reach position i', 'i-1 dereferences to reach the predecessor node', '2i dereferences due to bidirectional checks'], correctAnswer: 'C', explanation: 'To insert at position i, you must reach the predecessor at position i-1. This requires i-1 traversal steps, each with one dereference operation.'},
                {type: 'fill-in', question: 'Merge Operation: When merging two sorted linked lists, why is the operation O(n+m) for lists of size n and m rather than O(n*m)?', context: 'Merging requires <span style="color: red;">_______</span> pass through each list, comparing and linking nodes without re-traversal.', hint: 'single or one', acceptableAnswers: ['single', 'one', 'linear', 'sequential'], explanation: 'Single traversal of both lists with pointer manipulation achieves linear time. Each node is visited once and linked appropriately, avoiding quadratic comparisons.'},
                {type: 'multiple-choice', question: 'Why is detecting a cycle in a linked list O(n) using Floyd\'s cycle detection algorithm rather than O(n²) with other approaches?', options: ['Floyd\'s algorithm uses sorting which is O(n log n)', 'Using two pointers at different speeds finds cycle in single pass', 'Cycle detection is impossible in better than O(n²)', 'Floyd\'s algorithm maintains a hash table of O(n) space'], correctAnswer: 'B', explanation: 'Slow pointer moves 1 step, fast moves 2 steps. They must meet if cycle exists. This converges in O(n) time without extra space for bookkeeping.'},
                {type: 'true-false', question: 'In a linked list, the last node\'s next pointer can be safely set to nullptr without additional validation.', correctAnswer: 'false', explanation: 'False. Without verifying the node is actually the last node, setting next to nullptr could disconnect the rest of the list. Proper validation is essential.'},
                {type: 'short-answer', question: 'Complexity Analysis: Why is splitting a linked list at a given node O(n) even if you have a direct pointer to the node?', context: 'To properly split at node X, you must find its <span style="color: red;">_______</span> to disconnect the list cleanly.', hint: 'predecessor', acceptableAnswers: ['predecessor', 'previous node', 'prior node'], explanation: 'With only forward pointers, you must traverse from head to find the node before X to update its next pointer. This requires O(n) traversal despite having X\'s address.'},
                {type: 'multiple-choice', question: 'When a linked list operation modifies the head (like delete head), why must the calling function typically receive a pointer-to-pointer (Node** head) rather than just a pointer (Node* head)?', options: ['Pointer-to-pointer is purely stylistic convention', 'It allows the function to modify the head pointer itself, not just follow it', 'It provides better cache locality', 'Only necessary for recursive implementations'], correctAnswer: 'B', explanation: 'Passing by value (Node*) allows following the pointer but not modifying it. Pointer-to-pointer (Node**) allows changing what head points to, essential for structural modifications.'},
                {type: 'fill-in', question: 'Recursive Reversal: A recursive reversal algorithm must carefully manage the base case. What is the base case for recursive linked list reversal?', context: 'Base case: when curr is <span style="color: red;">_______</span>, return immediately to terminate recursion.', hint: 'nullptr or null', acceptableAnswers: ['nullptr', 'null', 'empty', 'nullptr or curr->next is nullptr'], explanation: 'Reaching nullptr indicates end of list. Without this base case, dereferencing nullptr causes segmentation fault.'},
                {type: 'true-false', question: 'A linked list implementation must explicitly free nodes during deletion to avoid memory leaks, even if the program is terminating.', correctAnswer: 'true', explanation: 'True. Proper resource management demands freeing allocated memory. Some systems may reclaim memory on exit, but explicit deletion is best practice for correctness.'},
                {type: 'multiple-choice', question: 'Why is implementing a "get size" operation O(n) for linked lists without maintaining a size variable, but O(1) for arrays?', options: ['Arrays are superior data structures', 'Linked lists require traversing entire structure to count nodes; arrays store size information by default', 'Size calculation is identical in both; arrays are just faster', 'Linked lists can use hash tables to optimize size'], correctAnswer: 'B', explanation: 'Arrays allocate fixed capacity; size is metadata. Linked lists dynamically grow; no inherent size tracking without explicit maintenance, requiring traversal.'},
            ];

            window.quizSystem = new QuizSystem('Linked Lists', questions);
            openQuizModal();
        }

        if (!document.getElementById('quizModal')) {
            const modal = document.createElement('div');
            modal.id = 'quizModal';
            modal.className = 'quiz-modal';
            modal.innerHTML = `<div class="quiz-modal-content"><div class="quiz-header"><div><div class="quiz-question-number">Quiz: Linked Lists</div><div class="quiz-progress">Question 1 of 20</div></div><button class="quiz-close" onclick="closeQuizModal()">✕</button></div><div class="quiz-questions-container"></div></div>`;
            document.body.appendChild(modal);
        }
    </script>
</body>
</html>