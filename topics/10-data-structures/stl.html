<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>STL - COS110 OOP Study Website</title>
    <link rel="stylesheet" href="../../css/style.css">
</head>
<body>
    <nav class="navbar">
        <a href="../../index.html" class="navbar-brand">📚 COS110 OOP</a>
        <div class="navbar-search"><input type="text" placeholder="Search topics..."></div>
    </nav>

    <div class="container">
        <aside class="sidebar">
            <div class="sidebar-title">📌 Foundations</div>
            <a href="../01-pointers/part1.html" class="sidebar-item">Pointers Part 1</a>
            <a href="../01-pointers/part2.html" class="sidebar-item">Pointers Part 2</a>

            <div class="sidebar-title">🏗️ Classes & Objects</div>
            <a href="../02-classes/basics.html" class="sidebar-item">Classes Basics</a>
            <a href="../02-classes/advanced.html" class="sidebar-item">Classes Advanced</a>
            <a href="../02-classes/more.html" class="sidebar-item">Classes More</a>

            <div class="sidebar-title">🔧 Constructors</div>
            <a href="../03-copy-constructors.html" class="sidebar-item">Copy Constructors</a>
            <a href="../04-assignment-operator.html" class="sidebar-item">Assignment Operator</a>

            <div class="sidebar-title">➕ Operators</div>
            <a href="../05-operator-overloading/basics.html" class="sidebar-item">Overloading Basics</a>
            <a href="../05-operator-overloading/friends.html" class="sidebar-item">Friends</a>
            <a href="../05-operator-overloading/references.html" class="sidebar-item">References/IO</a>
            <a href="../05-operator-overloading/increment.html" class="sidebar-item">Inc/Dec/Subscript</a>

            <div class="sidebar-title">⚠️ Exception Handling</div>
            <a href="../06-exception-handling/basics.html" class="sidebar-item">Basics</a>
            <a href="../06-exception-handling/hierarchies.html" class="sidebar-item">Hierarchies</a>

            <div class="sidebar-title">👨‍👧 Inheritance</div>
            <a href="../07-inheritance/basics.html" class="sidebar-item">Basics</a>
            <a href="../07-inheritance/redefining.html" class="sidebar-item">Redefining</a>
            <a href="../07-inheritance/aggregation.html" class="sidebar-item">Aggregation</a>

            <div class="sidebar-title">🔄 Polymorphism</div>
            <a href="../08-polymorphism/virtual-functions.html" class="sidebar-item">Virtual Functions</a>
            <a href="../08-polymorphism/pointers.html" class="sidebar-item">Pointers</a>

            <div class="sidebar-title">🎨 Templates</div>
            <a href="../09-templates/classes.html" class="sidebar-item">Classes</a>
            <a href="../09-templates/functions.html" class="sidebar-item">Functions</a>

            <div class="sidebar-title">📊 Data Structures</div>
            <a href="linked-lists.html" class="sidebar-item">Linked Lists</a>
            <a href="doubly-linked.html" class="sidebar-item">Doubly Linked</a>
            <a href="circular-lists.html" class="sidebar-item">Circular Lists</a>
            <a href="stacks.html" class="sidebar-item">Stacks</a>
            <a href="queues.html" class="sidebar-item">Queues</a>
            <a href="stl.html" class="sidebar-item">STL</a>
        </aside>

        <main class="main-content">
            <h1>📦 Standard Template Library (STL)</h1>

            <section class="section">
                <div class="section-title">📚 Explanation</div>
                <div class="explanation">
                    <h3 style="color: var(--primary);">What is STL? The Game Changer</h3>
                    <p>The <strong>Standard Template Library (STL)</strong> is a comprehensive collection of template classes and functions that provides production-ready implementations of common data structures and algorithms. Instead of manually implementing linked lists, queues, sorting algorithms, etc., STL gives you tested, optimized versions. It's one of C++'s greatest strengths and saves thousands of lines of code.</p>
                    
                    <div style="background: #f0f0f0; padding: 15px; border-radius: 8px; margin: 15px 0;">
                    <strong>Why Learn Manual Implementations Before STL?</strong><br>
                    Understanding how linked lists, stacks, and queues work internally helps you:<br>
                    • Know which STL container to use for which problem<br>
                    • Predict performance characteristics<br>
                    • Debug issues when something unexpected happens<br>
                    • Optimize when STL doesn't meet constraints<br>
                    <br>
                    <strong>Bottom Line:</strong> Learn fundamentals (your data structures course), then use STL in real projects!
                    </div>

                    <h3 style="color: var(--primary); margin-top: 25px;">STL Containers - The Three Categories</h3>
                    
                    <strong>1️⃣ Sequence Containers (Ordered by Position)</strong>
                    <table style="width: 100%; border-collapse: collapse; margin: 15px 0;">
                    <tr style="background: var(--primary); color: white;">
                        <th style="padding: 10px; border: 1px solid #999;">Container</th>
                        <th style="padding: 10px; border: 1px solid #999;">Underlying Structure</th>
                        <th style="padding: 10px; border: 1px solid #999;">Random Access</th>
                        <th style="padding: 10px; border: 1px solid #999;">Insert/Delete</th>
                        <th style="padding: 10px; border: 1px solid #999;">Use When</th>
                    </tr>
                    <tr style="background: #f9f9f9;">
                        <td style="padding: 10px; border: 1px solid #ddd;"><strong>vector</strong></td>
                        <td style="padding: 10px; border: 1px solid #ddd;">Dynamic array</td>
                        <td style="padding: 10px; border: 1px solid #ddd;">O(1)</td>
                        <td style="padding: 10px; border: 1px solid #ddd;">O(n)</td>
                        <td style="padding: 10px; border: 1px solid #ddd;">Need fast access, back insertion</td>
                    </tr>
                    <tr>
                        <td style="padding: 10px; border: 1px solid #ddd;"><strong>list</strong></td>
                        <td style="padding: 10px; border: 1px solid #ddd;">Doubly linked list</td>
                        <td style="padding: 10px; border: 1px solid #ddd;">O(n)</td>
                        <td style="padding: 10px; border: 1px solid #ddd;">O(1)</td>
                        <td style="padding: 10px; border: 1px solid #ddd;">Frequent insertions/deletions anywhere</td>
                    </tr>
                    <tr style="background: #f9f9f9;">
                        <td style="padding: 10px; border: 1px solid #ddd;"><strong>deque</strong></td>
                        <td style="padding: 10px; border: 1px solid #ddd;">Double-ended queue</td>
                        <td style="padding: 10px; border: 1px solid #ddd;">O(1)</td>
                        <td style="padding: 10px; border: 1px solid #ddd;">O(1) both ends</td>
                        <td style="padding: 10px; border: 1px solid #ddd;">Need both ends O(1) access/insert</td>
                    </tr>
                    </table>

                    <strong>2️⃣ Associative Containers (Ordered by Key/Value)</strong>
                    <table style="width: 100%; border-collapse: collapse; margin: 15px 0;">
                    <tr style="background: var(--primary); color: white;">
                        <th style="padding: 10px; border: 1px solid #999;">Container</th>
                        <th style="padding: 10px; border: 1px solid #999;">Structure</th>
                        <th style="padding: 10px; border: 1px solid #999;">Keys</th>
                        <th style="padding: 10px; border: 1px solid #999;">Order</th>
                        <th style="padding: 10px; border: 1px solid #999;">Use When</th>
                    </tr>
                    <tr style="background: #f9f9f9;">
                        <td style="padding: 10px; border: 1px solid #ddd;"><strong>set</strong></td>
                        <td style="padding: 10px; border: 1px solid #ddd;">Red-black tree</td>
                        <td style="padding: 10px; border: 1px solid #ddd;">Unique</td>
                        <td style="padding: 10px; border: 1px solid #ddd;">Sorted</td>
                        <td style="padding: 10px; border: 1px solid #ddd;">Need unique values, sorted iteration</td>
                    </tr>
                    <tr>
                        <td style="padding: 10px; border: 1px solid #ddd;"><strong>map</strong></td>
                        <td style="padding: 10px; border: 1px solid #ddd;">Red-black tree</td>
                        <td style="padding: 10px; border: 1px solid #ddd;">Unique</td>
                        <td style="padding: 10px; border: 1px solid #ddd;">Sorted by key</td>
                        <td style="padding: 10px; border: 1px solid #ddd;">Key-value pairs, need lookup O(log n)</td>
                    </tr>
                    <tr style="background: #f9f9f9;">
                        <td style="padding: 10px; border: 1px solid #ddd;"><strong>unordered_set</strong></td>
                        <td style="padding: 10px; border: 1px solid #ddd;">Hash table</td>
                        <td style="padding: 10px; border: 1px solid #ddd;">Unique</td>
                        <td style="padding: 10px; border: 1px solid #ddd;">None</td>
                        <td style="padding: 10px; border: 1px solid #ddd;">Need O(1) average lookup, order irrelevant</td>
                    </tr>
                    <tr>
                        <td style="padding: 10px; border: 1px solid #ddd;"><strong>unordered_map</strong></td>
                        <td style="padding: 10px; border: 1px solid #ddd;">Hash table</td>
                        <td style="padding: 10px; border: 1px solid #ddd;">Unique</td>
                        <td style="padding: 10px; border: 1px solid #ddd;">None</td>
                        <td style="padding: 10px; border: 1px solid #ddd;">Fast key-value lookup O(1)</td>
                    </tr>
                    <tr style="background: #f9f9f9;">
                        <td style="padding: 10px; border: 1px solid #ddd;"><strong>multiset/multimap</strong></td>
                        <td style="padding: 10px; border: 1px solid #ddd;">Red-black tree</td>
                        <td style="padding: 10px; border: 1px solid #ddd;">Duplicate allowed</td>
                        <td style="padding: 10px; border: 1px solid #ddd;">Sorted</td>
                        <td style="padding: 10px; border: 1px solid #ddd;">Multiple values per key allowed</td>
                    </tr>
                    </table>

                    <strong>3️⃣ Container Adapters (Built on Top)</strong>
                    <p><strong>stack&lt;T&gt;:</strong> Adapter using vector/list/deque underneath. LIFO operations: push(), pop(), top(). Default underlying: deque.</p>
                    <p><strong>queue&lt;T&gt;:</strong> Adapter using list/deque. FIFO operations: enqueue(), dequeue(), front(). Default underlying: deque.</p>
                    <p><strong>priority_queue&lt;T&gt;:</strong> Adapter using vector as heap. Operations respect priority. Default underlying: vector (as max-heap).</p>

                    <h3 style="color: var(--primary); margin-top: 20px;">Iterators - Pointers on Steroids</h3>
                    <div style="background: #e8f4f8; padding: 15px; border-radius: 8px; margin: 10px 0;">
                    <strong>Iterator Types (from weakest to strongest):</strong><br><br>
                    <strong>1. Input Iterator</strong> - Read-only, forward only (like reading file)<br>
                    Operations: ++, ==, !=, *<br><br>
                    
                    <strong>2. Output Iterator</strong> - Write-only, forward only (like writing file)<br>
                    Operations: ++, *<br><br>
                    
                    <strong>3. Forward Iterator</strong> - Read/write, forward only (singly linked)<br>
                    Operations: ++, ==, !=, *, -><br><br>
                    
                    <strong>4. Bidirectional Iterator</strong> - Read/write, forward and backward (doubly linked, set, map)<br>
                    Operations: ++, --, ==, !=, *, -><br><br>
                    
                    <strong>5. Random Access Iterator</strong> - Full access like pointers (vector, array, deque)<br>
                    Operations: ++, --, +, -, [], <, >, <=, >=
                    </div>

                    <strong>Iterator Usage Patterns:</strong>
                    <div style="background: #f0f0f0; padding: 15px; border-radius: 8px; margin: 10px 0; font-family: 'Courier New', monospace;">
                    vector&lt;int&gt; vec = {1, 2, 3};<br><br>
                    // Range-based for (simplest, preferred):<br>
                    for(int val : vec) { cout << val; }<br><br>
                    
                    // Traditional iterator loop:<br>
                    for(auto it = vec.begin(); it != vec.end(); ++it) {<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;cout << *it;  // Dereference iterator<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;cout << it->size();  // Arrow operator<br>
                    }<br><br>
                    
                    // Reverse iteration:<br>
                    for(auto it = vec.rbegin(); it != vec.rend(); ++it) {<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;cout << *it;  // Backward!<br>
                    }
                    </div>

                    <h3 style="color: var(--primary); margin-top: 20px;">STL Algorithms - Write Less Code</h3>
                    <p><strong>Core Concept:</strong> Algorithms are template functions that work with any container, operating on ranges defined by iterators.</p>
                    
                    <strong>Common Non-Modifying Algorithms (Read-Only):</strong>
                    <div style="background: #f0f0f0; padding: 15px; border-radius: 8px; margin: 10px 0; font-family: 'Courier New', monospace;">
                    find(begin, end, value) → iterator to first occurrence<br>
                    count(begin, end, value) → count of matching elements<br>
                    all_of(begin, end, predicate) → true if all match condition<br>
                    any_of(begin, end, predicate) → true if any match<br>
                    none_of(begin, end, predicate) → true if none match<br>
                    min_element(begin, end) → iterator to minimum<br>
                    max_element(begin, end) → iterator to maximum<br>
                    </div>

                    <strong>Common Modifying Algorithms (Change Data):</strong>
                    <div style="background: #f0f0f0; padding: 15px; border-radius: 8px; margin: 10px 0; font-family: 'Courier New', monospace;">
                    sort(begin, end) → sort container<br>
                    reverse(begin, end) → reverse order<br>
                    unique(begin, end) → remove consecutive duplicates<br>
                    transform(begin, end, dest, func) → apply function to each<br>
                    replace(begin, end, old, new) → replace all old with new<br>
                    copy(begin, end, dest) → copy range to destination<br>
                    fill(begin, end, value) → fill with value<br>
                    </div>

                    <h3 style="color: var(--primary); margin-top: 20px;">STL vs Manual Implementation</h3>
                    <table style="width: 100%; border-collapse: collapse; margin: 15px 0;">
                    <tr style="background: var(--primary); color: white;">
                        <th style="padding: 10px; border: 1px solid #999;">Aspect</th>
                        <th style="padding: 10px; border: 1px solid #999;">Manual Implementation</th>
                        <th style="padding: 10px; border: 1px solid #999;">STL</th>
                    </tr>
                    <tr style="background: #f9f9f9;">
                        <td style="padding: 10px; border: 1px solid #ddd;"><strong>Code Size</strong></td>
                        <td style="padding: 10px; border: 1px solid #ddd;">Hundreds of lines</td>
                        <td style="padding: 10px; border: 1px solid #ddd;">Single line</td>
                    </tr>
                    <tr>
                        <td style="padding: 10px; border: 1px solid #ddd;"><strong>Performance</strong></td>
                        <td style="padding: 10px; border: 1px solid #ddd;">Often suboptimal</td>
                        <td style="padding: 10px; border: 1px solid #ddd;">Highly optimized</td>
                    </tr>
                    <tr style="background: #f9f9f9;">
                        <td style="padding: 10px; border: 1px solid #ddd;"><strong>Bugs</strong></td>
                        <td style="padding: 10px; border: 1px solid #ddd;">Lots! (memory leaks, edge cases)</td>
                        <td style="padding: 10px; border: 1px solid #ddd;">Well-tested, rare</td>
                    </tr>
                    <tr>
                        <td style="padding: 10px; border: 1px solid #ddd;"><strong>Maintenance</strong></td>
                        <td style="padding: 10px; border: 1px solid #ddd;">Your responsibility</td>
                        <td style="padding: 10px; border: 1px solid #ddd;">Standard committee</td>
                    </tr>
                    <tr style="background: #f9f9f9;">
                        <td style="padding: 10px; border: 1px solid #ddd;"><strong>Learning Value</strong></td>
                        <td style="padding: 10px; border: 1px solid #ddd;">High (understand internals)</td>
                        <td style="padding: 10px; border: 1px solid #ddd;">Different (learn interfaces)</td>
                    </tr>
                    </table>

                    <h3 style="color: var(--primary); margin-top: 20px;">How to Choose an STL Container</h3>
                    <div style="background: #ffe8e8; padding: 15px; border-radius: 8px; margin: 10px 0;">
                    <strong>Decision Tree:</strong><br><br>
                    1. Do you need to search by key? → use map/unordered_map<br>
                    &nbsp;&nbsp;a. Need order? → map (slower, sorted)<br>
                    &nbsp;&nbsp;b. Need speed? → unordered_map (faster, unsorted)<br><br>
                    
                    2. Do you need unique values? → use set/unordered_set<br>
                    &nbsp;&nbsp;a. Need order? → set<br>
                    &nbsp;&nbsp;b. Need speed? → unordered_set<br><br>
                    
                    3. Is it LIFO? → stack (adapter on deque)<br>
                    4. Is it FIFO? → queue (adapter on deque)<br>
                    5. Need priority? → priority_queue<br><br>
                    
                    6. Need random access? → vector<br>
                    7. Frequent mid-insertions? → list (doubly linked)<br>
                    8. Need both ends? → deque
                    </div>

                    <h3 style="color: var(--primary); margin-top: 20px;">STL Best Practices</h3>
                    <p><strong>✅ Do This:</strong></p>
                    <p>• Use range-based for loops: `for(auto x : container)`</p>
                    <p>• Use auto for iterators: `auto it = container.begin()`</p>
                    <p>• Use algorithms: `std::sort()` instead of writing quicksort</p>
                    <p>• Use vector by default (cache-friendly, simple)</p>
                    <p>• Check if element exists: `find() != end()`</p>
                    
                    <p><strong>❌ Don't Do This:</strong></p>
                    <p>• Don't use deque for frequent random access (use vector)</p>
                    <p>• Don't use list unless you need O(1) mid-insertion (vector push_back is usually faster!)</p>
                    <p>• Don't dereference end() iterator (it's past-the-end, not valid!)</p>
                    <p>• Don't modify container while iterating (unless using erase() which returns new iterator)</p>
                    <p>• Don't use set when you just need a vector to sort/search (vector is often faster!)</p>

                    <h3 style="color: var(--primary); margin-top: 20px;">Advanced STL Concepts</h3>
                    <p><strong>Custom Comparators:</strong> Pass function/lambda to sort in custom order</p>
                    <p><strong>Lambda Functions:</strong> `auto sorted = std::sort(v.begin(), v.end(), [](int a, int b) { return a > b; });`</p>
                    <p><strong>Function Objects:</strong> Classes overloading operator() for comparisons</p>
                    <p><strong>Functional:</strong> std::less, std::greater, std::equal_to templates</p>
                </div>
            </section>

            <section class="section">
                <div class="section-title">💻 Code Examples</div>

                <div class="code-example">
                    <div class="code-tabs">
                        <button class="code-tab active" data-tab="simple1">Vector Operations</button>
                        <button class="code-tab" data-tab="full1">Full Program</button>
                    </div>
                    <div data-tab-content="simple1" class="code-editor">
#include <vector>
using namespace std;

vector<int> v;
v.push_back(10);
v.push_back(20);
v.push_back(30);

for(int val : v) {
    cout << val << " ";
}

v.pop_back();
v[0] = 100;
cout << "Size: " << v.size() << endl;
                    </div>
                    <div data-tab-content="full1" style="display: none;">
                        <textarea class="code-editor" id="code1">#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
    cout << "=== Vector ===" << endl;
    vector<int> v;
    
    v.push_back(30);
    v.push_back(10);
    v.push_back(50);
    v.push_back(20);
    v.push_back(40);
    
    cout << "Original: ";
    for(int val : v) cout << val << " ";
    cout << endl;
    
    cout << "Size: " << v.size() << endl;
    cout << "Front: " << v.front() << endl;
    cout << "Back: " << v.back() << endl;
    
    cout << "\n=== Operations ===" << endl;
    sort(v.begin(), v.end());
    cout << "After sort: ";
    for(int val : v) cout << val << " ";
    cout << endl;
    
    auto it = find(v.begin(), v.end(), 30);
    if(it != v.end()) {
        cout << "Found 30 at position " 
             << (it - v.begin()) << endl;
    }
    
    return 0;
}
                        </textarea>
                    </div>
                    <div class="code-buttons">
                        <button class="btn btn-primary" onclick="runCode(document.getElementById('code1'), document.getElementById('output1'))">▶ Run Code</button>
                        <button class="btn btn-secondary" onclick="downloadCode(document.getElementById('code1'))">⬇ Download Code</button>
                    </div>
                    <div class="output-box" id="output1">Click "Run Code" to execute...</div>
                </div>

                <div class="code-example">
                    <div class="code-tabs">
                        <button class="code-tab active" data-tab="simple2">Map & Set</button>
                        <button class="code-tab" data-tab="full2">Full Program</button>
                    </div>
                    <div data-tab-content="simple2" class="code-editor">
#include <map>
#include <set>
using namespace std;

map<string, int> ages;
ages["Alice"] = 25;
ages["Bob"] = 30;
cout << ages["Alice"] << endl;

set<int> unique_nums;
unique_nums.insert(5);
unique_nums.insert(3);
unique_nums.insert(5);  // Duplicate
for(int n : unique_nums) {
    cout << n << " ";  // 3 5 (sorted)
}
                    </div>
                    <div data-tab-content="full2" style="display: none;">
                        <textarea class="code-editor" id="code2">#include <iostream>
#include <map>
#include <set>
#include <string>
using namespace std;

int main() {
    cout << "=== Map (Key-Value) ===" << endl;
    map<string, int> scores;
    scores["Alice"] = 95;
    scores["Bob"] = 87;
    scores["Charlie"] = 92;
    scores["Alice"] = 98;  // Update
    
    cout << "Scores:" << endl;
    for(auto& p : scores) {
        cout << p.first << ": " 
             << p.second << endl;
    }
    
    cout << "\n=== Set (Unique Sorted) ===" << endl;
    set<int> numbers;
    numbers.insert(50);
    numbers.insert(30);
    numbers.insert(70);
    numbers.insert(30);  // Duplicate ignored
    numbers.insert(10);
    
    cout << "Unique numbers: ";
    for(int n : numbers) {
        cout << n << " ";
    }
    cout << endl;
    
    cout << "\n=== Operations ===" << endl;
    cout << "Contains 30: " 
         << (numbers.find(30) != numbers.end() 
             ? "Yes" : "No") << endl;
    cout << "Size: " << numbers.size() << endl;
    
    return 0;
}
                        </textarea>
                    </div>
                    <div class="code-buttons">
                        <button class="btn btn-primary" onclick="runCode(document.getElementById('code2'), document.getElementById('output2'))">▶ Run Code</button>
                        <button class="btn btn-secondary" onclick="downloadSTLAlgorithmsSkeleton(document.getElementById('code2'))">⬇ Download Code</button>
                    </div>
                    <div class="output-box" id="output2">Click "Run Code" to execute...</div>
                </div>

                <div class="code-example">
                    <div class="code-tabs">
                        <button class="code-tab active" data-tab="simple3">STL Algorithms</button>
                        <button class="code-tab" data-tab="full3">Full Program</button>
                    </div>
                    <div data-tab-content="simple3" class="code-editor">
#include <vector>
#include <algorithm>
using namespace std;

vector<int> v = {3,1,4,1,5,9,2,6};

sort(v.begin(), v.end());
reverse(v.begin(), v.end());

auto it = find(v.begin(), v.end(), 5);
int count = count(v.begin(), v.end(), 1);

fill(v.begin(), v.end(), 0);
                    </div>
                    <div data-tab-content="full3" style="display: none;">
                        <textarea class="code-editor" id="code3">#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>
using namespace std;

int main() {
    vector<int> v = {3,1,4,1,5,9,2,6,5};
    
    cout << "Original: ";
    for(int n : v) cout << n << " ";
    cout << endl;
    
    cout << "\n=== Searching ===" << endl;
    auto it = find(v.begin(), v.end(), 5);
    if(it != v.end()) {
        cout << "Found 5 at position " 
             << (it - v.begin()) << endl;
    }
    
    cout << "\n=== Counting ===" << endl;
    int freq5 = count(v.begin(), v.end(), 5);
    cout << "Count of 5: " << freq5 << endl;
    
    cout << "\n=== Sorting ===" << endl;
    sort(v.begin(), v.end());
    for(int n : v) cout << n << " ";
    cout << endl;
    
    cout << "\n=== Sum ===" << endl;
    int sum = accumulate(v.begin(), v.end(), 0);
    cout << "Sum: " << sum << endl;
    
    cout << "\n=== Reverse ===" << endl;
    reverse(v.begin(), v.end());
    for(int n : v) cout << n << " ";
    cout << endl;
    
    cout << "\n=== Min/Max ===" << endl;
    cout << "Min: " << *min_element(v.begin(), v.end()) 
         << endl;
    cout << "Max: " << *max_element(v.begin(), v.end()) 
         << endl;
    
    return 0;
}
                        </textarea>
                    </div>
                    <div class="code-buttons">
                        <button class="btn btn-primary" onclick="runCode(document.getElementById('code3'), document.getElementById('output3'))">▶ Run Code</button>
                        <button class="btn btn-secondary" onclick="downloadCode(document.getElementById('code3'))">⬇ Download Code</button>
                    </div>
                    <div class="output-box" id="output3">Click "Run Code" to execute...</div>
                </div>
            </section>

            <section class="section">
                <div class="section-title">✍️ Coding Activities</div>

                <div class="activity">
                    <div class="activity-title">⚡ Intermediate Challenge: Word Frequency Counter</div>
                    <p>Use STL map to count word frequencies from input text.</p>
                    <button class="btn btn-secondary" onclick="downloadSkeleton(`#include <iostream>
#include <map>
#include <string>
using namespace std;

int main() {
    map<string, int> wordCount;
    string word;
    
    cout << \"Enter words (empty to stop):\" << endl;
    while(cin >> word && !word.empty()) {
        wordCount[word]++;
    }
    
    // TODO: Display sorted by frequency
    
    return 0;
                    <button class="btn btn-secondary" onclick="downloadVectorSkeleton()">⬇ Download Skeleton</button>
                    <button class="collapsible">▼ Show Solution</button>
                    <div class="collapsible-content">
                        <div class="code-editor">
#include <iostream>
#include <map>
#include <vector>
#include <string>
#include <algorithm>
using namespace std;

int main() {
    map<string, int> wordCount;
    string word;
    
    cout << "Enter words (type 'end' to finish):" << endl;
    while(cin >> word && word != "end") {
        wordCount[word]++;
    }
    
    cout << "\n=== Word Frequencies ===" << endl;
    cout << "Total unique words: " 
         << wordCount.size() << endl << endl;
    
    vector<pair<string, int>> freq;
    for(auto& p : wordCount) {
        freq.push_back(p);
    }
    
    sort(freq.begin(), freq.end(),
         [](const auto& a, const auto& b) {
             return a.second > b.second;
         });
    
    for(auto& p : freq) {
        cout << p.first << ": " 
             << p.second << endl;
    }
    
    return 0;
}
                        </div>
                    </div>
                </div>

                <div class="activity">
                    <div class="activity-title">🔥 Advanced Challenge: Contact Manager</div>
                    <p>Build contact management system using STL map and string for names/phone numbers.</p>
                    <button class="btn btn-secondary" onclick="downloadSkeleton(`#include <iostream>
#include <map>
#include <string>
using namespace std;

int main() {
    map<string, string> contacts;
    int choice;
    string name, phone;
    
    do {
        cout << \"1.Add 2.Search 3.List 4.Delete 0.Exit\" << endl;
        cin >> choice;
        
        // TODO: Implement menu options
        
    } while(choice != 0);
    
    return 0;
                    <button class="btn btn-secondary" onclick="downloadSTLAlgorithmsSkeleton()">⬇ Download Skeleton</button>
                    <button class="collapsible">▼ Show Solution</button>
                    <div class="collapsible-content">
                        <div class="code-editor">
#include <iostream>
#include <map>
#include <string>
using namespace std;

int main() {
    map<string, string> contacts;
    int choice;
    string name, phone;
    
    while(true) {
        cout << "\n=== Contact Manager ===" << endl;
        cout << "1. Add Contact" << endl;
        cout << "2. Search Contact" << endl;
        cout << "3. List All" << endl;
        cout << "4. Delete Contact" << endl;
        cout << "0. Exit" << endl;
        cout << "Choice: ";
        cin >> choice;
        cin.ignore();
        
        if(choice == 1) {
            cout << "Name: ";
            getline(cin, name);
            cout << "Phone: ";
            getline(cin, phone);
            contacts[name] = phone;
            cout << "Added!" << endl;
        }
        else if(choice == 2) {
            cout << "Search name: ";
            getline(cin, name);
            auto it = contacts.find(name);
            if(it != contacts.end()) {
                cout << it->first << ": " 
                     << it->second << endl;
            } else {
                cout << "Not found" << endl;
            }
        }
        else if(choice == 3) {
            cout << "\nAll Contacts:" << endl;
            for(auto& p : contacts) {
                cout << p.first << ": " 
                     << p.second << endl;
            }
        }
        else if(choice == 4) {
            cout << "Name to delete: ";
            getline(cin, name);
            if(contacts.erase(name)) {
                cout << "Deleted!" << endl;
            } else {
                cout << "Not found" << endl;
            }
        }
        else if(choice == 0) {
            cout << "Goodbye!" << endl;
            break;
        }
        else {
            cout << "Invalid choice" << endl;
        }
    }
    
    return 0;
}
                        </div>
                    </div>
                </div>
            </section>

            <section class="section">
                <div class="section-title">📝 Knowledge Check Quiz</div>
                <div class="quiz-container">
                    <button class="quiz-btn" onclick="initializeQuiz()">▶ Start Quiz</button>
                </div>
            </section>
        </main>
    </div>

    <footer><p>COS110 OOP Study Website | November 2025</p></footer>

    <script src="../../js/main.js"></script>
    <script src="../../js/compiler.js"></script>
    <script src="../../js/quiz.js"></script>

    <script>
        function downloadVectorSkeleton() {
            const code = `#include <iostream>
#include <vector>
using namespace std;

int main() {
    vector<int> v;
    
    // TODO: Add elements using push_back()
    // Add: 10, 20, 30, 40, 50
    
    // TODO: Access and print elements
    // Use v[i] or v.at(i)
    
    // TODO: Modify element at index 2 to 35
    
    // TODO: Remove last element
    
    // TODO: Print size and capacity
    
    return 0;
}`;
            downloadSkeleton(code, 'vector_usage.cpp');
        }
        function downloadSTLAlgorithmsSkeleton() {
            const code = `#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
    vector<int> v = {64, 34, 25, 12, 22, 11, 90};
    
    // TODO: Use sort() to sort vector
    
    // TODO: Print sorted vector
    
    // TODO: Use find() to find element 25
    
    // TODO: Use count() to count occurrences of 12
    
    // TODO: Use reverse() to reverse vector
    
    // TODO: Use max_element() to find maximum
    
    return 0;
}`;
            downloadSkeleton(code, 'stl_algorithms.cpp');
        }
        function initializeQuiz() {
            const questions = [
                {type: 'multiple-choice', question: 'The STL is divided into containers, iterators, and algorithms. Why is this three-part design powerful?', options: ['It\'s just organizational; separate parts don\'t interact', 'Algorithms work with any container via iterators, enabling code reuse and flexibility', 'Each part must be used independently', 'STL actually has seven main components'], correctAnswer: 'B', explanation: 'Iterators provide abstract interface. Algorithms written for iterators work with any container. This separation enables powerful, generic programming.'},
                {type: 'true-false', question: 'A vector<int> in STL is a dynamic array that automatically resizes when capacity is exceeded, with amortized O(1) insertion at end.', correctAnswer: 'true', explanation: 'Correct. Vector resizes by multiplying capacity (typically by 1.5 or 2). Most push_back calls are O(1); occasional reallocations amortize to O(1) average.'},
                {type: 'fill-in', question: 'Difference between vector and list in STL: vector provides O(1) <span style="color: red;">_______</span> access, while list provides O(1) <span style="color: red;">_______</span> at both ends.', hint: 'random, insertion/deletion', acceptableAnswers: ['random', 'insertion', 'deletion'], explanation: 'Vector: direct indexing. List: no random access but efficient manipulation at both ends. Different use cases.'},
                {type: 'multiple-choice', question: 'An STL set<int> stores unique elements in sorted order. What is the typical complexity of insertion, deletion, and search?', options: ['O(1) all operations', 'O(log n) all operations using binary search tree internally', 'O(n) all operations', 'Varies by operation'], correctAnswer: 'B', explanation: 'Set is typically implemented as Red-Black tree. All three operations are O(log n) due to tree properties.'},
                {type: 'true-false', question: 'Using std::map<string, int> to count word frequencies: map automatically handles unique keys and allows O(log n) insertions and lookups.', correctAnswer: 'true', explanation: 'Correct. Map stores unique keys in sorted order. Each operation (insert, find, erase) is O(log n) via internal binary search tree.'},
                {type: 'fill-in', question: 'STL iterator categories, from most limited to most powerful: input, <span style="color: red;">_______</span>, forward, <span style="color: red;">_______</span>, random access.', hint: 'output, bidirectional', acceptableAnswers: ['output', 'bidirectional'], explanation: 'Five iterator categories with increasing capabilities. Random access most powerful (like pointer). Different containers support different iterator types.'},
                {type: 'multiple-choice', question: 'Why is std::sort() more efficient than manually implementing quicksort for most uses?', options: ['It\'s not; manual quicksort is always better', 'STL sort uses optimized introsort (quicksort + heapsort hybrid) with proven performance and cache optimizations', 'STL sort doesn\'t sort; it just shuffles', 'Sorting complexity is identical; only implementation differs'], correctAnswer: 'B', explanation: 'Introsort: starts with quicksort, switches to heapsort if recursion depth exceeds threshold. Prevents quicksort worst-case O(n²). Highly optimized.'},
                {type: 'true-false', question: 'std::find(container.begin(), container.end(), value) returns an iterator to the found element or container.end() if not found.', correctAnswer: 'true', explanation: 'Correct. Iterator-based search. Checking against .end() determines success: if (it != container.end()) { found; }.'},
                {type: 'fill-in', question: 'Container adapter std::stack requires underlying container (default <span style="color: red;">_______</span>), and adapter std::queue requires underlying container (default <span style="color: red;">_______</span>).', hint: 'deque, deque', acceptableAnswers: ['deque'], explanation: 'Both default to deque, which supports efficient operations at both ends. Can override with vector or list.'},
                {type: 'multiple-choice', question: 'std::priority_queue in STL is implemented using a binary heap. Extracting the maximum element is O(log n). Why is insertion O(log n)?', options: ['Heap insertion requires traversing from root to leaf maintaining heap property', 'New element inserted at end, then "bubbled up" to correct position maintaining heap property', 'Priority queue inserts are actually O(1)', 'Insertion time depends on element value'], correctAnswer: 'B', explanation: 'Insertion appends to heap then percolates up (sift-up), swapping with parent if needed. Maintains heap property in O(log n) swaps.'},
                {type: 'fill-in', question: 'Range-based for loop: for(int x : my_vector) { } internally uses <span style="color: red;">_______</span> to iterate; this proves STL containers are all <span style="color: red;">_______</span>-based.', hint: 'iterators, iterator', acceptableAnswers: ['iterators', 'iterator'], explanation: 'Range-for desugars to iterator-based loops. All containers support begin()/end() iterators.'},
                {type: 'true-false', question: 'std::unordered_map uses hash table internally, providing O(1) average insertion/lookup but no sorted order.', correctAnswer: 'true', explanation: 'Correct. Hash-based, not tree-based. O(1) average but O(n) worst-case with hash collisions. No ordering.'},
                {type: 'multiple-choice', question: 'std::lower_bound() and std::upper_bound() are binary search functions. On a sorted range, lower_bound returns iterator to first element >= value, while upper_bound returns iterator to first element > value. Usage for counting occurrences?', options: ['Cannot count using bounds; requires manual iteration', 'distance(lower_bound(x), upper_bound(x)) gives count of x', 'Both always point to same element', 'Bounds only work on std::set, not arrays'], correctAnswer: 'B', explanation: 'Perfect tool for counting duplicates: lower_bound finds first occurrence, upper_bound finds first non-occurrence. Range size = count.'},
                {type: 'fill-in', question: 'std::algorithm function std::accumulate(begin, end, initial) sums elements in range starting with initial value, returning <span style="color: red;">_______</span> (the total sum).', hint: 'sum or total', acceptableAnswers: ['sum', 'total', 'accumulated value'], explanation: 'Accumulate applies operator+ by default. Can customize with different function/lambda.'},
                {type: 'true-false', question: 'std::string in STL is implemented efficiently and supports O(1) random access via [], O(1) append via push_back with amortized capacity similar to vector.', correctAnswer: 'true', explanation: 'Correct. String is essentially vector<char>. Resizes dynamically with same amortization as vector.'},
                {type: 'multiple-choice', question: 'Creating custom comparator for std::sort or std::set: you can use a lambda, function pointer, or functor. Which is preferred in modern C++?', options: ['Function pointer for speed', 'Functor for compatibility', 'Lambda for clarity, simplicity, and compiler optimizations', 'All identical in performance'], correctAnswer: 'C', explanation: 'Lambdas are preferred: inline, readable, and compiler inlines them. Functors also work but lambdas are cleaner for simple comparisons.'},
                {type: 'fill-in', question: 'std::copy(source.begin(), source.end(), destination.begin()) copies elements from source to destination. It assumes destination has <span style="color: red;">_______</span> space already allocated.', hint: 'sufficient or enough', acceptableAnswers: ['sufficient', 'enough', 'adequate', 'required'], explanation: 'copy doesn\'t resize destination. Use std::back_inserter(dest) to auto-append if using vector.'},
                {type: 'true-false', question: 'std::reverse(begin, end) reverses elements in place. On a list, this is O(n). On a vector, this is O(n). Complexity is identical regardless of container type.', correctAnswer: 'true', explanation: 'Correct. Both require touching each element once: O(n). Container type doesn\'t affect asymptotic complexity for reverse.'},
                {type: 'multiple-choice', question: 'When to choose std::vector vs std::list: vector if you need random access and cache locality; list if you need frequent insertions/deletions in middle with no random access.', options: ['Always use vector; it\'s universally better', 'Always use list; it\'s universally better', 'Choose based on access patterns and operations', 'Both identical in performance'], correctAnswer: 'C', explanation: 'Trade-offs: vector fast for iteration/indexing but slow middle insertion. List fast for middle insertion but slow iteration. Choose by use case.'},
                {type: 'fill-in', question: 'std::make_pair and std::make_tuple are factory functions that simplify creating <span style="color: red;">_______</span> without explicit type specification via template argument deduction.', hint: 'pairs/tuples or compound types', acceptableAnswers: ['pairs', 'tuples', 'pair or tuple'], explanation: 'make_pair<int, string>(5, "hello") vs pair<int, string>(5, "hello")—make_pair is cleaner.'}
            ];

            window.quizSystem = new QuizSystem('STL', questions);
            openQuizModal();
        }

        if (!document.getElementById('quizModal')) {
            const modal = document.createElement('div');
            modal.id = 'quizModal';
            modal.className = 'quiz-modal';
            modal.innerHTML = `<div class="quiz-modal-content"><div class="quiz-header"><div><div class="quiz-question-number">Quiz: STL</div><div class="quiz-progress">Question 1 of 20</div></div><button class="quiz-close" onclick="closeQuizModal()">✕</button></div><div class="quiz-questions-container"></div></div>`;
            document.body.appendChild(modal);
        }
    </script>
</body>
</html>