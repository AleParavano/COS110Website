<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>STL - COS110 OOP Study Website</title>
    <link rel="stylesheet" href="../../css/style.css">
</head>
<body>
    <nav class="navbar">
        <a href="../../index.html" class="navbar-brand">📚 COS110 OOP</a>
        <div class="navbar-search"><input type="text" placeholder="Search topics..."></div>
    </nav>

    <div class="container">
        <aside class="sidebar">
            <div class="sidebar-title">📌 Foundations</div>
            <a href="../01-pointers/part1.html" class="sidebar-item">Pointers Part 1</a>
            <a href="../01-pointers/part2.html" class="sidebar-item">Pointers Part 2</a>

            <div class="sidebar-title">🏗️ Classes & Objects</div>
            <a href="../02-classes/basics.html" class="sidebar-item">Classes Basics</a>
            <a href="../02-classes/advanced.html" class="sidebar-item">Classes Advanced</a>
            <a href="../02-classes/more.html" class="sidebar-item">Classes More</a>

            <div class="sidebar-title">🔧 Constructors</div>
            <a href="../03-copy-constructors.html" class="sidebar-item">Copy Constructors</a>
            <a href="../04-assignment-operator.html" class="sidebar-item">Assignment Operator</a>

            <div class="sidebar-title">➕ Operators</div>
            <a href="../05-operator-overloading/basics.html" class="sidebar-item">Overloading Basics</a>
            <a href="../05-operator-overloading/friends.html" class="sidebar-item">Friends</a>
            <a href="../05-operator-overloading/references.html" class="sidebar-item">References/IO</a>
            <a href="../05-operator-overloading/increment.html" class="sidebar-item">Inc/Dec/Subscript</a>

            <div class="sidebar-title">⚠️ Exception Handling</div>
            <a href="../06-exception-handling/basics.html" class="sidebar-item">Basics</a>
            <a href="../06-exception-handling/hierarchies.html" class="sidebar-item">Hierarchies</a>

            <div class="sidebar-title">👨‍👧 Inheritance</div>
            <a href="../07-inheritance/basics.html" class="sidebar-item">Basics</a>
            <a href="../07-inheritance/redefining.html" class="sidebar-item">Redefining</a>
            <a href="../07-inheritance/aggregation.html" class="sidebar-item">Aggregation</a>

            <div class="sidebar-title">🔄 Polymorphism</div>
            <a href="../08-polymorphism/virtual-functions.html" class="sidebar-item">Virtual Functions</a>
            <a href="../08-polymorphism/pointers.html" class="sidebar-item">Pointers</a>

            <div class="sidebar-title">🎨 Templates</div>
            <a href="../09-templates/classes.html" class="sidebar-item">Classes</a>
            <a href="../09-templates/functions.html" class="sidebar-item">Functions</a>

            <div class="sidebar-title">📊 Data Structures</div>
            <a href="linked-lists.html" class="sidebar-item">Linked Lists</a>
            <a href="doubly-linked.html" class="sidebar-item">Doubly Linked</a>
            <a href="circular-lists.html" class="sidebar-item">Circular Lists</a>
            <a href="stacks.html" class="sidebar-item">Stacks</a>
            <a href="queues.html" class="sidebar-item">Queues</a>
            <a href="stl.html" class="sidebar-item">STL</a>
        </aside>

        <main class="main-content">
            <h1>📦 Standard Template Library (STL)</h1>

            <section class="section">
                <div class="section-title">📚 Explanation</div>
                <div class="explanation">
                    <h3 style="color: var(--primary);">What is STL?</h3>
                    <p>The Standard Template Library (STL) is a collection of template classes and functions providing common data structures and algorithms. It's part of the C++ Standard Library and eliminates need for manual implementation. STL includes containers (vector, list, stack, queue, map), iterators, and algorithms (sort, find, transform).</p>

                    <h3 style="color: var(--primary); margin-top: 20px;">STL Containers</h3>
                    <p>Sequence containers: vector (dynamic array), list (linked list), deque (double-ended queue). Associative containers: set (unique sorted), map (key-value pairs), multiset, multimap. Container adapters: stack, queue, priority_queue. Each has different performance characteristics for operations.</p>

                    <h3 style="color: var(--primary); margin-top: 20px;">Iterators</h3>
                    <p>Iterators are pointer-like objects enabling element access and traversal. Types: input (read-only), output (write-only), forward, bidirectional, random-access. Algorithms work with iterators making them container-independent. Learn iterator operations: ++, --, *, ->, begin(), end().</p>

                    <h3 style="color: var(--primary); margin-top: 20px;">STL Algorithms</h3>
                    <p>Sort, search, transform, count, find, replace operations work with ranges defined by iterators. Non-modifying algorithms: find, count, all_of. Modifying algorithms: sort, reverse, unique, random_shuffle. Numeric algorithms: accumulate, inner_product. Functional and powerful.</p>

                    <h3 style="color: var(--primary); margin-top: 20px;">When to Use STL</h3>
                    <p>STL is optimized, well-tested, and maintained. Use for most data structure needs instead of implementing from scratch. Exceptions: educational purpose, very specific requirements, embedded systems with strict constraints. STL provides 80% of needed functionality with minimal code.</p>
                </div>
            </section>

            <section class="section">
                <div class="section-title">💻 Code Examples</div>

                <div class="code-example">
                    <div class="code-tabs">
                        <button class="code-tab active" data-tab="simple1">Vector Operations</button>
                        <button class="code-tab" data-tab="full1">Full Program</button>
                    </div>
                    <div data-tab-content="simple1" class="code-editor">
#include <vector>
using namespace std;

vector<int> v;
v.push_back(10);
v.push_back(20);
v.push_back(30);

for(int val : v) {
    cout << val << " ";
}

v.pop_back();
v[0] = 100;
cout << "Size: " << v.size() << endl;
                    </div>
                    <div data-tab-content="full1" style="display: none;">
                        <textarea class="code-editor" id="code1">#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
    cout << "=== Vector ===" << endl;
    vector<int> v;
    
    v.push_back(30);
    v.push_back(10);
    v.push_back(50);
    v.push_back(20);
    v.push_back(40);
    
    cout << "Original: ";
    for(int val : v) cout << val << " ";
    cout << endl;
    
    cout << "Size: " << v.size() << endl;
    cout << "Front: " << v.front() << endl;
    cout << "Back: " << v.back() << endl;
    
    cout << "\n=== Operations ===" << endl;
    sort(v.begin(), v.end());
    cout << "After sort: ";
    for(int val : v) cout << val << " ";
    cout << endl;
    
    auto it = find(v.begin(), v.end(), 30);
    if(it != v.end()) {
        cout << "Found 30 at position " 
             << (it - v.begin()) << endl;
    }
    
    return 0;
}
                        </textarea>
                    </div>
                    <div class="code-buttons">
                        <button class="btn btn-primary" onclick="runCode(document.getElementById('code1'), document.getElementById('output1'))">▶ Run Code</button>
                    </div>
                    <div class="output-box" id="output1">Click "Run Code" to execute...</div>
                </div>

                <div class="code-example">
                    <div class="code-tabs">
                        <button class="code-tab active" data-tab="simple2">Map & Set</button>
                        <button class="code-tab" data-tab="full2">Full Program</button>
                    </div>
                    <div data-tab-content="simple2" class="code-editor">
#include <map>
#include <set>
using namespace std;

map<string, int> ages;
ages["Alice"] = 25;
ages["Bob"] = 30;
cout << ages["Alice"] << endl;

set<int> unique_nums;
unique_nums.insert(5);
unique_nums.insert(3);
unique_nums.insert(5);  // Duplicate
for(int n : unique_nums) {
    cout << n << " ";  // 3 5 (sorted)
}
                    </div>
                    <div data-tab-content="full2" style="display: none;">
                        <textarea class="code-editor" id="code2">#include <iostream>
#include <map>
#include <set>
#include <string>
using namespace std;

int main() {
    cout << "=== Map (Key-Value) ===" << endl;
    map<string, int> scores;
    scores["Alice"] = 95;
    scores["Bob"] = 87;
    scores["Charlie"] = 92;
    scores["Alice"] = 98;  // Update
    
    cout << "Scores:" << endl;
    for(auto& p : scores) {
        cout << p.first << ": " 
             << p.second << endl;
    }
    
    cout << "\n=== Set (Unique Sorted) ===" << endl;
    set<int> numbers;
    numbers.insert(50);
    numbers.insert(30);
    numbers.insert(70);
    numbers.insert(30);  // Duplicate ignored
    numbers.insert(10);
    
    cout << "Unique numbers: ";
    for(int n : numbers) {
        cout << n << " ";
    }
    cout << endl;
    
    cout << "\n=== Operations ===" << endl;
    cout << "Contains 30: " 
         << (numbers.find(30) != numbers.end() 
             ? "Yes" : "No") << endl;
    cout << "Size: " << numbers.size() << endl;
    
    return 0;
}
                        </textarea>
                    </div>
                    <div class="code-buttons">
                        <button class="btn btn-primary" onclick="runCode(document.getElementById('code2'), document.getElementById('output2'))">▶ Run Code</button>
                    </div>
                    <div class="output-box" id="output2">Click "Run Code" to execute...</div>
                </div>

                <div class="code-example">
                    <div class="code-tabs">
                        <button class="code-tab active" data-tab="simple3">STL Algorithms</button>
                        <button class="code-tab" data-tab="full3">Full Program</button>
                    </div>
                    <div data-tab-content="simple3" class="code-editor">
#include <vector>
#include <algorithm>
using namespace std;

vector<int> v = {3,1,4,1,5,9,2,6};

sort(v.begin(), v.end());
reverse(v.begin(), v.end());

auto it = find(v.begin(), v.end(), 5);
int count = count(v.begin(), v.end(), 1);

fill(v.begin(), v.end(), 0);
                    </div>
                    <div data-tab-content="full3" style="display: none;">
                        <textarea class="code-editor" id="code3">#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>
using namespace std;

int main() {
    vector<int> v = {3,1,4,1,5,9,2,6,5};
    
    cout << "Original: ";
    for(int n : v) cout << n << " ";
    cout << endl;
    
    cout << "\n=== Searching ===" << endl;
    auto it = find(v.begin(), v.end(), 5);
    if(it != v.end()) {
        cout << "Found 5 at position " 
             << (it - v.begin()) << endl;
    }
    
    cout << "\n=== Counting ===" << endl;
    int freq5 = count(v.begin(), v.end(), 5);
    cout << "Count of 5: " << freq5 << endl;
    
    cout << "\n=== Sorting ===" << endl;
    sort(v.begin(), v.end());
    for(int n : v) cout << n << " ";
    cout << endl;
    
    cout << "\n=== Sum ===" << endl;
    int sum = accumulate(v.begin(), v.end(), 0);
    cout << "Sum: " << sum << endl;
    
    cout << "\n=== Reverse ===" << endl;
    reverse(v.begin(), v.end());
    for(int n : v) cout << n << " ";
    cout << endl;
    
    cout << "\n=== Min/Max ===" << endl;
    cout << "Min: " << *min_element(v.begin(), v.end()) 
         << endl;
    cout << "Max: " << *max_element(v.begin(), v.end()) 
         << endl;
    
    return 0;
}
                        </textarea>
                    </div>
                    <div class="code-buttons">
                        <button class="btn btn-primary" onclick="runCode(document.getElementById('code3'), document.getElementById('output3'))">▶ Run Code</button>
                    </div>
                    <div class="output-box" id="output3">Click "Run Code" to execute...</div>
                </div>
            </section>

            <section class="section">
                <div class="section-title">✍️ Coding Activities</div>

                <div class="activity">
                    <div class="activity-title">⚡ Intermediate Challenge: Word Frequency Counter</div>
                    <p>Use STL map to count word frequencies from input text.</p>
                    <button class="btn btn-secondary" onclick="downloadCode(\`#include <iostream>
#include <map>
#include <string>
using namespace std;

int main() {
    map<string, int> wordCount;
    string word;
    
    cout << \"Enter words (empty to stop):\" << endl;
    while(cin >> word && !word.empty()) {
        wordCount[word]++;
    }
    
    // TODO: Display sorted by frequency
    
    return 0;
}\`, 'word_frequency.cpp')">⬇ Download Skeleton</button>
                    <button class="collapsible">▼ Show Solution</button>
                    <div class="collapsible-content">
                        <div class="code-editor">
#include <iostream>
#include <map>
#include <vector>
#include <string>
#include <algorithm>
using namespace std;

int main() {
    map<string, int> wordCount;
    string word;
    
    cout << "Enter words (type 'end' to finish):" << endl;
    while(cin >> word && word != "end") {
        wordCount[word]++;
    }
    
    cout << "\n=== Word Frequencies ===" << endl;
    cout << "Total unique words: " 
         << wordCount.size() << endl << endl;
    
    vector<pair<string, int>> freq;
    for(auto& p : wordCount) {
        freq.push_back(p);
    }
    
    sort(freq.begin(), freq.end(),
         [](const auto& a, const auto& b) {
             return a.second > b.second;
         });
    
    for(auto& p : freq) {
        cout << p.first << ": " 
             << p.second << endl;
    }
    
    return 0;
}
                        </div>
                    </div>
                </div>

                <div class="activity">
                    <div class="activity-title">🔥 Advanced Challenge: Contact Manager</div>
                    <p>Build contact management system using STL map and string for names/phone numbers.</p>
                    <button class="btn btn-secondary" onclick="downloadCode(\`#include <iostream>
#include <map>
#include <string>
using namespace std;

int main() {
    map<string, string> contacts;
    int choice;
    string name, phone;
    
    do {
        cout << \"1.Add 2.Search 3.List 4.Delete 0.Exit\" << endl;
        cin >> choice;
        
        // TODO: Implement menu options
        
    } while(choice != 0);
    
    return 0;
}\`, 'contact_manager.cpp')">⬇ Download Skeleton</button>
                    <button class="collapsible">▼ Show Solution</button>
                    <div class="collapsible-content">
                        <div class="code-editor">
#include <iostream>
#include <map>
#include <string>
using namespace std;

int main() {
    map<string, string> contacts;
    int choice;
    string name, phone;
    
    while(true) {
        cout << "\n=== Contact Manager ===" << endl;
        cout << "1. Add Contact" << endl;
        cout << "2. Search Contact" << endl;
        cout << "3. List All" << endl;
        cout << "4. Delete Contact" << endl;
        cout << "0. Exit" << endl;
        cout << "Choice: ";
        cin >> choice;
        cin.ignore();
        
        if(choice == 1) {
            cout << "Name: ";
            getline(cin, name);
            cout << "Phone: ";
            getline(cin, phone);
            contacts[name] = phone;
            cout << "Added!" << endl;
        }
        else if(choice == 2) {
            cout << "Search name: ";
            getline(cin, name);
            auto it = contacts.find(name);
            if(it != contacts.end()) {
                cout << it->first << ": " 
                     << it->second << endl;
            } else {
                cout << "Not found" << endl;
            }
        }
        else if(choice == 3) {
            cout << "\nAll Contacts:" << endl;
            for(auto& p : contacts) {
                cout << p.first << ": " 
                     << p.second << endl;
            }
        }
        else if(choice == 4) {
            cout << "Name to delete: ";
            getline(cin, name);
            if(contacts.erase(name)) {
                cout << "Deleted!" << endl;
            } else {
                cout << "Not found" << endl;
            }
        }
        else if(choice == 0) {
            cout << "Goodbye!" << endl;
            break;
        }
        else {
            cout << "Invalid choice" << endl;
        }
    }
    
    return 0;
}
                        </div>
                    </div>
                </div>
            </section>

            <section class="section">
                <div class="section-title">📝 Knowledge Check Quiz</div>
                <div class="quiz-container">
                    <button class="quiz-btn" onclick="initializeQuiz()">▶ Start Quiz</button>
                </div>
            </section>
        </main>
    </div>

    <footer><p>COS110 OOP Study Website | November 2025</p></footer>

    <script src="../../js/main.js"></script>
    <script src="../../js/compiler.js"></script>
    <script src="../../js/quiz.js"></script>

    <script>
        function initializeQuiz() {
            const questions = [
                {type: 'multiple-choice', question: 'The STL is divided into containers, iterators, and algorithms. Why is this three-part design powerful?', options: ['It\'s just organizational; separate parts don\'t interact', 'Algorithms work with any container via iterators, enabling code reuse and flexibility', 'Each part must be used independently', 'STL actually has seven main components'], correctAnswer: 'B', explanation: 'Iterators provide abstract interface. Algorithms written for iterators work with any container. This separation enables powerful, generic programming.'},
                {type: 'true-false', question: 'A vector<int> in STL is a dynamic array that automatically resizes when capacity is exceeded, with amortized O(1) insertion at end.', correctAnswer: 'true', explanation: 'Correct. Vector resizes by multiplying capacity (typically by 1.5 or 2). Most push_back calls are O(1); occasional reallocations amortize to O(1) average.'},
                {type: 'fill-in', question: 'Difference between vector and list in STL: vector provides O(1) <span style="color: red;">_______</span> access, while list provides O(1) <span style="color: red;">_______</span> at both ends.', hint: 'random, insertion/deletion', acceptableAnswers: ['random', 'insertion', 'deletion'], explanation: 'Vector: direct indexing. List: no random access but efficient manipulation at both ends. Different use cases.'},
                {type: 'multiple-choice', question: 'An STL set<int> stores unique elements in sorted order. What is the typical complexity of insertion, deletion, and search?', options: ['O(1) all operations', 'O(log n) all operations using binary search tree internally', 'O(n) all operations', 'Varies by operation'], correctAnswer: 'B', explanation: 'Set is typically implemented as Red-Black tree. All three operations are O(log n) due to tree properties.'},
                {type: 'true-false', question: 'Using std::map<string, int> to count word frequencies: map automatically handles unique keys and allows O(log n) insertions and lookups.', correctAnswer: 'true', explanation: 'Correct. Map stores unique keys in sorted order. Each operation (insert, find, erase) is O(log n) via internal binary search tree.'},
                {type: 'fill-in', question: 'STL iterator categories, from most limited to most powerful: input, <span style="color: red;">_______</span>, forward, <span style="color: red;">_______</span>, random access.', hint: 'output, bidirectional', acceptableAnswers: ['output', 'bidirectional'], explanation: 'Five iterator categories with increasing capabilities. Random access most powerful (like pointer). Different containers support different iterator types.'},
                {type: 'multiple-choice', question: 'Why is std::sort() more efficient than manually implementing quicksort for most uses?', options: ['It\'s not; manual quicksort is always better', 'STL sort uses optimized introsort (quicksort + heapsort hybrid) with proven performance and cache optimizations', 'STL sort doesn\'t sort; it just shuffles', 'Sorting complexity is identical; only implementation differs'], correctAnswer: 'B', explanation: 'Introsort: starts with quicksort, switches to heapsort if recursion depth exceeds threshold. Prevents quicksort worst-case O(n²). Highly optimized.'},
                {type: 'true-false', question: 'std::find(container.begin(), container.end(), value) returns an iterator to the found element or container.end() if not found.', correctAnswer: 'true', explanation: 'Correct. Iterator-based search. Checking against .end() determines success: if (it != container.end()) { found; }.'},
                {type: 'fill-in', question: 'Container adapter std::stack requires underlying container (default <span style="color: red;">_______</span>), and adapter std::queue requires underlying container (default <span style="color: red;">_______</span>).', hint: 'deque, deque', acceptableAnswers: ['deque'], explanation: 'Both default to deque, which supports efficient operations at both ends. Can override with vector or list.'},
                {type: 'multiple-choice', question: 'std::priority_queue in STL is implemented using a binary heap. Extracting the maximum element is O(log n). Why is insertion O(log n)?', options: ['Heap insertion requires traversing from root to leaf maintaining heap property', 'New element inserted at end, then "bubbled up" to correct position maintaining heap property', 'Priority queue inserts are actually O(1)', 'Insertion time depends on element value'], correctAnswer: 'B', explanation: 'Insertion appends to heap then percolates up (sift-up), swapping with parent if needed. Maintains heap property in O(log n) swaps.'},
                {type: 'fill-in', question: 'Range-based for loop: for(int x : my_vector) { } internally uses <span style="color: red;">_______</span> to iterate; this proves STL containers are all <span style="color: red;">_______</span>-based.', hint: 'iterators, iterator', acceptableAnswers: ['iterators', 'iterator'], explanation: 'Range-for desugars to iterator-based loops. All containers support begin()/end() iterators.'},
                {type: 'true-false', question: 'std::unordered_map uses hash table internally, providing O(1) average insertion/lookup but no sorted order.', correctAnswer: 'true', explanation: 'Correct. Hash-based, not tree-based. O(1) average but O(n) worst-case with hash collisions. No ordering.'},
                {type: 'multiple-choice', question: 'std::lower_bound() and std::upper_bound() are binary search functions. On a sorted range, lower_bound returns iterator to first element >= value, while upper_bound returns iterator to first element > value. Usage for counting occurrences?', options: ['Cannot count using bounds; requires manual iteration', 'distance(lower_bound(x), upper_bound(x)) gives count of x', 'Both always point to same element', 'Bounds only work on std::set, not arrays'], correctAnswer: 'B', explanation: 'Perfect tool for counting duplicates: lower_bound finds first occurrence, upper_bound finds first non-occurrence. Range size = count.'},
                {type: 'fill-in', question: 'std::algorithm function std::accumulate(begin, end, initial) sums elements in range starting with initial value, returning <span style="color: red;">_______</span> (the total sum).', hint: 'sum or total', acceptableAnswers: ['sum', 'total', 'accumulated value'], explanation: 'Accumulate applies operator+ by default. Can customize with different function/lambda.'},
                {type: 'true-false', question: 'std::string in STL is implemented efficiently and supports O(1) random access via [], O(1) append via push_back with amortized capacity similar to vector.', correctAnswer: 'true', explanation: 'Correct. String is essentially vector<char>. Resizes dynamically with same amortization as vector.'},
                {type: 'multiple-choice', question: 'Creating custom comparator for std::sort or std::set: you can use a lambda, function pointer, or functor. Which is preferred in modern C++?', options: ['Function pointer for speed', 'Functor for compatibility', 'Lambda for clarity, simplicity, and compiler optimizations', 'All identical in performance'], correctAnswer: 'C', explanation: 'Lambdas are preferred: inline, readable, and compiler inlines them. Functors also work but lambdas are cleaner for simple comparisons.'},
                {type: 'fill-in', question: 'std::copy(source.begin(), source.end(), destination.begin()) copies elements from source to destination. It assumes destination has <span style="color: red;">_______</span> space already allocated.', hint: 'sufficient or enough', acceptableAnswers: ['sufficient', 'enough', 'adequate', 'required'], explanation: 'copy doesn\'t resize destination. Use std::back_inserter(dest) to auto-append if using vector.'},
                {type: 'true-false', question: 'std::reverse(begin, end) reverses elements in place. On a list, this is O(n). On a vector, this is O(n). Complexity is identical regardless of container type.', correctAnswer: 'true', explanation: 'Correct. Both require touching each element once: O(n). Container type doesn\'t affect asymptotic complexity for reverse.'},
                {type: 'multiple-choice', question: 'When to choose std::vector vs std::list: vector if you need random access and cache locality; list if you need frequent insertions/deletions in middle with no random access.', options: ['Always use vector; it\'s universally better', 'Always use list; it\'s universally better', 'Choose based on access patterns and operations', 'Both identical in performance'], correctAnswer: 'C', explanation: 'Trade-offs: vector fast for iteration/indexing but slow middle insertion. List fast for middle insertion but slow iteration. Choose by use case.'},
                {type: 'fill-in', question: 'std::make_pair and std::make_tuple are factory functions that simplify creating <span style="color: red;">_______</span> without explicit type specification via template argument deduction.', hint: 'pairs/tuples or compound types', acceptableAnswers: ['pairs', 'tuples', 'pair or tuple'], explanation: 'make_pair<int, string>(5, "hello") vs pair<int, string>(5, "hello")—make_pair is cleaner.'}
            ];

            window.quizSystem = new QuizSystem('STL', questions);
            openQuizModal();
        }

        if (!document.getElementById('quizModal')) {
            const modal = document.createElement('div');
            modal.id = 'quizModal';
            modal.className = 'quiz-modal';
            modal.innerHTML = `<div class="quiz-modal-content"><div class="quiz-header"><div><div class="quiz-question-number">Quiz: STL</div><div class="quiz-progress">Question 1 of 20</div></div><button class="quiz-close" onclick="closeQuizModal()">✕</button></div><div class="quiz-questions-container"></div></div>`;
            document.body.appendChild(modal);
        }
    </script>
</body>
</html>