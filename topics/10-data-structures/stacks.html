<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stacks - COS110 OOP Study Website</title>
    <link rel="stylesheet" href="../../css/style.css">
</head>
<body>
    <nav class="navbar">
        <a href="../../index.html" class="navbar-brand">üìö COS110 OOP</a>
        <div class="navbar-search"><input type="text" placeholder="Search topics..."></div>
    </nav>

    <div class="container">
        <aside class="sidebar">
            <div class="sidebar-title">üìå Foundations</div>
            <a href="../01-pointers/part1.html" class="sidebar-item">Pointers Part 1</a>
            <a href="../01-pointers/part2.html" class="sidebar-item">Pointers Part 2</a>

            <div class="sidebar-title">üèóÔ∏è Classes & Objects</div>
            <a href="../02-classes/basics.html" class="sidebar-item">Classes Basics</a>
            <a href="../02-classes/advanced.html" class="sidebar-item">Classes Advanced</a>
            <a href="../02-classes/more.html" class="sidebar-item">Classes More</a>

            <div class="sidebar-title">üîß Constructors</div>
            <a href="../03-copy-constructors.html" class="sidebar-item">Copy Constructors</a>
            <a href="../04-assignment-operator.html" class="sidebar-item">Assignment Operator</a>

            <div class="sidebar-title">‚ûï Operators</div>
            <a href="../05-operator-overloading/basics.html" class="sidebar-item">Overloading Basics</a>
            <a href="../05-operator-overloading/friends.html" class="sidebar-item">Friends</a>
            <a href="../05-operator-overloading/references.html" class="sidebar-item">References/IO</a>
            <a href="../05-operator-overloading/increment.html" class="sidebar-item">Inc/Dec/Subscript</a>

            <div class="sidebar-title">‚ö†Ô∏è Exception Handling</div>
            <a href="../06-exception-handling/basics.html" class="sidebar-item">Basics</a>
            <a href="../06-exception-handling/hierarchies.html" class="sidebar-item">Hierarchies</a>

            <div class="sidebar-title">üë®‚Äçüëß Inheritance</div>
            <a href="../07-inheritance/basics.html" class="sidebar-item">Basics</a>
            <a href="../07-inheritance/redefining.html" class="sidebar-item">Redefining</a>
            <a href="../07-inheritance/aggregation.html" class="sidebar-item">Aggregation</a>

            <div class="sidebar-title">üîÑ Polymorphism</div>
            <a href="../08-polymorphism/virtual-functions.html" class="sidebar-item">Virtual Functions</a>
            <a href="../08-polymorphism/pointers.html" class="sidebar-item">Pointers</a>

            <div class="sidebar-title">üé® Templates</div>
            <a href="../09-templates/classes.html" class="sidebar-item">Classes</a>
            <a href="../09-templates/functions.html" class="sidebar-item">Functions</a>

            <div class="sidebar-title">üìä Data Structures</div>
            <a href="linked-lists.html" class="sidebar-item">Linked Lists</a>
            <a href="doubly-linked.html" class="sidebar-item">Doubly Linked</a>
            <a href="circular-lists.html" class="sidebar-item">Circular Lists</a>
            <a href="stacks.html" class="sidebar-item">Stacks</a>
            <a href="queues.html" class="sidebar-item">Queues</a>
            <a href="stl.html" class="sidebar-item">STL</a>
        </aside>

        <main class="main-content">
            <h1>üìö Stacks - LIFO Data Structure</h1>

            <section class="section">
                <div class="section-title">üìö Explanation</div>
                <div class="explanation">
                    <h3 style="color: var(--primary);">What is a Stack?</h3>
                    <p>A stack is a Last-In-First-Out (LIFO) data structure where elements are added and removed from the same end called the top. Think of a stack of plates - you add/remove from the top. Applications: function call stack, undo/redo, expression evaluation, browser history.</p>

                    <h3 style="color: var(--primary); margin-top: 20px;">Stack Operations</h3>
                    <p>Push: add element to top. Pop: remove and return element from top. Peek/Top: view top element without removing. isEmpty: check if stack is empty. All operations are O(1) time complexity. Can implement using arrays or linked lists.</p>

                    <h3 style="color: var(--primary); margin-top: 20px;">Stack Implementation</h3>
                    <p>Array-based: use index top to track top element. Linked list-based: use head pointer. Array method is simple and efficient for fixed size. Linked list allows dynamic resizing. Choose based on max size requirements and memory concerns.</p>

                    <h3 style="color: var(--primary); margin-top: 20px;">Stack Applications</h3>
                    <p>Expression evaluation: convert infix to postfix, evaluate postfix. Parentheses matching: validate balanced brackets. Function calls: call stack in programming. Undo operations: store previous states. Maze solving: backtracking with stack.</p>

                    <h3 style="color: var(--primary); margin-top: 20px;">Stack vs Queue</h3>
                    <p>Stack is LIFO (last element out first), Queue is FIFO (first element out first). Stack removes from same end it adds. Queue removes from different end. Different applications and properties make them complementary.</p>
                </div>
            </section>

            <section class="section">
                <div class="section-title">üíª Code Examples</div>

                <div class="code-example">
                    <div class="code-tabs">
                        <button class="code-tab active" data-tab="simple1">Array-based Stack</button>
                        <button class="code-tab" data-tab="full1">Full Program</button>
                    </div>
                    <div data-tab-content="simple1" class="code-editor">
template<typename T>
class Stack {
private:
    T items[100];
    int top;
public:
    Stack() : top(-1) {}
    
    void push(T val) {
        items[++top] = val;
    }
    
    T pop() {
        return items[top--];
    }
    
    T peek() {
        return items[top];
    }
    
    bool isEmpty() {
        return top == -1;
    }
};

Stack<int> s;
s.push(10);
s.push(20);
cout << s.pop() << endl;  // 20
                    </div>
                    <div data-tab-content="full1" style="display: none;">
                        <textarea class="code-editor" id="code1">#include <iostream>
using namespace std;

template<typename T>
class Stack {
private:
    static const int MAX = 100;
    T items[MAX];
    int top;
public:
    Stack() : top(-1) {
        cout << "Stack created" << endl;
    }
    
    bool isFull() {
        return top == MAX - 1;
    }
    
    bool isEmpty() {
        return top == -1;
    }
    
    void push(T val) {
        if(!isFull()) {
            items[++top] = val;
            cout << "Pushed: " << val << endl;
        } else {
            cout << "Stack full!" << endl;
        }
    }
    
    T pop() {
        if(!isEmpty()) {
            cout << "Popped: " << items[top] << endl;
            return items[top--];
        }
        return T();
    }
    
    T peek() {
        if(!isEmpty()) {
            return items[top];
        }
        return T();
    }
    
    int size() {
        return top + 1;
    }
    
    void display() {
        cout << "Stack: ";
        for(int i = 0; i <= top; i++) {
            cout << items[i] << " ";
        }
        cout << endl;
    }
};

int main() {
    Stack<int> s;
    
    cout << "\n=== Push Operations ===" << endl;
    s.push(10);
    s.push(20);
    s.push(30);
    s.push(40);
    s.display();
    
    cout << "\n=== Stack Info ===" << endl;
    cout << "Size: " << s.size() << endl;
    cout << "Top: " << s.peek() << endl;
    
    cout << "\n=== Pop Operations ===" << endl;
    s.pop();
    s.pop();
    s.display();
    
    return 0;
}
                        </textarea>
                    </div>
                    <div class="code-buttons">
                        <button class="btn btn-primary" onclick="runCode(document.getElementById('code1'), document.getElementById('output1'))">‚ñ∂ Run Code</button>
                    </div>
                    <div class="output-box" id="output1">Click "Run Code" to execute...</div>
                </div>

                <div class="code-example">
                    <div class="code-tabs">
                        <button class="code-tab active" data-tab="simple2">Balanced Parentheses</button>
                        <button class="code-tab" data-tab="full2">Full Program</button>
                    </div>
                    <div data-tab-content="simple2" class="code-editor">
bool isBalanced(string expr) {
    Stack<char> s;
    for(char c : expr) {
        if(c == '(' || c == '{') {
            s.push(c);
        } else if(c == ')' || c == '}') {
            if(s.isEmpty()) return false;
            s.pop();
        }
    }
    return s.isEmpty();
}

cout << isBalanced("{(x+y)*2}");      // true
cout << isBalanced("{(x+y)*2");       // false
                    </div>
                    <div data-tab-content="full2" style="display: none;">
                        <textarea class="code-editor" id="code2">#include <iostream>
#include <string>
#include <stack>
using namespace std;

bool isBalanced(string expr) {
    stack<char> s;
    for(char c : expr) {
        if(c == '(' || c == '[' || c == '{') {
            s.push(c);
        } else if(c == ')' || c == ']' || c == '}') {
            if(s.empty()) return false;
            
            char top = s.top();
            if((c == ')' && top != '(') ||
               (c == ']' && top != '[') ||
               (c == '}' && top != '{')) {
                return false;
            }
            s.pop();
        }
    }
    return s.empty();
}

int main() {
    vector<string> expressions = {
        "{(a+b)*c}",
        "((x+y)*2)",
        "{[a+(b*c)]}",
        "((x+y)",
        "{(x+y})",
        "[a+b)+c]"
    };
    
    cout << "=== Balanced Parentheses Check ===" << endl;
    for(const auto& expr : expressions) {
        cout << expr << ": " 
             << (isBalanced(expr) ? "BALANCED" : "NOT BALANCED") 
             << endl;
    }
    
    return 0;
}
                        </textarea>
                    </div>
                    <div class="code-buttons">
                        <button class="btn btn-primary" onclick="runCode(document.getElementById('code2'), document.getElementById('output2'))">‚ñ∂ Run Code</button>
                    </div>
                    <div class="output-box" id="output2">Click "Run Code" to execute...</div>
                </div>

                <div class="code-example">
                    <div class="code-tabs">
                        <button class="code-tab active" data-tab="simple3">Expression Evaluation</button>
                        <button class="code-tab" data-tab="full3">Full Program</button>
                    </div>
                    <div data-tab-content="simple3" class="code-editor">
int evaluatePostfix(string expr) {
    Stack<int> s;
    for(char c : expr) {
        if(isdigit(c)) {
            s.push(c - '0');
        } else {
            int b = s.pop();
            int a = s.pop();
            if(c == '+') s.push(a + b);
            else if(c == '-') s.push(a - b);
            else if(c == '*') s.push(a * b);
            else if(c == '/') s.push(a / b);
        }
    }
    return s.peek();
}

cout << evaluatePostfix("23+5*");  // 25 = (2+3)*5
                    </div>
                    <div data-tab-content="full3" style="display: none;">
                        <textarea class="code-editor" id="code3">#include <iostream>
#include <string>
#include <stack>
#include <cctype>
using namespace std;

int evaluatePostfix(string expr) {
    stack<int> s;
    
    for(char c : expr) {
        if(isdigit(c)) {
            s.push(c - '0');
        } else if(c == ' ') {
            continue;
        } else {
            int b = s.top(); s.pop();
            int a = s.top(); s.pop();
            
            if(c == '+') s.push(a + b);
            else if(c == '-') s.push(a - b);
            else if(c == '*') s.push(a * b);
            else if(c == '/') s.push(a / b);
        }
    }
    return s.top();
}

int main() {
    cout << "=== Postfix Expression Evaluation ===" << endl;
    
    cout << "23+ (2+3=5): " 
         << evaluatePostfix("23+") << endl;
    
    cout << "34*5+ (3*4+5=17): " 
         << evaluatePostfix("34*5+") << endl;
    
    cout << "123*+ (1+2*3=7): " 
         << evaluatePostfix("123*+") << endl;
    
    cout << "65-3/ ((6-5)/3=0): " 
         << evaluatePostfix("65-3/") << endl;
    
    return 0;
}
                        </textarea>
                    </div>
                    <div class="code-buttons">
                        <button class="btn btn-primary" onclick="runCode(document.getElementById('code3'), document.getElementById('output3'))">‚ñ∂ Run Code</button>
                    </div>
                    <div class="output-box" id="output3">Click "Run Code" to execute...</div>
                </div>
            </section>

            <section class="section">
                <div class="section-title">‚úçÔ∏è Coding Activities</div>

                <div class="activity">
                    <div class="activity-title">‚ö° Intermediate Challenge: Stack using Linked List</div>
                    <p>Implement stack with dynamic allocation using linked list.</p>
                    <button class="btn btn-secondary" onclick="downloadCode(\`#include <iostream>
using namespace std;

template<typename T>
struct Node {
    T data;
    Node* next;
    Node(T val) : data(val), next(nullptr) {}
};

template<typename T>
class LinkedStack {
private:
    Node<T>* head;
public:
    LinkedStack() : head(nullptr) {}
    
    // TODO: void push(T val)
    // TODO: T pop()
    // TODO: bool isEmpty()
};

int main() {
    LinkedStack<int> s;
    s.push(10);
    s.push(20);
    cout << s.pop() << endl;
    return 0;
}\`, 'linked_stack.cpp')">‚¨á Download Skeleton</button>
                    <button class="collapsible">‚ñº Show Solution</button>
                    <div class="collapsible-content">
                        <div class="code-editor">
#include <iostream>
using namespace std;

template<typename T>
struct Node {
    T data;
    Node* next;
    Node(T val) : data(val), next(nullptr) {}
};

template<typename T>
class LinkedStack {
private:
    Node<T>* head;
public:
    LinkedStack() : head(nullptr) {}
    
    void push(T val) {
        Node<T>* newNode = new Node<T>(val);
        newNode->next = head;
        head = newNode;
        cout << "Pushed: " << val << endl;
    }
    
    T pop() {
        if(isEmpty()) {
            cout << "Stack empty" << endl;
            return T();
        }
        T val = head->data;
        Node<T>* temp = head;
        head = head->next;
        cout << "Popped: " << val << endl;
        delete temp;
        return val;
    }
    
    T peek() {
        if(!isEmpty()) {
            return head->data;
        }
        return T();
    }
    
    bool isEmpty() {
        return head == nullptr;
    }
    
    ~LinkedStack() {
        while(!isEmpty()) {
            pop();
        }
    }
};

int main() {
    LinkedStack<int> s;
    
    cout << "=== Push ===" << endl;
    s.push(10);
    s.push(20);
    s.push(30);
    
    cout << "\n=== Peek ===" << endl;
    cout << "Top: " << s.peek() << endl;
    
    cout << "\n=== Pop ===" << endl;
    s.pop();
    s.pop();
    s.pop();
    
    return 0;
}
                        </div>
                    </div>
                </div>

                <div class="activity">
                    <div class="activity-title">üî• Advanced Challenge: Infix to Postfix Converter</div>
                    <p>Convert infix expressions to postfix using stack with operator precedence.</p>
                    <button class="btn btn-secondary" onclick="downloadCode(\`#include <iostream>
#include <string>
#include <cctype>
using namespace std;

// TODO: Implement infixToPostfix
// Rules:
// - Operands go to output
// - Operators use stack with precedence
// - Handle parentheses

int main() {
    cout << \"Infix: a+b*c\" << endl;
    cout << \"Postfix: \" << infixToPostfix(\"a+b*c\") << endl;
    return 0;
}\`, 'infix_to_postfix.cpp')">‚¨á Download Skeleton</button>
                    <button class="collapsible">‚ñº Show Solution</button>
                    <div class="collapsible-content">
                        <div class="code-editor">
#include <iostream>
#include <string>
#include <stack>
#include <cctype>
using namespace std;

int precedence(char op) {
    if(op == '+' || op == '-') return 1;
    if(op == '*' || op == '/') return 2;
    return 0;
}

string infixToPostfix(string infix) {
    stack<char> s;
    string postfix = "";
    
    for(int i = 0; i < infix.length(); i++) {
        char c = infix[i];
        
        if(isalnum(c)) {
            postfix += c;
        }
        else if(c == '(') {
            s.push(c);
        }
        else if(c == ')') {
            while(!s.empty() && 
                  s.top() != '(') {
                postfix += s.top();
                s.pop();
            }
            if(!s.empty()) s.pop();
        }
        else {
            while(!s.empty() && 
                  precedence(s.top()) 
                  >= precedence(c)) {
                postfix += s.top();
                s.pop();
            }
            s.push(c);
        }
    }
    
    while(!s.empty()) {
        postfix += s.top();
        s.pop();
    }
    
    return postfix;
}

int main() {
    vector<string> expressions = {
        "a+b",
        "a+b*c",
        "(a+b)*c",
        "a*b+c*d",
        "((a+b)*c)-d"
    };
    
    cout << "=== Infix to Postfix ===" << endl;
    for(const auto& expr : expressions) {
        cout << "Infix:   " << expr << endl;
        cout << "Postfix: " 
             << infixToPostfix(expr) << endl << endl;
    }
    
    return 0;
}
                        </div>
                    </div>
                </div>
            </section>

            <section class="section">
                <div class="section-title">üìù Knowledge Check Quiz</div>
                <div class="quiz-container">
                    <button class="quiz-btn" onclick="initializeQuiz()">‚ñ∂ Start Quiz</button>
                </div>
            </section>
        </main>
    </div>

    <footer><p>COS110 OOP Study Website | November 2025</p></footer>

    <script src="../../js/main.js"></script>
    <script src="../../js/compiler.js"></script>
    <script src="../../js/quiz.js"></script>

    <script>
        function initializeQuiz() {
            const questions = [
                    {type: 'multiple-choice', question: 'In a stack-based postfix evaluation of "3 4 + 2 *", why does LIFO semantics ensure operators apply to the correct operands?', options: ['It\'s arbitrary; any order would evaluate correctly', 'LIFO guarantees the top two elements are the operands for the current operator', 'Operators must be pushed before operands in postfix', 'Memory alignment requires this ordering'], correctAnswer: 'B', explanation: 'Postfix notation uses stack LIFO: when an operator is encountered, its operands are guaranteed to be the top two elements, correctly implementing operator precedence.'},
                    {type: 'true-false', question: 'A balanced parentheses checker using a stack correctly validates nesting like "{[()]}" by LIFO matching of innermost brackets.', correctAnswer: 'true', explanation: 'True. Stack LIFO semantics inherently match innermost opening brackets with closing brackets, validating nesting correctly.'},
                    {type: 'short-answer', question: 'Function Call Stack: When a function calls another, why is LIFO (stack) semantics necessary rather than FIFO (queue)?', context: 'Return addresses must restore in <<span style="color: red;">_______</span> order, the most recently called function context.', hint: 'reverse or last-in-first-out', acceptableAnswers: ['reverse', 'LIFO', 'opposite', 'reverse call'], explanation: 'Return addresses must restore in reverse call order. LIFO naturally maintains nesting: last-called function returns first.'},
                    {type: 'multiple-choice', question: 'Why does Depth-First Search use a stack while Breadth-First Search uses a queue?', options: ['It\'s arbitrary; both could use either', 'DFS needs LIFO for deepest paths; BFS needs FIFO for level-by-level traversal', 'Stacks are faster than queues', 'DFS and BFS are equivalent'], correctAnswer: 'B', explanation: 'LIFO explores current path fully before backtracking (DFS). FIFO explores all current-level nodes before advancing (BFS). Data structure choice enables algorithmic behavior.'},
                    {type: 'true-false', question: 'Converting infix to postfix notation requires understanding operator precedence to determine when operators are popped from the stack.', correctAnswer: 'true', explanation: 'Correct. Precedence rules determine when operators are popped and pushed during conversion. Higher precedence operators process before lower precedence.'},
                    {type: 'fill-in', question: 'Undo/Redo: When user performs a new action after undo, the redo stack must be cleared because the <<span style="color: red;">_______</span> forward history is no longer valid.', hint: 'old or previous', acceptableAnswers: ['old forward', 'previous', 'old', 'original'], explanation: 'New actions diverge from the undone state, invalidating the old redo history. Clearing prevents following incorrect state paths.'},
                    {type: 'multiple-choice', question: 'A stack overflow with fixed-size array-based implementation is critical because the program terminates. When is overflow recoverable?', options: ['Never; overflow always terminates', 'With linked-list stacks that grow dynamically or gracefully reject pushes', 'With increased array size allocation', 'B and C'], correctAnswer: 'D', explanation: 'Array-based stacks crash at fixed capacity. Linked stacks grow or gracefully reject. Implementation choice determines severity and recoverability.'},
                    {type: 'true-false', question: 'Deep recursion causes stack overflow by accumulating stack frames on the call stack, even with correct algorithm logic.', correctAnswer: 'true', explanation: 'True. Excessive recursion depth exhausts stack memory. Iterative solutions using explicit stacks avoid this limitation.'},
                    {type: 'short-answer', question: 'Explicit Stack vs Recursion: Why might explicit stacks be more memory-efficient than recursive calls?', context: 'Recursive calls create <<span style="color: red;">_______</span> overhead per level (local variables, return address), while explicit stacks minimize data.', hint: 'stack frame', acceptableAnswers: ['stack frame', 'context', 'metadata', 'frame overhead'], explanation: 'Each function call stores full context. Explicit stacks store only necessary algorithm data, reducing per-level memory.'},
                    {type: 'multiple-choice', question: 'Implementing a stack with linked list vs array: What operation benefits most from linked implementation?', options: ['Push efficiency', 'Dynamic size growth without reallocation overhead', 'Random access performance', 'Cache locality'], correctAnswer: 'B', explanation: 'Linked stacks avoid array resize overhead. Arrays waste memory with fixed capacity or repeatedly reallocate. Linked lists adapt naturally to dynamic growth.'},
                    {type: 'true-false', question: 'The pop operation in a stack always returns the element that was pushed first in the sequence.', correctAnswer: 'false', explanation: 'False. Pop returns the most recently pushed element (LIFO). The first element pushed is popped last.'},
                    {type: 'multiple-choice', question: 'When parsing nested expressions, why does a stack accurately handle operator precedence in infix-to-postfix conversion?', options: ['It doesn\'t; separate precedence table is needed', 'LIFO ensures lower precedence operators wait until higher precedence is resolved', 'Precedence is irrelevant to stack operations', 'Stacks automatically handle all precedence'], correctAnswer: 'B', explanation: 'Stack LIFO semantics, combined with precedence rules, ensure operators are processed in correct order. Lower precedence operators remain in stack while higher precedence is resolved.'},
                    {type: 'fill-in', question: 'Tower of Hanoi Problem: Solving Tower of Hanoi with stacks representing pegs is efficient because moving disks uses <<span style="color: red;">_______</span> operations, matching the recursive structure.', hint: 'push/pop or LIFO', acceptableAnswers: ['push/pop', 'LIFO', 'stack', 'push and pop'], explanation: 'Disk movement (push disk to peg, pop from peg) maps naturally to stack operations. LIFO ensures larger disks remain under smaller ones.'},
                    {type: 'multiple-choice', question: 'In expression evaluation, why must operands be pushed onto stack before operators when parsing postfix notation left-to-right?', options: ['Operands must come first in all notations', 'Operands are pushed; operators trigger pops for their operands already on stack', 'Operators cannot be on stack', 'Order doesn\'t matter'], correctAnswer: 'B', explanation: 'Postfix notation places operators after operands. When operator is encountered, its operands are already on stack top, ready for immediate processing.'},
                    {type: 'true-false', question: 'A stack supporting O(1) push, pop, and peek operations is possible with linked-list implementation.', correctAnswer: 'true', explanation: 'True. Linked-list stacks achieve O(1) for all operations by maintaining head pointer and manipulating only the head node.'},
                    {type: 'short-answer', question: 'Balanced Symbol Checking: Why can a stack determine if symbol pairs like (), {}, [] are balanced, but cannot verify they match?', context: 'Stacks track presence of open symbols but need <<span style="color: red;">_______</span> matching to verify corresponding pair types.', hint: 'type checking or comparison', acceptableAnswers: ['type checking', 'comparison', 'matching logic', 'validation'], explanation: 'Stack LIFO tracks nesting depth and symbol types. When closing symbol appears, it must match the top symbol\'s type‚Äîa comparison operation beyond stack semantics.'},
                    {type: 'multiple-choice', question: 'Why is the call stack in programming languages typically implemented as a stack rather than a queue or other structure?', options: ['Arbitrary choice; any structure works', 'Function returns must reverse call order; nested calls require LIFO semantics', 'Stack is the only available data structure', 'Queue would be equivalent'], correctAnswer: 'B', explanation: 'Function nesting creates call hierarchies. Innermost functions must return before outer ones, necessitating LIFO semantics.'},
                    {type: 'fill-in', question: 'DFS Tree Traversal: A stack-based DFS can explore all nodes from a starting node because the stack <<span style="color: red;">_______</span> ensures deep exploration before backtracking.', hint: 'LIFO or last-in-first-out', acceptableAnswers: ['LIFO', 'last-in-first-out', 'pop structure', 'depth-first property'], explanation: 'LIFO pops most recent unexplored node, continuing depth-first along current path before backtracking. This naturally implements DFS traversal order.'},
                    {type: 'true-false', question: 'A peek operation that returns the top element without removing it is essential for stack implementations, not just convenience.', correctAnswer: 'true', explanation: 'True. Peek allows inspection before committing to pop. Many algorithms need to check top element and conditionally pop based on its value.'},
                ];

            window.quizSystem = new QuizSystem('Stacks', questions);
            openQuizModal();
        }

        if (!document.getElementById('quizModal')) {
            const modal = document.createElement('div');
            modal.id = 'quizModal';
            modal.className = 'quiz-modal';
            modal.innerHTML = `<div class="quiz-modal-content"><div class="quiz-header"><div><div class="quiz-question-number">Quiz: Stacks</div><div class="quiz-progress">Question 1 of 20</div></div><button class="quiz-close" onclick="closeQuizModal()">‚úï</button></div><div class="quiz-questions-container"></div></div>`;
            document.body.appendChild(modal);
        }
    </script>
</body>
</html>