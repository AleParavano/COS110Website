<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Queues - COS110 OOP Study Website</title>
    <link rel="stylesheet" href="../../css/style.css">
</head>
<body>
    <nav class="navbar">
        <a href="../../index.html" class="navbar-brand">📚 COS110 OOP</a>
        <div class="navbar-search"><input type="text" placeholder="Search topics..."></div>
    </nav>

    <div class="container">
        <aside class="sidebar">
            <div class="sidebar-title">📌 Foundations</div>
            <a href="../01-pointers/part1.html" class="sidebar-item">Pointers Part 1</a>
            <a href="../01-pointers/part2.html" class="sidebar-item">Pointers Part 2</a>

            <div class="sidebar-title">🏗️ Classes & Objects</div>
            <a href="../02-classes/basics.html" class="sidebar-item">Classes Basics</a>
            <a href="../02-classes/advanced.html" class="sidebar-item">Classes Advanced</a>
            <a href="../02-classes/more.html" class="sidebar-item">Classes More</a>

            <div class="sidebar-title">🔧 Constructors</div>
            <a href="../03-copy-constructors.html" class="sidebar-item">Copy Constructors</a>
            <a href="../04-assignment-operator.html" class="sidebar-item">Assignment Operator</a>

            <div class="sidebar-title">➕ Operators</div>
            <a href="../05-operator-overloading/basics.html" class="sidebar-item">Overloading Basics</a>
            <a href="../05-operator-overloading/friends.html" class="sidebar-item">Friends</a>
            <a href="../05-operator-overloading/references.html" class="sidebar-item">References/IO</a>
            <a href="../05-operator-overloading/increment.html" class="sidebar-item">Inc/Dec/Subscript</a>

            <div class="sidebar-title">⚠️ Exception Handling</div>
            <a href="../06-exception-handling/basics.html" class="sidebar-item">Basics</a>
            <a href="../06-exception-handling/hierarchies.html" class="sidebar-item">Hierarchies</a>

            <div class="sidebar-title">👨‍👧 Inheritance</div>
            <a href="../07-inheritance/basics.html" class="sidebar-item">Basics</a>
            <a href="../07-inheritance/redefining.html" class="sidebar-item">Redefining</a>
            <a href="../07-inheritance/aggregation.html" class="sidebar-item">Aggregation</a>

            <div class="sidebar-title">🔄 Polymorphism</div>
            <a href="../08-polymorphism/virtual-functions.html" class="sidebar-item">Virtual Functions</a>
            <a href="../08-polymorphism/pointers.html" class="sidebar-item">Pointers</a>

            <div class="sidebar-title">🎨 Templates</div>
            <a href="../09-templates/classes.html" class="sidebar-item">Classes</a>
            <a href="../09-templates/functions.html" class="sidebar-item">Functions</a>

            <div class="sidebar-title">📊 Data Structures</div>
            <a href="linked-lists.html" class="sidebar-item">Linked Lists</a>
            <a href="doubly-linked.html" class="sidebar-item">Doubly Linked</a>
            <a href="circular-lists.html" class="sidebar-item">Circular Lists</a>
            <a href="stacks.html" class="sidebar-item">Stacks</a>
            <a href="queues.html" class="sidebar-item">Queues</a>
            <a href="stl.html" class="sidebar-item">STL</a>
        </aside>

        <main class="main-content">
            <h1>🚦 Queues - FIFO Data Structure</h1>

            <section class="section">
                <div class="section-title">📚 Explanation</div>
                <div class="explanation">
                    <h3 style="color: var(--primary);">What is a Queue?</h3>
                    <p>A queue is a <strong>First-In-First-Out (FIFO)</strong> data structure where elements are added at the <strong>rear</strong> (end) and removed from the <strong>front</strong> (beginning). Picture waiting in line at a store - first customer in is first customer served, maintaining fairness. Queues power printer job scheduling, network packet management, breadth-first search, and task scheduling in operating systems.</p>
                    
                    <div style="background: #f0f0f0; padding: 15px; border-radius: 8px; margin: 15px 0; font-family: 'Courier New', monospace; color: #333;">
                    <strong>Visual: Queue Operations Sequence</strong><br><br>
                    Empty Queue:<br>
                    front = -1, rear = -1<br><br>
                    
                    After Enqueue(10), Enqueue(20), Enqueue(30):<br>
                    ┌──┬──┬──┐<br>
                    │10│20│30│<br>
                    └──┴──┴──┘<br>
                    ↑         ↑<br>
                    front     rear<br><br>
                    
                    After Dequeue() - removes 10:<br>
                    ┌──┬──┐<br>
                    │20│30│<br>
                    └──┴──┘<br>
                    ↑     ↑<br>
                    front rear (First in is first out!)
                    </div>

                    <h3 style="color: var(--primary); margin-top: 25px;">Queue Operations - All O(1)</h3>
                    <p><strong>Enqueue(element):</strong> Add element to rear. Array-based: insert at rear pointer position, increment rear. Linked list: create node, attach to rear.</p>
                    <p><strong>Dequeue():</strong> Remove and return front element. Array-based: get element at front, increment front. Linked list: get head data, update head pointer.</p>
                    <p><strong>Front()/Peek():</strong> View front element without removing. Returns element at front position. Used for priority decisions before dequeue.</p>
                    <p><strong>isEmpty():</strong> Check if queue is empty. Array: front > rear or front == -1. Linked list: head == nullptr.</p>
                    <p><strong>Size():</strong> Return number of elements. Array: rear - front + 1. Linked list: traverse and count (or maintain size variable).</p>

                    <h3 style="color: var(--primary); margin-top: 20px;">The Circular Queue Problem & Solution</h3>
                    <div style="background: #ffe8e8; padding: 15px; border-radius: 8px; margin: 10px 0; font-family: 'Courier New', monospace; color: #333;">
                    <strong>Linear Queue Problem:</strong><br>
                    After many enqueue/dequeue, front pointer moves right but space on left is wasted!<br><br>
                    Example (capacity=5):<br>
                    After dequeuing from positions 0,1,2:<br>
                    [X][X][X][3][4] ← front=3, rear=4, but 3 slots unused!<br><br>
                    <strong>Circular Queue Solution:</strong><br>
                    Wrap indices around! When rear reaches end, wrap to beginning if space exists.<br><br>
                    Example (capacity=5):<br>
                    Treat as circular: [4][0][1][2][3]<br>
                    rear wraps: rear = (rear + 1) % capacity<br><br>
                    <strong>Problem:</strong> Can't distinguish empty (front==rear) from full (front==rear)!<br>
                    <strong>Solutions:</strong> (1) Keep size counter, (2) Leave one slot empty, (3) Use front pointer differently
                    </div>

                    <h3 style="color: var(--primary); margin-top: 20px;">Implementation Comparison</h3>
                    <table style="width: 100%; border-collapse: collapse; margin: 15px 0;">
                    <tr style="background: var(--primary); color: white;">
                        <th style="padding: 10px; border: 1px solid #999;">Feature</th>
                        <th style="padding: 10px; border: 1px solid #999;">Linear Array</th>
                        <th style="padding: 10px; border: 1px solid #999;">Circular Array</th>
                        <th style="padding: 10px; border: 1px solid #999;">Linked List</th>
                    </tr>
                    <tr style="background: #f9f9f9;">
                        <td style="padding: 10px; border: 1px solid #ddd;"><strong>Space Waste</strong></td>
                        <td style="padding: 10px; border: 1px solid #ddd;">High (left side)</td>
                        <td style="padding: 10px; border: 1px solid #ddd;">None</td>
                        <td style="padding: 10px; border: 1px solid #ddd;">None</td>
                    </tr>
                    <tr>
                        <td style="padding: 10px; border: 1px solid #ddd;"><strong>Operation Time</strong></td>
                        <td style="padding: 10px; border: 1px solid #ddd;">O(1)</td>
                        <td style="padding: 10px; border: 1px solid #ddd;">O(1)</td>
                        <td style="padding: 10px; border: 1px solid #ddd;">O(1)</td>
                    </tr>
                    <tr style="background: #f9f9f9;">
                        <td style="padding: 10px; border: 1px solid #ddd;"><strong>Cache Performance</strong></td>
                        <td style="padding: 10px; border: 1px solid #ddd;">Excellent</td>
                        <td style="padding: 10px; border: 1px solid #ddd;">Excellent</td>
                        <td style="padding: 10px; border: 1px solid #ddd;">Poor</td>
                    </tr>
                    </table>

                    <h3 style="color: var(--primary); margin-top: 20px;">Real-World Queue Applications</h3>
                    <p><strong>Printer Queue:</strong> Multiple computers send print jobs. Printer processes first job received, maintaining order fairness. Jobs wait their turn.</p>
                    <p><strong>Operating System Task Scheduling:</strong> CPU executes processes in queue order (round-robin). Each process gets time slice, then goes to back of queue.</p>
                    <p><strong>Breadth-First Search (BFS):</strong> Level-order graph/tree traversal. Enqueue start node, dequeue and process, enqueue all neighbors. Explores nearest nodes first.</p>
                    <p><strong>Traffic Simulation:</strong> Vehicles at intersection modeled as queue. Dequeue vehicles as light turns green. New vehicles enqueue continuously.</p>
                    <p><strong>Network Packet Routing:</strong> Routers maintain packet queues. High-traffic links cause queuing delays. Priority queues handle urgent packets.</p>
                    <p><strong>Customer Service Systems:</strong> Bank teller queues, help desks, call centers. Multiple servers dequeue customers from shared queue for load balancing.</p>

                    <h3 style="color: var(--primary); margin-top: 20px;">Deques and Priority Queues</h3>
                    <p><strong>Deque (Double-Ended Queue):</strong> Allows insertion/deletion at both ends. More flexible than regular queue. Example: browsing history (add to end, remove from front or recent end).</p>
                    <p><strong>Priority Queue:</strong> Elements dequeue by priority, not insertion order. Example: emergency room triage (critical patients served first regardless of arrival time). Usually implemented with heap for O(log n) operations.</p>

                    <h3 style="color: var(--primary); margin-top: 20px;">Common Queue Pitfalls</h3>
                    <p><strong>❌ Dequeue from empty queue:</strong> Must check isEmpty() before dequeue to prevent undefined behavior.</p>
                    <p><strong>❌ Enqueue to full queue (array-based):</strong> Check isFull() before enqueue. Use circular implementation or linked list for unlimited.</p>
                    <p><strong>❌ Empty-full confusion in circular queue:</strong> With front==rear, can't tell if empty or full. Maintain separate size counter or waste one slot.</p>
                    <p><strong>❌ Memory leaks (linked list):</strong> Must delete dequeued nodes and destructor must clean entire queue.</p>
                </div>
            </section>

            <section class="section">
                <div class="section-title">💻 Code Examples</div>

                <div class="code-example">
                    <div class="code-tabs">
                        <button class="code-tab active" data-tab="simple1">Circular Queue</button>
                        <button class="code-tab" data-tab="full1">Full Program</button>
                    </div>
                    <div data-tab-content="simple1" class="code-editor">
template<typename T>
class CircularQueue {
private:
    T items[100];
    int front, rear;
    int size;
public:
    CircularQueue() : front(0), rear(-1), size(0) {}
    
    void enqueue(T val) {
        rear = (rear + 1) % 100;
        items[rear] = val;
        size++;
    }
    
    T dequeue() {
        T val = items[front];
        front = (front + 1) % 100;
        size--;
        return val;
    }
    
    bool isEmpty() { return size == 0; }
};

CircularQueue<int> q;
q.enqueue(10);
q.enqueue(20);
cout << q.dequeue() << endl;  // 10
                    </div>
                    <div data-tab-content="full1" style="display: none;">
                        <textarea class="code-editor" id="code1">#include <iostream>
using namespace std;

template<typename T>
class CircularQueue {
private:
    static const int MAX = 100;
    T items[MAX];
    int front, rear;
    int size;
public:
    CircularQueue() : front(0), rear(-1), size(0) {
        cout << "Queue created" << endl;
    }
    
    bool isEmpty() {
        return size == 0;
    }
    
    bool isFull() {
        return size == MAX;
    }
    
    void enqueue(T val) {
        if(!isFull()) {
            rear = (rear + 1) % MAX;
            items[rear] = val;
            size++;
            cout << "Enqueued: " << val << endl;
        } else {
            cout << "Queue full!" << endl;
        }
    }
    
    T dequeue() {
        if(!isEmpty()) {
            T val = items[front];
            front = (front + 1) % MAX;
            size--;
            cout << "Dequeued: " << val << endl;
            return val;
        }
        return T();
    }
    
    T getFront() {
        if(!isEmpty()) {
            return items[front];
        }
        return T();
    }
    
    int getSize() {
        return size;
    }
};

int main() {
    CircularQueue<int> q;
    
    cout << "\n=== Enqueue ===" << endl;
    q.enqueue(10);
    q.enqueue(20);
    q.enqueue(30);
    q.enqueue(40);
    
    cout << "\n=== Queue Info ===" << endl;
    cout << "Front: " << q.getFront() << endl;
    cout << "Size: " << q.getSize() << endl;
    
    cout << "\n=== Dequeue ===" << endl;
    q.dequeue();
    q.dequeue();
    
    cout << "\n=== Remaining ===" << endl;
    cout << "Front: " << q.getFront() << endl;
    cout << "Size: " << q.getSize() << endl;
    
    return 0;
}
                        </textarea>
                    </div>
                    <div class="code-buttons">
                        <button class="btn btn-primary" onclick="runCode(document.getElementById('code1'), document.getElementById('output1'))">▶ Run Code</button>
                    </div>
                    <div class="output-box" id="output1">Click "Run Code" to execute...</div>
                </div>

                <div class="code-example">
                    <div class="code-tabs">
                        <button class="code-tab active" data-tab="simple2">Linked List Queue</button>
                        <button class="code-tab" data-tab="full2">Full Program</button>
                    </div>
                    <div data-tab-content="simple2" class="code-editor">
template<typename T>
struct Node {
    T data;
    Node* next;
    Node(T val) : data(val), next(nullptr) {}
};

template<typename T>
class Queue {
private:
    Node<T>* front;
    Node<T>* rear;
public:
    Queue() : front(nullptr), rear(nullptr) {}
    
    void enqueue(T val) {
        Node<T>* newNode = new Node<T>(val);
        if(rear == nullptr) {
            front = rear = newNode;
        } else {
            rear->next = newNode;
            rear = newNode;
        }
    }
    
    T dequeue() {
        T val = front->data;
        Node<T>* temp = front;
        front = front->next;
        delete temp;
        return val;
    }
};
                    </div>
                    <div data-tab-content="full2" style="display: none;">
                        <textarea class="code-editor" id="code2">#include <iostream>
using namespace std;

template<typename T>
struct Node {
    T data;
    Node* next;
    Node(T val) : data(val), next(nullptr) {}
};

template<typename T>
class LinkedQueue {
private:
    Node<T>* front;
    Node<T>* rear;
    int size;
public:
    LinkedQueue() : front(nullptr), rear(nullptr), size(0) {}
    
    bool isEmpty() {
        return front == nullptr;
    }
    
    void enqueue(T val) {
        Node<T>* newNode = new Node<T>(val);
        if(rear == nullptr) {
            front = rear = newNode;
        } else {
            rear->next = newNode;
            rear = newNode;
        }
        size++;
        cout << "Enqueued: " << val << endl;
    }
    
    T dequeue() {
        if(isEmpty()) {
            cout << "Queue empty" << endl;
            return T();
        }
        T val = front->data;
        Node<T>* temp = front;
        front = front->next;
        if(front == nullptr) {
            rear = nullptr;
        }
        size--;
        cout << "Dequeued: " << val << endl;
        delete temp;
        return val;
    }
    
    T getFront() {
        if(!isEmpty()) {
            return front->data;
        }
        return T();
    }
    
    int getSize() {
        return size;
    }
    
    ~LinkedQueue() {
        while(!isEmpty()) {
            dequeue();
        }
    }
};

int main() {
    LinkedQueue<int> q;
    
    cout << "=== Enqueue ===" << endl;
    q.enqueue(1);
    q.enqueue(2);
    q.enqueue(3);
    q.enqueue(4);
    q.enqueue(5);
    
    cout << "\n=== Queue Info ===" << endl;
    cout << "Front: " << q.getFront() << endl;
    cout << "Size: " << q.getSize() << endl;
    
    cout << "\n=== Dequeue ===" << endl;
    for(int i = 0; i < 3; i++) {
        q.dequeue();
    }
    
    cout << "\n=== Remaining ===" << endl;
    cout << "Front: " << q.getFront() << endl;
    cout << "Size: " << q.getSize() << endl;
    
    return 0;
}
                        </textarea>
                    </div>
                    <div class="code-buttons">
                        <button class="btn btn-primary" onclick="runCode(document.getElementById('code2'), document.getElementById('output2'))">▶ Run Code</button>
                    </div>
                    <div class="output-box" id="output2">Click "Run Code" to execute...</div>
                </div>

                <div class="code-example">
                    <div class="code-tabs">
                        <button class="code-tab active" data-tab="simple3">BFS using Queue</button>
                        <button class="code-tab" data-tab="full3">Full Program</button>
                    </div>
                    <div data-tab-content="simple3" class="code-editor">
void bfs(int start) {
    Queue<int> q;
    bool visited[10] = {false};
    
    q.enqueue(start);
    visited[start] = true;
    
    while(!q.isEmpty()) {
        int node = q.dequeue();
        cout << node << " ";
        
        for(int neighbor : adj[node]) {
            if(!visited[neighbor]) {
                q.enqueue(neighbor);
                visited[neighbor] = true;
            }
        }
    }
}

// Queue is essential for BFS!
                    </div>
                    <div data-tab-content="full3" style="display: none;">
                        <textarea class="code-editor" id="code3">#include <iostream>
#include <queue>
#include <vector>
using namespace std;

class Graph {
private:
    int vertices;
    vector<int>* adjList;
public:
    Graph(int v) : vertices(v) {
        adjList = new vector<int>[v];
    }
    
    void addEdge(int u, int v) {
        adjList[u].push_back(v);
        adjList[v].push_back(u);
    }
    
    void bfs(int start) {
        queue<int> q;
        bool* visited = new bool[vertices]{false};
        
        q.push(start);
        visited[start] = true;
        
        cout << "BFS from " << start << ": ";
        while(!q.empty()) {
            int node = q.front();
            q.pop();
            cout << node << " ";
            
            for(int neighbor : adjList[node]) {
                if(!visited[neighbor]) {
                    q.push(neighbor);
                    visited[neighbor] = true;
                }
            }
        }
        cout << endl;
        
        delete[] visited;
    }
    
    ~Graph() {
        delete[] adjList;
    }
};

int main() {
    Graph g(6);
    
    cout << "=== Building Graph ===" << endl;
    g.addEdge(0, 1);
    g.addEdge(0, 2);
    g.addEdge(1, 3);
    g.addEdge(2, 3);
    g.addEdge(2, 4);
    g.addEdge(3, 5);
    g.addEdge(4, 5);
    
    cout << "\n=== Breadth-First Search ===" << endl;
    g.bfs(0);
    
    cout << "\n=== BFS from Different Start ===" << endl;
    g.bfs(2);
    
    return 0;
}
                        </textarea>
                    </div>
                    <div class="code-buttons">
                        <button class="btn btn-primary" onclick="runCode(document.getElementById('code3'), document.getElementById('output3'))">▶ Run Code</button>
                    </div>
                    <div class="output-box" id="output3">Click "Run Code" to execute...</div>
                </div>
            </section>

            <section class="section">
                <div class="section-title">✍️ Coding Activities</div>

                <div class="activity">
                    <div class="activity-title">⚡ Intermediate Challenge: Customer Service Simulation</div>
                    <p>Simulate customers waiting in queue for service with random arrival/service times.</p>
                    <button class="btn btn-secondary" onclick="downloadCode(\`#include <iostream>
#include <queue>
using namespace std;

struct Customer {
    int id;
    int arrivalTime;
    int serviceTime;
};

// TODO: Simulate customer queue
// Track wait times and service times

int main() {
    queue<Customer> waitingLine;
    // Simulate 10 minutes
    for(int time = 0; time < 10; time++) {
        // Add random customers
        // Serve customers
    }
    return 0;
}\`, 'customer_service.cpp')">⬇ Download Skeleton</button>
                    <button class="collapsible">▼ Show Solution</button>
                    <div class="collapsible-content">
                        <div class="code-editor">
#include <iostream>
#include <queue>
#include <cstdlib>
#include <ctime>
using namespace std;

struct Customer {
    int id;
    int arrivalTime;
    int serviceTime;
    Customer(int i, int a, int s) 
        : id(i), arrivalTime(a), serviceTime(s) {}
};

int main() {
    srand(time(0));
    queue<Customer> waitingLine;
    
    int customerId = 1;
    int totalWaitTime = 0;
    int customersServed = 0;
    int serverFreeAt = 0;
    
    cout << "=== Customer Service Simulation ===" << endl;
    cout << "(10 minutes)" << endl << endl;
    
    for(int time = 0; time < 10; time++) {
        if(rand() % 3 == 0) {
            int serviceTime = (rand() % 3) + 1;
            Customer c(customerId++, time, serviceTime);
            waitingLine.push(c);
            cout << "Time " << time << ": Customer " 
                 << c.id << " arrives (service: " 
                 << c.serviceTime << "min)" << endl;
        }
        
        if(time >= serverFreeAt && !waitingLine.empty()) {
            Customer c = waitingLine.front();
            waitingLine.pop();
            
            int waitTime = time - c.arrivalTime;
            totalWaitTime += waitTime;
            customersServed++;
            serverFreeAt = time + c.serviceTime;
            
            cout << "Time " << time << ": Serving Customer " 
                 << c.id << " (waited " << waitTime 
                 << "min, service: " << c.serviceTime 
                 << "min)" << endl;
        }
    }
    
    cout << "\n=== Statistics ===" << endl;
    cout << "Customers served: " << customersServed << endl;
    cout << "Customers waiting: " << waitingLine.size() << endl;
    if(customersServed > 0) {
        cout << "Average wait time: " 
             << (double)totalWaitTime / customersServed 
             << " min" << endl;
    }
    
    return 0;
}
                        </div>
                    </div>
                </div>

                <div class="activity">
                    <div class="activity-title">🔥 Advanced Challenge: Print Job Scheduler</div>
                    <p>Queue-based printer with job priorities and print times.</p>
                    <button class="btn btn-secondary" onclick="downloadCode(\`#include <iostream>
#include <queue>
using namespace std;

struct PrintJob {
    int id;
    int pages;
    int priority;
};

// TODO: Priority queue for print jobs
// Higher priority prints first
// Track total print time

int main() {
    // Add multiple jobs with different priorities
    // Process jobs in priority order
    return 0;
}\`, 'print_scheduler.cpp')">⬇ Download Skeleton</button>
                    <button class="collapsible">▼ Show Solution</button>
                    <div class="collapsible-content">
                        <div class="code-editor">
#include <iostream>
#include <queue>
using namespace std;

struct PrintJob {
    int id;
    int pages;
    int priority;
    
    PrintJob(int i, int p, int pr) 
        : id(i), pages(p), priority(pr) {}
    
    bool operator<(const PrintJob& other) const {
        return priority < other.priority;
    }
};

int main() {
    priority_queue<PrintJob> printQueue;
    
    cout << "=== Adding Print Jobs ===" << endl;
    printQueue.push(PrintJob(1, 10, 3));
    cout << "Job 1: 10 pages, priority 3" << endl;
    
    printQueue.push(PrintJob(2, 50, 1));
    cout << "Job 2: 50 pages, priority 1" << endl;
    
    printQueue.push(PrintJob(3, 25, 5));
    cout << "Job 3: 25 pages, priority 5" << endl;
    
    printQueue.push(PrintJob(4, 15, 2));
    cout << "Job 4: 15 pages, priority 2" << endl;
    
    cout << "\n=== Processing Queue ===" << endl;
    int totalPages = 0;
    while(!printQueue.empty()) {
        PrintJob job = printQueue.top();
        printQueue.pop();
        
        totalPages += job.pages;
        cout << "Printing Job " << job.id 
             << " (" << job.pages << " pages, " 
             << "priority " << job.priority << ")" << endl;
    }
    
    cout << "\nTotal pages printed: " << totalPages << endl;
    
    return 0;
}
                        </div>
                    </div>
                </div>
            </section>

            <section class="section">
                <div class="section-title">📝 Knowledge Check Quiz</div>
                <div class="quiz-container">
                    <button class="quiz-btn" onclick="initializeQuiz()">▶ Start Quiz</button>
                </div>
            </section>
        </main>
    </div>

    <footer><p>COS110 OOP Study Website | November 2025</p></footer>

    <script src="../../js/main.js"></script>
    <script src="../../js/compiler.js"></script>
    <script src="../../js/quiz.js"></script>

    <script>
        function initializeQuiz() {
            const questions = [
                {type: 'multiple-choice', question: 'In a circular array queue, why does modulo (%) solve space waste from repeated dequeue operations?', options: ['Modulo eliminates array space need', 'Wrapping indices allows reuse of freed front space without shifting', 'Modulo increases capacity automatically', 'Prevents dequeue entirely'], correctAnswer: 'B', explanation: 'Circular indexing reuses space as elements are dequeued from front. Without modulo, freed space becomes unusable despite capacity remaining.'},
                {type: 'true-false', question: 'A simple array queue requiring O(n) shifts after each dequeue is inefficient; circular arrays achieve O(1) by reusing front space.', correctAnswer: 'true', explanation: 'Correct. Non-circular arrays shift all elements after dequeue (O(n)). Circular arrays wrap indices, achieving O(1).'},
                {type: 'short-answer', question: 'Priority Queue: Why is standard FIFO insufficient for task scheduling?', context: 'Critical tasks must execute before normal tasks regardless of arrival time, requiring <<span style="color: red;">_______</span> based ordering.', hint: 'priority', acceptableAnswers: ['priority', 'urgency', 'importance', 'priority-based'], explanation: 'FIFO ignores urgency. Priority queues extract highest-priority items first, ensuring critical tasks complete promptly.'},
                {type: 'multiple-choice', question: 'In BFS graph traversal, why does FIFO guarantee level-by-level discovery rather than depth-first?', options: ['Queues inherently faster', 'FIFO processes shallower nodes before deeper ones discovered later', 'BFS always explores depth-first regardless', 'Identical traversal order'], correctAnswer: 'B', explanation: 'FIFO ensures newly discovered nodes wait behind shallower nodes. Shallowest nodes are processed completely before advancing level.'},
                {type: 'true-false', question: 'A circular queue distinguishes empty (rear == front) from full (rear == front) conditions automatically due to circular nature.', correctAnswer: 'false', explanation: 'False. Both conditions can have rear == front depending on implementation. Distinguishing requires size counter or sentinel values.'},
                {type: 'fill-in', question: 'Queue Simulation: Calculating average wait time requires tracking both <<span style="color: red;">_______</span> and service start time to compute duration in queue.', hint: 'arrival', acceptableAnswers: ['arrival time', 'arrival', 'join time'], explanation: 'Wait time = service start - arrival time. Both timestamps needed to calculate how long customer was queued.'},
                {type: 'multiple-choice', question: 'A deque (double-ended queue) enables insertion and deletion at both ends. What real-world scenario benefits?', options: ['Linear printing jobs', 'Browser history with back/forward navigation', 'Stack-like function calls', 'All equally'], correctAnswer: 'B', explanation: 'Browser history needs both-end operations: navigate back (remove), forward (re-add), or push new (add rear). Deque is natural fit.'},
                {type: 'true-false', question: 'Linked-list and circular-array queues both achieve O(1) enqueue/dequeue, making choice purely about implementation convenience.', correctAnswer: 'false', explanation: 'False. Both achieve O(1) but differ in space efficiency (linked overhead vs array waste) and cache locality (arrays better).'},
                {type: 'short-answer', question: 'Printer Queue: Why is a priority-queue better than strict FIFO for shared office printer?', context: 'Single-page urgent jobs should not wait behind <<span style="color: red;">_______</span> multipage low-priority jobs.', hint: 'large or lengthy', acceptableAnswers: ['large', 'lengthy', 'big', 'long'], explanation: 'Priority respects urgency. Pure FIFO delays urgent short jobs behind lengthy jobs, frustrating users. Priority queue balances fairness with responsiveness.'},
                {type: 'multiple-choice', question: 'Why is detecting if a queue is full in a circular array with n slots tricky even with front and rear pointers?', options: ['It\'s simple; rear == front indicates full', 'Rear == front can mean empty or full; size counter or sentinel distinguishes', 'Full detection is impossible', 'All positions invalid'], correctAnswer: 'B', explanation: 'Ambiguity arises: rear == front after dequeuing all elements (empty) or after enqueuing n elements (full). Resolving requires additional state.'},
                {type: 'fill-in', question: 'Enqueue at Rear: In a queue, adding elements occurs at the <<span style="color: red;">_______</span> to maintain FIFO ordering for later dequeue.', hint: 'rear', acceptableAnswers: ['rear', 'back', 'end'], explanation: 'New elements enqueue at rear; oldest elements dequeue from front, maintaining first-in-first-out order.'},
                {type: 'multiple-choice', question: 'Task Scheduling with Queue: When processes arrive at different times, why do queues handle scheduling correctly compared to arrays?', options: ['Arrays cannot store processes', 'Queues naturally order by arrival; array management requires sorting', 'Identical capability', 'Queues are arbitrary choice'], correctAnswer: 'B', explanation: 'Queues maintain arrival order implicitly through FIFO. Arrays need sorting logic. Queue structure matches problem requirements naturally.'},
                {type: 'true-false', question: 'A bounded queue with maximum capacity n can always accommodate n+1 elements by resizing the underlying array.', correctAnswer: 'false', explanation: 'False. A bounded queue by definition enforces capacity. Resizing changes it from bounded to unbounded, fundamentally altering the constraint.'},
                {type: 'short-answer', question: 'Message Queue System: Why is a FIFO queue ideal for message processing where order matters?', context: 'Processing messages in <<span style="color: red;">_______</span> order ensures causality; a message depending on a prior message is processed correctly.', hint: 'arrival or received', acceptableAnswers: ['arrival', 'received', 'order received', 'reception order'], explanation: 'FIFO order maintains causality. Messages processed in arrival sequence ensures dependencies are satisfied—critical for correctness.'},
                {type: 'multiple-choice', question: 'In a linked-list queue, why is maintaining both head (for dequeue) and rear (for enqueue) pointers essential?', options: ['Arbitrary choice', 'Head enables O(1) dequeue; rear enables O(1) enqueue without full traversal', 'One pointer suffices', 'Pointers unnecessary'], correctAnswer: 'B', explanation: 'Without both: head-only requires O(n) traversal for enqueue; rear-only requires O(n) for dequeue. Both pointers achieve O(1) for both operations.'},
                {type: 'fill-in', question: 'BFS Exploration: When traversing a graph level-by-level with a queue, the <<span style="color: red;">_______</span> pointer advances through all nodes at current depth before next level.', hint: 'front', acceptableAnswers: ['front', 'dequeue pointer'], explanation: 'Dequeue pointer processes current-level nodes. Each node enqueues its neighbors. All current-level nodes process before any next-level node.'},
                {type: 'true-false', question: 'A queue can be implemented as a stack of stacks by reversing elements twice to achieve FIFO behavior.', correctAnswer: 'true', explanation: 'True. Reversing twice returns elements to original order: reverse → LIFO becomes FIFO → reverse restores sequence.'},
                {type: 'multiple-choice', question: 'Why is implementing a queue using two stacks efficient despite the added complexity?', options: ['No advantage; inefficient', 'Amortized O(1) dequeue when done in batches, efficiently uses stack structure', 'Identical to direct queue', 'Two stacks are always slower'], correctAnswer: 'B', explanation: 'Lazy reversal of the input stack for dequeue amortizes cost across multiple operations. Each element reverses once, achieving amortized O(1).'},
                {type: 'fill-in', question: 'Circular Queue Capacity: For a circular array of size n with front and rear pointers, the maximum number of elements that can be enqueued is <<span style="color: red;">_______</span>.', hint: 'n-1 or n', acceptableAnswers: ['n-1', 'n', 'maximum n', 'up to n'], explanation: 'Some implementations reserve one slot empty to distinguish full (rear == front-1) from empty (rear == front), limiting capacity to n-1.'},
            ];

            window.quizSystem = new QuizSystem('Queues', questions);
            openQuizModal();
        }

        if (!document.getElementById('quizModal')) {
            const modal = document.createElement('div');
            modal.id = 'quizModal';
            modal.className = 'quiz-modal';
            modal.innerHTML = `<div class="quiz-modal-content"><div class="quiz-header"><div><div class="quiz-question-number">Quiz: Queues</div><div class="quiz-progress">Question 1 of 20</div></div><button class="quiz-close" onclick="closeQuizModal()">✕</button></div><div class="quiz-questions-container"></div></div>`;
            document.body.appendChild(modal);
        }
    </script>
</body>
</html>