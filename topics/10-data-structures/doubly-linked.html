<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Doubly Linked Lists - COS110 OOP Study Website</title>
    <link rel="stylesheet" href="../../css/style.css">
</head>
<body>
    <nav class="navbar">
        <a href="../../index.html" class="navbar-brand">📚 COS110 OOP</a>
        <div class="navbar-search"><input type="text" placeholder="Search topics..."></div>
    </nav>

    <div class="container">
        <aside class="sidebar">
            <div class="sidebar-title">📌 Foundations</div>
            <a href="../01-pointers/part1.html" class="sidebar-item">Pointers Part 1</a>
            <a href="../01-pointers/part2.html" class="sidebar-item">Pointers Part 2</a>

            <div class="sidebar-title">🏗️ Classes & Objects</div>
            <a href="../02-classes/basics.html" class="sidebar-item">Classes Basics</a>
            <a href="../02-classes/advanced.html" class="sidebar-item">Classes Advanced</a>
            <a href="../02-classes/more.html" class="sidebar-item">Classes More</a>

            <div class="sidebar-title">🔧 Constructors</div>
            <a href="../03-copy-constructors.html" class="sidebar-item">Copy Constructors</a>
            <a href="../04-assignment-operator.html" class="sidebar-item">Assignment Operator</a>

            <div class="sidebar-title">➕ Operators</div>
            <a href="../05-operator-overloading/basics.html" class="sidebar-item">Overloading Basics</a>
            <a href="../05-operator-overloading/friends.html" class="sidebar-item">Friends</a>
            <a href="../05-operator-overloading/references.html" class="sidebar-item">References/IO</a>
            <a href="../05-operator-overloading/increment.html" class="sidebar-item">Inc/Dec/Subscript</a>

            <div class="sidebar-title">⚠️ Exception Handling</div>
            <a href="../06-exception-handling/basics.html" class="sidebar-item">Basics</a>
            <a href="../06-exception-handling/hierarchies.html" class="sidebar-item">Hierarchies</a>

            <div class="sidebar-title">👨‍👧 Inheritance</div>
            <a href="../07-inheritance/basics.html" class="sidebar-item">Basics</a>
            <a href="../07-inheritance/redefining.html" class="sidebar-item">Redefining</a>
            <a href="../07-inheritance/aggregation.html" class="sidebar-item">Aggregation</a>

            <div class="sidebar-title">🔄 Polymorphism</div>
            <a href="../08-polymorphism/virtual-functions.html" class="sidebar-item">Virtual Functions</a>
            <a href="../08-polymorphism/pointers.html" class="sidebar-item">Pointers</a>

            <div class="sidebar-title">🎨 Templates</div>
            <a href="../09-templates/classes.html" class="sidebar-item">Classes</a>
            <a href="../09-templates/functions.html" class="sidebar-item">Functions</a>

            <div class="sidebar-title">📊 Data Structures</div>
            <a href="linked-lists.html" class="sidebar-item">Linked Lists</a>
            <a href="doubly-linked.html" class="sidebar-item">Doubly Linked</a>
            <a href="circular-lists.html" class="sidebar-item">Circular Lists</a>
            <a href="stacks.html" class="sidebar-item">Stacks</a>
            <a href="queues.html" class="sidebar-item">Queues</a>
            <a href="stl.html" class="sidebar-item">STL</a>
        </aside>

        <main class="main-content">
            <h1>🔗 Doubly Linked Lists</h1>

            <section class="section">
                <div class="section-title">📚 Explanation</div>
                <div class="explanation">
                    <h3 style="color: var(--primary);">Doubly Linked List Structure</h3>
                    <p>A doubly linked list has nodes with three components: data, next pointer, and previous pointer. This allows traversal in both directions - forward through next pointers and backward through previous pointers. The first node's previous is nullptr, and the last node's next is nullptr.</p>

                    <h3 style="color: var(--primary); margin-top: 20px;">Bidirectional Traversal</h3>
                    <p>Doubly linked lists enable reverse traversal without recursion. You can start from the head and move backward using prev pointers. This is useful for operations like undo/redo, bidirectional searching, and displaying lists in reverse order.</p>

                    <h3 style="color: var(--primary); margin-top: 20px;">Insertion in Doubly Linked Lists</h3>
                    <p>When inserting, you must update both next and previous pointers. Insert at beginning: new node's next = head, head->prev = new node. Insert in middle: update both neighbors' pointers. Proper pointer manipulation prevents data loss and maintains list integrity.</p>

                    <h3 style="color: var(--primary); margin-top: 20px;">Deletion in Doubly Linked Lists</h3>
                    <p>Deletion is safer in doubly linked lists because you can access both neighbors directly. Find the node, update previous->next and next->prev pointers, then delete. No need to track the predecessor separately, reducing code complexity.</p>

                    <h3 style="color: var(--primary); margin-top: 20px;">Memory and Complexity Trade-offs</h3>
                    <p>Doubly linked lists use more memory (extra pointer per node) but enable faster operations. Some operations that need backward traversal are O(n) in singly linked but O(n) forward in doubly linked. Trade memory for functionality depending on use case.</p>
                </div>
            </section>

            <section class="section">
                <div class="section-title">💻 Code Examples</div>

                <div class="code-example">
                    <div class="code-tabs">
                        <button class="code-tab active" data-tab="simple1">Basic Doubly Linked List</button>
                        <button class="code-tab" data-tab="full1">Full Program</button>
                    </div>
                    <div data-tab-content="simple1" class="code-editor">
struct Node {
    int data;
    Node* next;
    Node* prev;
    Node(int val) : data(val), next(nullptr), 
                    prev(nullptr) {}
};

class DoublyLinkedList {
private:
    Node* head;
public:
    DoublyLinkedList() : head(nullptr) {}
    
    void insertAtBegin(int val) {
        Node* newNode = new Node(val);
        if(head == nullptr) {
            head = newNode;
            return;
        }
        newNode->next = head;
        head->prev = newNode;
        head = newNode;
    }
    
    void displayForward() {
        Node* curr = head;
        while(curr != nullptr) {
            cout << curr->data << " -> ";
            curr = curr->next;
        }
        cout << "NULL" << endl;
    }
};
                    </div>
                    <div data-tab-content="full1" style="display: none;">
                        <textarea class="code-editor" id="code1">#include <iostream>
using namespace std;

struct Node {
    int data;
    Node* next;
    Node* prev;
    Node(int val) : data(val), next(nullptr), 
                    prev(nullptr) {}
};

class DoublyLinkedList {
private:
    Node* head;
public:
    DoublyLinkedList() : head(nullptr) {}
    
    void insertAtBegin(int val) {
        Node* newNode = new Node(val);
        if(head == nullptr) {
            head = newNode;
            return;
        }
        newNode->next = head;
        head->prev = newNode;
        head = newNode;
    }
    
    void insertAtEnd(int val) {
        Node* newNode = new Node(val);
        if(head == nullptr) {
            head = newNode;
            return;
        }
        Node* curr = head;
        while(curr->next != nullptr) {
            curr = curr->next;
        }
        curr->next = newNode;
        newNode->prev = curr;
    }
    
    void displayForward() {
        cout << "Forward: ";
        Node* curr = head;
        while(curr != nullptr) {
            cout << curr->data << " -> ";
            curr = curr->next;
        }
        cout << "NULL" << endl;
    }
    
    void displayBackward() {
        cout << "Backward: ";
        Node* curr = head;
        if(curr == nullptr) {
            cout << "NULL" << endl;
            return;
        }
        while(curr->next != nullptr) {
            curr = curr->next;
        }
        while(curr != nullptr) {
            cout << curr->data << " -> ";
            curr = curr->prev;
        }
        cout << "NULL" << endl;
    }
    
    ~DoublyLinkedList() {
        Node* curr = head;
        while(curr != nullptr) {
            Node* temp = curr;
            curr = curr->next;
            delete temp;
        }
    }
};

int main() {
    DoublyLinkedList list;
    
    cout << "=== Inserting ===" << endl;
    list.insertAtEnd(10);
    list.insertAtEnd(20);
    list.insertAtEnd(30);
    
    cout << "\n=== Insert at Begin ===" << endl;
    list.insertAtBegin(5);
    list.insertAtBegin(1);
    
    list.displayForward();
    list.displayBackward();
    
    return 0;
}
                        </textarea>
                    </div>
                    <div class="code-buttons">
                        <button class="btn btn-primary" onclick="runCode(document.getElementById('code1'), document.getElementById('output1'))">▶ Run Code</button>
                    </div>
                    <div class="output-box" id="output1">Click "Run Code" to execute...</div>
                </div>

                <div class="code-example">
                    <div class="code-tabs">
                        <button class="code-tab active" data-tab="simple2">Deletion</button>
                        <button class="code-tab" data-tab="full2">Full Program</button>
                    </div>
                    <div data-tab-content="simple2" class="code-editor">
void deleteNode(Node* node) {
    if(node == nullptr) return;
    
    if(node->prev != nullptr) {
        node->prev->next = node->next;
    } else {
        head = node->next;
    }
    
    if(node->next != nullptr) {
        node->next->prev = node->prev;
    }
    
    delete node;
}

// Easier deletion - access both neighbors!
                    </div>
                    <div data-tab-content="full2" style="display: none;">
                        <textarea class="code-editor" id="code2">#include <iostream>
using namespace std;

struct Node {
    int data;
    Node* next;
    Node* prev;
    Node(int val) : data(val), next(nullptr), 
                    prev(nullptr) {}
};

class DoublyLinkedList {
private:
    Node* head;
public:
    DoublyLinkedList() : head(nullptr) {}
    
    void insertAtEnd(int val) {
        Node* newNode = new Node(val);
        if(head == nullptr) {
            head = newNode;
            return;
        }
        Node* curr = head;
        while(curr->next != nullptr) {
            curr = curr->next;
        }
        curr->next = newNode;
        newNode->prev = curr;
    }
    
    void deleteFromBegin() {
        if(head == nullptr) return;
        cout << "Deleting: " << head->data << endl;
        Node* temp = head;
        head = head->next;
        if(head != nullptr) {
            head->prev = nullptr;
        }
        delete temp;
    }
    
    void deleteFromEnd() {
        if(head == nullptr) return;
        
        Node* curr = head;
        while(curr->next != nullptr) {
            curr = curr->next;
        }
        cout << "Deleting: " << curr->data << endl;
        
        if(curr->prev != nullptr) {
            curr->prev->next = nullptr;
        } else {
            head = nullptr;
        }
        delete curr;
    }
    
    void displayForward() {
        cout << "Forward: ";
        Node* curr = head;
        while(curr != nullptr) {
            cout << curr->data << " -> ";
            curr = curr->next;
        }
        cout << "NULL" << endl;
    }
    
    ~DoublyLinkedList() {
        while(head != nullptr) {
            deleteFromBegin();
        }
    }
};

int main() {
    DoublyLinkedList list;
    
    cout << "=== Building ===" << endl;
    for(int i = 10; i <= 50; i += 10) {
        list.insertAtEnd(i);
    }
    list.displayForward();
    
    cout << "\n=== Delete from Begin ===" << endl;
    list.deleteFromBegin();
    list.displayForward();
    
    cout << "\n=== Delete from End ===" << endl;
    list.deleteFromEnd();
    list.displayForward();
    
    return 0;
}
                        </textarea>
                    </div>
                    <div class="code-buttons">
                        <button class="btn btn-primary" onclick="runCode(document.getElementById('code2'), document.getElementById('output2'))">▶ Run Code</button>
                    </div>
                    <div class="output-box" id="output2">Click "Run Code" to execute...</div>
                </div>

                <div class="code-example">
                    <div class="code-tabs">
                        <button class="code-tab active" data-tab="simple3">Bidirectional Traversal</button>
                        <button class="code-tab" data-tab="full3">Full Program</button>
                    </div>
                    <div data-tab-content="simple3" class="code-editor">
void displayBackward() {
    // Find last node
    Node* curr = head;
    while(curr->next != nullptr) {
        curr = curr->next;
    }
    
    // Traverse backward using prev
    cout << "Backward: ";
    while(curr != nullptr) {
        cout << curr->data << " -> ";
        curr = curr->prev;
    }
    cout << "NULL" << endl;
}

// Can now traverse in both directions!
                    </div>
                    <div data-tab-content="full3" style="display: none;">
                        <textarea class="code-editor" id="code3">#include <iostream>
using namespace std;

struct Node {
    int data;
    Node* next;
    Node* prev;
    Node(int val) : data(val), next(nullptr), 
                    prev(nullptr) {}
};

class DoublyLinkedList {
private:
    Node* head;
public:
    DoublyLinkedList() : head(nullptr) {}
    
    void insert(int val) {
        Node* newNode = new Node(val);
        if(head == nullptr) {
            head = newNode;
            return;
        }
        Node* curr = head;
        while(curr->next != nullptr) {
            curr = curr->next;
        }
        curr->next = newNode;
        newNode->prev = curr;
    }
    
    void displayForward() {
        cout << "Forward:  ";
        Node* curr = head;
        while(curr != nullptr) {
            cout << curr->data << " -> ";
            curr = curr->next;
        }
        cout << "NULL" << endl;
    }
    
    void displayBackward() {
        cout << "Backward: ";
        Node* curr = head;
        if(curr == nullptr) {
            cout << "NULL" << endl;
            return;
        }
        while(curr->next != nullptr) {
            curr = curr->next;
        }
        while(curr != nullptr) {
            cout << curr->data << " -> ";
            curr = curr->prev;
        }
        cout << "NULL" << endl;
    }
    
    int sumForward() {
        int sum = 0;
        Node* curr = head;
        while(curr != nullptr) {
            sum += curr->data;
            curr = curr->next;
        }
        return sum;
    }
    
    int sumBackward() {
        int sum = 0;
        Node* curr = head;
        if(curr == nullptr) return sum;
        
        while(curr->next != nullptr) {
            curr = curr->next;
        }
        while(curr != nullptr) {
            sum += curr->data;
            curr = curr->prev;
        }
        return sum;
    }
    
    ~DoublyLinkedList() {
        Node* curr = head;
        while(curr != nullptr) {
            Node* temp = curr;
            curr = curr->next;
            delete temp;
        }
    }
};

int main() {
    DoublyLinkedList list;
    
    cout << "=== Building List ===" << endl;
    for(int i = 1; i <= 5; i++) {
        list.insert(i * 10);
    }
    
    cout << "\n=== Display Both Directions ===" << endl;
    list.displayForward();
    list.displayBackward();
    
    cout << "\n=== Sum Both Directions ===" << endl;
    cout << "Forward sum: " << list.sumForward() << endl;
    cout << "Backward sum: " << list.sumBackward() << endl;
    
    return 0;
}
                        </textarea>
                    </div>
                    <div class="code-buttons">
                        <button class="btn btn-primary" onclick="runCode(document.getElementById('code3'), document.getElementById('output3'))">▶ Run Code</button>
                    </div>
                    <div class="output-box" id="output3">Click "Run Code" to execute...</div>
                </div>
            </section>

            <section class="section">
                <div class="section-title">✍️ Coding Activities</div>

                <div class="activity">
                    <div class="activity-title">⚡ Intermediate Challenge: Search from Both Ends</div>
                    <p>Implement binary search pattern by searching from both ends simultaneously.</p>
                    <button class="btn btn-secondary" onclick="downloadCode(\`#include <iostream>
using namespace std;

struct Node {
    int data;
    Node* next;
    Node* prev;
    Node(int val) : data(val), next(nullptr), prev(nullptr) {}
};

class DoublyLinkedList {
private:
    Node* head;
public:
    DoublyLinkedList() : head(nullptr) {}
    
    // TODO: bool searchFromBothEnds(int target)
    // Search from head and tail simultaneously
    
    void insert(int val) { /* existing */ }
};

int main() {
    DoublyLinkedList list;
    // Build and search
    return 0;
}\`, 'doubly_search_both.cpp')">⬇ Download Skeleton</button>
                    <button class="collapsible">▼ Show Solution</button>
                    <div class="collapsible-content">
                        <div class="code-editor">
#include <iostream>
using namespace std;

struct Node {
    int data;
    Node* next;
    Node* prev;
    Node(int val) : data(val), next(nullptr), prev(nullptr) {}
};

class DoublyLinkedList {
private:
    Node* head;
public:
    DoublyLinkedList() : head(nullptr) {}
    
    void insert(int val) {
        Node* newNode = new Node(val);
        if(head == nullptr) {
            head = newNode;
            return;
        }
        Node* curr = head;
        while(curr->next != nullptr) {
            curr = curr->next;
        }
        curr->next = newNode;
        newNode->prev = curr;
    }
    
    bool searchFromBothEnds(int target) {
        Node* front = head;
        Node* back = head;
        
        if(head == nullptr) return false;
        
        while(back->next != nullptr) {
            back = back->next;
        }
        
        while(front != back && front->prev != back) {
            if(front->data == target) {
                cout << "Found " << target 
                     << " from front" << endl;
                return true;
            }
            if(back->data == target) {
                cout << "Found " << target 
                     << " from back" << endl;
                return true;
            }
            front = front->next;
            back = back->prev;
        }
        
        if(front->data == target || back->data == target) {
            cout << "Found " << target << endl;
            return true;
        }
        
        cout << target << " not found" << endl;
        return false;
    }
    
    ~DoublyLinkedList() {
        Node* curr = head;
        while(curr != nullptr) {
            Node* temp = curr;
            curr = curr->next;
            delete temp;
        }
    }
};

int main() {
    DoublyLinkedList list;
    
    for(int i = 1; i <= 10; i++) {
        list.insert(i * 10);
    }
    
    list.searchFromBothEnds(50);
    list.searchFromBothEnds(100);
    list.searchFromBothEnds(25);
    
    return 0;
}
                        </div>
                    </div>
                </div>

                <div class="activity">
                    <div class="activity-title">🔥 Advanced Challenge: Undo/Redo System</div>
                    <p>Implement undo/redo using doubly linked list for command history.</p>
                    <button class="btn btn-secondary" onclick="downloadCode(\`#include <iostream>
#include <string>
using namespace std;

struct Command {
    string action;
    Command(string a) : action(a) {}
};

struct Node {
    Command* cmd;
    Node* next;
    Node* prev;
    Node(Command* c) : cmd(c), next(nullptr), prev(nullptr) {}
};

class CommandHistory {
private:
    Node* current;
    Node* head;
public:
    CommandHistory() : current(nullptr), head(nullptr) {}
    
    // TODO: void execute(string cmd)
    // TODO: void undo()
    // TODO: void redo()
};

int main() {
    CommandHistory history;
    history.execute(\"CreateFile\");
    history.execute(\"EditText\");
    history.undo();
    history.redo();
    return 0;
}\`, 'undo_redo_system.cpp')">⬇ Download Skeleton</button>
                    <button class="collapsible">▼ Show Solution</button>
                    <div class="collapsible-content">
                        <div class="code-editor">
#include <iostream>
#include <string>
using namespace std;

struct Node {
    string action;
    Node* next;
    Node* prev;
    Node(string a) : action(a), next(nullptr), prev(nullptr) {}
};

class CommandHistory {
private:
    Node* current;
    Node* head;
public:
    CommandHistory() : current(nullptr), head(nullptr) {}
    
    void execute(string action) {
        Node* newNode = new Node(action);
        
        if(head == nullptr) {
            head = current = newNode;
        } else {
            if(current->next != nullptr) {
                Node* temp = current->next;
                while(temp != nullptr) {
                    Node* toDelete = temp;
                    temp = temp->next;
                    delete toDelete;
                }
                current->next = nullptr;
            }
            
            current->next = newNode;
            newNode->prev = current;
            current = newNode;
        }
        
        cout << "Executed: " << action << endl;
    }
    
    void undo() {
        if(current == nullptr) {
            cout << "Nothing to undo" << endl;
            return;
        }
        cout << "Undid: " << current->action << endl;
        if(current->prev != nullptr) {
            current = current->prev;
        }
    }
    
    void redo() {
        if(current == nullptr) {
            cout << "Nothing to redo" << endl;
            return;
        }
        if(current->next != nullptr) {
            current = current->next;
            cout << "Redid: " << current->action << endl;
        } else {
            cout << "Nothing to redo" << endl;
        }
    }
    
    void showHistory() {
        Node* temp = head;
        cout << "History: ";
        while(temp != nullptr) {
            if(temp == current) cout << "[";
            cout << temp->action;
            if(temp == current) cout << "]";
            cout << " <- ";
            temp = temp->next;
        }
        cout << "END" << endl;
    }
    
    ~CommandHistory() {
        Node* temp = head;
        while(temp != nullptr) {
            Node* toDelete = temp;
            temp = temp->next;
            delete toDelete;
        }
    }
};

int main() {
    CommandHistory history;
    
    cout << "=== Commands ===" << endl;
    history.execute("CreateFile");
    history.execute("EditText");
    history.execute("SaveFile");
    history.showHistory();
    
    cout << "\n=== Undo ===" << endl;
    history.undo();
    history.showHistory();
    history.undo();
    history.showHistory();
    
    cout << "\n=== Redo ===" << endl;
    history.redo();
    history.showHistory();
    
    cout << "\n=== New Command After Undo ===" << endl;
    history.execute("DeleteText");
    history.showHistory();
    
    return 0;
}
                        </div>
                    </div>
                </div>
            </section>

            <section class="section">
                <div class="section-title">📝 Knowledge Check Quiz</div>
                <div class="quiz-container">
                    <button class="quiz-btn" onclick="initializeQuiz()">▶ Start Quiz</button>
                </div>
            </section>
        </main>
    </div>

    <footer><p>COS110 OOP Study Website | November 2025</p></footer>

    <script src="../../js/main.js"></script>
    <script src="../../js/compiler.js"></script>
    <script src="../../js/quiz.js"></script>

    <script>
        function initializeQuiz() {
            const questions = [
                 {type: 'multiple-choice', question: 'In a doubly linked list, why must you update both predecessor->next AND successor->prev to maintain structural integrity?', options: ['Both pointers must point to valid nodes; updating only one creates a broken chain in one direction', 'It\'s purely for stylistic consistency with forward and backward traversal', 'Only updating one would cause immediate memory corruption', 'Both updates are equivalent; you could update just one'], correctAnswer: 'A', explanation: 'A doubly linked list maintains bidirectional connectivity. Updating only one direction creates an asymmetrical, broken structure where reverse traversal from successor wouldn\'t reach predecessor.'},
                {type: 'true-false', question: 'Backward traversal in a doubly linked list is as efficient as forward traversal, both being O(n) for full traversal.', correctAnswer: 'true', explanation: 'Correct. Both directions traverse through n nodes using pointer following, maintaining identical time complexity regardless of direction.'},
                {type: 'short-answer', question: 'An undo/redo system uses a doubly linked list to store commands. How does the bidirectional structure enable efficient undo/redo operations?', context: 'The current pointer can move <span style="color: red;">_______</span> through history without seeking from the beginning, enabling O(1) undo/redo.', hint: 'backward or forward', acceptableAnswers: ['backward and forward', 'in both directions', 'bidirectionally', 'forward and backward'], explanation: 'Bidirectional movement allows current position to jump backward (undo) or forward (redo) in constant time, unlike a singly linked list requiring traversal.'},
                {type: 'multiple-choice', question: 'When inserting a node between two existing nodes in a doubly linked list, what order of pointer assignments prevents data corruption?', options: ['Any order is safe; pointer assignments are atomic', 'Must assign both new node pointers first, then update surrounding nodes\' pointers', 'Order doesn\'t matter due to linked structure independence', 'Critical timing requires OS-level synchronization'], correctAnswer: 'B', explanation: 'Assign new node\'s pointers first (preserving old chain), then update surrounding nodes. Reverse order would create dangling pointers before establishing the chain.'},
                {type: 'true-false', question: 'A doubly linked list uses twice the memory per node compared to a singly linked list, but provides identical algorithmic capabilities.', correctAnswer: 'false', explanation: 'False. While memory doubles, capabilities differ. Doubly linked enables reverse traversal and deletion without predecessor lookup—singly linked cannot match this.'},
                {type: 'fill-in', question: 'Search From Both Ends Optimization: When searching for a target in a sorted doubly linked list, starting from both ends simultaneously is efficient because it reduces search space by <span style="color: red;">_______</span> with each comparison.', hint: 'half or 50%', acceptableAnswers: ['half', '50%', 'by half', 'to half'], explanation: 'Two simultaneous searches from opposite ends converge faster, halving the average search distance when target is near either end.'},
                {type: 'multiple-choice', question: 'Consider a scenario where a doubly linked list node is corrupted and prev pointer becomes invalid. Which traversal direction fails first and why?', options: ['Forward traversal; the head pointer is compromised', 'Backward traversal; it depends on the corrupted node\'s position', 'Both fail simultaneously due to structural interdependency', 'Neither fails; single corruption is not catastrophic'], correctAnswer: 'B', explanation: 'Forward traversal succeeds until reaching the corrupted node from before it. Backward traversal from after the node fails immediately. The direction that must use the corrupted pointer fails.'},
                {type: 'true-false', question: 'Deleting the middle element of a doubly linked list is easier than deleting from a singly linked list because you have direct access to the predecessor without traversal.', correctAnswer: 'true', explanation: 'True. Doubly linked provides direct prev access; singly linked requires traversing from head. This is a fundamental advantage of bidirectional structure.'},
                {type: 'fill-in', question: 'Memory Overhead Trade-off: A doubly linked list\'s extra memory is justified when operations require <span style="color: red;">_______</span> traversal frequently.', hint: 'bidirectional or reverse', acceptableAnswers: ['bidirectional', 'reverse', 'backward', 'both direction'], explanation: 'Frequent backward operations (undo, reverse iteration) justify the overhead. Without it, these operations require expensive full traversals.'},
                {type: 'multiple-choice', question: 'In a doubly linked list with n nodes, deleting all even-positioned nodes while traversing backward after halfway point is more efficient than forward because <span style="color: red;">_______</span>.', options: ['Backward traversal is always faster', 'Efficiency is identical in both directions', 'Deleting from end prevents index shifts that would affect remaining deletions', 'Backward iteration has better cache performance'], correctAnswer: 'C', explanation: 'Deleting from end upward avoids position shifts affecting remaining deletions. Forward deletion requires recalculating positions after each removal.'},
                {type: 'true-false', question: 'In a doubly linked list, you can find the last node in O(1) time if you maintain a tail pointer, just like with singly linked lists.', correctAnswer: 'true', explanation: 'True. Both structures benefit from tail pointer for O(1) end access. The difference is that doubly linked provides O(1) predecessor access without tail pointer.'},
                {type: 'multiple-choice', question: 'Reversing a doubly linked list by swapping next and prev pointers is O(n). What operation would be O(1) for reversing if the entire list is pre-existing?', options: ['Swapping the head and tail pointers', 'Reversing bits in memory', 'Creating a new reversed copy', 'No O(1) reversal exists'], correctAnswer: 'A', explanation: 'If head and tail point to opposite ends, swapping them presents the list in reverse order. The structure is already reversed conceptually without pointer manipulation.'},
                {type: 'fill-in', question: 'Insertion at Both Ends: A doubly linked list with maintained head and tail pointers achieves O(1) insertion at both ends because <span style="color: red;">_______</span>.', hint: 'direct access', acceptableAnswers: ['direct access', 'you have direct pointers', 'immediate access', 'no traversal needed'], explanation: 'With head and tail pointers, both ends are directly accessible for constant-time insertion without traversal.'},
                {type: 'multiple-choice', question: 'Why is a circular doubly linked list particularly useful for implementing a buffer or queue where you need both direction traversal?', options: ['It eliminates memory allocation entirely', 'It combines circular wrapping with bidirectional navigation and O(1) operations', 'It\'s faster than standard doubly linked lists', 'All structures have identical properties'], correctAnswer: 'B', explanation: 'Circular doubly linked provides wraparound navigation in both directions while maintaining O(1) operations. It\'s ideal for buffers requiring full bidirectional access.'},
                {type: 'true-false', question: 'A doubly linked list with corruption in a single node\'s next pointer can still be traversed backward from that node if the node\'s prev pointer is valid.', correctAnswer: 'true', explanation: 'True. Backward traversal uses prev pointers. A corrupted next doesn\'t affect backward movement; only forward traversal from that node fails.'},
                {type: 'short-answer', question: 'Splice Operation: Why can you splice (move) a sublist of n nodes from one doubly linked list to another in O(n) time with constant boundary operations?', context: 'You can update the <span style="color: red;">_______</span> pointers of affected boundary nodes to disconnect and reconnect sublists efficiently.', hint: 'next/prev or pointer', acceptableAnswers: ['next/prev', 'pointer', 'boundary', 'end'], explanation: 'Only boundary nodes need pointer updates; internal nodes aren\'t modified. This enables O(n) sublist movement through constant-time pointer operations.'},
                {type: 'multiple-choice', question: 'In a doubly linked list, when you need to delete a range of nodes [i, j], why is the operation O(j-i+1) rather than O(n)?', options: ['You don\'t need to traverse outside the range', 'The operation is actually O(n) regardless', 'Pointers handle ranges automatically', 'Memory access is optimized for ranges'], correctAnswer: 'A', explanation: 'Only the range [i, j] requires traversal for deletion. Outside nodes aren\'t accessed. This bounds complexity to range size, not list size.'},
                {type: 'fill-in', question: 'LRU Cache Implementation: A doubly linked list is ideal for LRU (Least Recently Used) caches because it supports O(1) <span style="color: red;">_______</span> of nodes to indicate recency.', hint: 'movement or reordering', acceptableAnswers: ['movement', 'reordering', 'relocation', 'repositioning'], explanation: 'Moving accessed nodes to the front in O(1) time tracks usage recency. Singly linked requires traversal; doubly linked updates pointers directly.'},
                {type: 'true-false', question: 'A doubly linked list must maintain identical memory efficiency compared to a singly linked list, just with additional prev pointer overhead.', correctAnswer: 'true', explanation: 'True. The only additional memory cost is one extra pointer per node. The structural complexity doesn\'t change memory usage compared to node count.'},
            ];


            window.quizSystem = new QuizSystem('Doubly Linked Lists', questions);
            openQuizModal();
        }

        if (!document.getElementById('quizModal')) {
            const modal = document.createElement('div');
            modal.id = 'quizModal';
            modal.className = 'quiz-modal';
            modal.innerHTML = `<div class="quiz-modal-content"><div class="quiz-header"><div><div class="quiz-question-number">Quiz: Doubly Linked</div><div class="quiz-progress">Question 1 of 20</div></div><button class="quiz-close" onclick="closeQuizModal()">✕</button></div><div class="quiz-questions-container"></div></div>`;
            document.body.appendChild(modal);
        }
    </script>
</body>
</html>