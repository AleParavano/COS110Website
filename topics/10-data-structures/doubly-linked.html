<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Doubly Linked Lists - COS110 OOP Study Website</title>
    <link rel="stylesheet" href="../../css/style.css">
</head>
<body>
    <nav class="navbar">
        <a href="../../index.html" class="navbar-brand">ğŸ“š COS110 OOP</a>
        <div class="navbar-search"><input type="text" placeholder="Search topics..."></div>
    </nav>

    <div class="container">
        <aside class="sidebar">
            <div class="sidebar-title">ğŸ“Œ Foundations</div>
            <a href="../01-pointers/part1.html" class="sidebar-item">Pointers Part 1</a>
            <a href="../01-pointers/part2.html" class="sidebar-item">Pointers Part 2</a>

            <div class="sidebar-title">ğŸ—ï¸ Classes & Objects</div>
            <a href="../02-classes/basics.html" class="sidebar-item">Classes Basics</a>
            <a href="../02-classes/advanced.html" class="sidebar-item">Classes Advanced</a>
            <a href="../02-classes/more.html" class="sidebar-item">Classes More</a>

            <div class="sidebar-title">ğŸ”§ Constructors</div>
            <a href="../03-copy-constructors.html" class="sidebar-item">Copy Constructors</a>
            <a href="../04-assignment-operator.html" class="sidebar-item">Assignment Operator</a>

            <div class="sidebar-title">â• Operators</div>
            <a href="../05-operator-overloading/basics.html" class="sidebar-item">Overloading Basics</a>
            <a href="../05-operator-overloading/friends.html" class="sidebar-item">Friends</a>
            <a href="../05-operator-overloading/references.html" class="sidebar-item">References/IO</a>
            <a href="../05-operator-overloading/increment.html" class="sidebar-item">Inc/Dec/Subscript</a>

            <div class="sidebar-title">âš ï¸ Exception Handling</div>
            <a href="../06-exception-handling/basics.html" class="sidebar-item">Basics</a>
            <a href="../06-exception-handling/hierarchies.html" class="sidebar-item">Hierarchies</a>

            <div class="sidebar-title">ğŸ‘¨â€ğŸ‘§ Inheritance</div>
            <a href="../07-inheritance/basics.html" class="sidebar-item">Basics</a>
            <a href="../07-inheritance/redefining.html" class="sidebar-item">Redefining</a>
            <a href="../07-inheritance/aggregation.html" class="sidebar-item">Aggregation</a>

            <div class="sidebar-title">ğŸ”„ Polymorphism</div>
            <a href="../08-polymorphism/virtual-functions.html" class="sidebar-item">Virtual Functions</a>
            <a href="../08-polymorphism/pointers.html" class="sidebar-item">Pointers</a>

            <div class="sidebar-title">ğŸ¨ Templates</div>
            <a href="../09-templates/classes.html" class="sidebar-item">Classes</a>
            <a href="../09-templates/functions.html" class="sidebar-item">Functions</a>

            <div class="sidebar-title">ğŸ“Š Data Structures</div>
            <a href="linked-lists.html" class="sidebar-item">Linked Lists</a>
            <a href="doubly-linked.html" class="sidebar-item">Doubly Linked</a>
            <a href="circular-lists.html" class="sidebar-item">Circular Lists</a>
            <a href="stacks.html" class="sidebar-item">Stacks</a>
            <a href="queues.html" class="sidebar-item">Queues</a>
            <a href="stl.html" class="sidebar-item">STL</a>
        </aside>

        <main class="main-content">
            <h1>ğŸ”— Doubly Linked Lists</h1>

            <section class="section">
                <div class="section-title">ğŸ“š Explanation</div>
                <div class="explanation">
                    <h3 style="color: var(--primary);">Doubly Linked List Structure</h3>
                    <p>A doubly linked list extends the singly linked list concept by adding a <strong>previous pointer</strong> to each node. Each node contains three fields: data, next pointer (to following node), and previous pointer (to preceding node). This bidirectional structure enables traversal in both directions, solving the key weakness of singly linked lists.</p>
                    
                    <div style="background: #f0f0f0; padding: 15px; border-radius: 8px; margin: 15px 0; font-family: 'Courier New', monospace; color: #333;">
                    <strong>Node Structure Comparison</strong><br><br>
                    Singly Linked:<br>
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”<br>
                    â”‚ data â”‚ next* â†’ â”œâ”€â”€â”<br>
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;â†“<br><br>
                    Doubly Linked:<br>
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”<br>
                    â”‚ â† prev* â”‚ data â”‚ next* â†’ â”œâ”€â”€â”€â”€â”€â”€â”¤ (Both directions!)<br>
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;â†“&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;â†“
                    </div>

                    <h3 style="color: var(--primary); margin-top: 25px;">Doubly Linked List Layout</h3>
                    <div style="background: #e8f4f8; padding: 15px; border-radius: 8px; margin: 10px 0; font-family: 'Courier New', monospace; color: #333;">
                    <strong>A Doubly Linked List with Values [10, 20, 30]:</strong><br><br>
                    nullptr â† [10|â†’] â†” [20|â†’] â†” [30|â†’] â† nullptr<br>
                    â†‘        â†‘                        â†‘        â†‘<br>
                    headâ†’    head.next            tail      tail.next<br><br>
                    
                    Forward Traversal (like singly linked):<br>
                    head â†’ 10 â†’ 20 â†’ 30 â†’ nullptr<br><br>
                    
                    Backward Traversal (singly can't do this!):<br>
                    tail â†’ 30 â†’ 20 â†’ 10 â†’ nullptr<br><br>
                    
                    <strong>Key Advantage:</strong> From any node, you can access predecessor in O(1) instead of O(n)!
                    </div>

                    <h3 style="color: var(--primary); margin-top: 20px;">Bidirectional Traversal - The Game Changer</h3>
                    <p><strong>Forward Traversal:</strong> Traditional left-to-right traversal using next pointers. Same as singly linked lists.</p>
                    <p><strong>Backward Traversal:</strong> New capability! Start from tail (or any node), follow prev pointers. In singly linked lists, reverse traversal requires recursion or complete reversal. Doubly linked makes it simple and efficient.</p>
                    <p><strong>Application Examples:</strong> Browser back/forward buttons (traverse browsing history both ways), LRU cache eviction (remove least recently used from tail), text editor line navigation (move up/down), playlist previous/next.</p>

                    <h3 style="color: var(--primary); margin-top: 20px;">Insertion Operations - Updating Two Pointers</h3>
                    <div style="background: #f0f0f0; padding: 15px; border-radius: 8px; margin: 10px 0; font-family: 'Courier New', monospace; color: #333;">
                    <strong>Insert 15 Between 10 and 20:</strong><br><br>
                    Before: ... â† [10|â†’] â†” [20|â†’] â† ...<br><br>
                    After: ... â† [10|â†’] â†” [15|â†’] â†” [20|â†’] â† ...<br><br>
                    <strong>Steps:</strong><br>
                    1. Create new node(15)<br>
                    2. new->next = 20_node  (link forward)<br>
                    3. new->prev = 10_node  (link backward)<br>
                    4. 10_node->next = new  (update 10's forward)<br>
                    5. 20_node->prev = new  (update 20's backward)<br><br>
                    <strong>Critical:</strong> Must update BOTH neighbors' pointers or chain breaks!
                    </div>

                    <h3 style="color: var(--primary); margin-top: 20px;">Deletion Operations - Direct Access to Predecessor</h3>
                    <p><strong>Key Advantage Over Singly Linked:</strong> In singly linked lists, deletion requires finding the predecessor (O(n)). In doubly linked lists, you have direct access! Delete node â†’ update prev->next and next->prev â†’ delete node. This is always O(1) from any node.</p>
                    <div style="background: #ffe8e8; padding: 15px; border-radius: 8px; margin: 10px 0;">
                    <strong>Delete node with value 20:</strong><br>
                    Before: â† [10|â†’] â†” [20|â†’] â†” [30|â†’] â†<br>
                    Steps: 10->next = 30, 30->prev = 10<br>
                    After: â† [10|â†’] â†” [30|â†’] â† (20 removed, chain intact)<br><br>
                    <strong>Complexity: O(1)</strong> if you have node pointer (vs O(n) in singly linked!)
                    </div>

                    <h3 style="color: var(--primary); margin-top: 20px;">Performance Comparison</h3>
                    <table style="width: 100%; border-collapse: collapse; margin: 15px 0;">
                    <tr style="background: var(--primary); color: white;">
                        <th style="padding: 10px; border: 1px solid #999;">Operation</th>
                        <th style="padding: 10px; border: 1px solid #999;">Singly</th>
                        <th style="padding: 10px; border: 1px solid #999;">Doubly</th>
                        <th style="padding: 10px; border: 1px solid #999;">Benefit</th>
                    </tr>
                    <tr style="background: #f9f9f9;">
                        <td style="padding: 10px; border: 1px solid #ddd;"><strong>Insert after node</strong></td>
                        <td style="padding: 10px; border: 1px solid #ddd;">O(1)</td>
                        <td style="padding: 10px; border: 1px solid #ddd;">O(1)</td>
                        <td style="padding: 10px; border: 1px solid #ddd;">Same</td>
                    </tr>
                    <tr>
                        <td style="padding: 10px; border: 1px solid #ddd;"><strong>Delete node</strong></td>
                        <td style="padding: 10px; border: 1px solid #ddd;">O(n)</td>
                        <td style="padding: 10px; border: 1px solid #ddd;">O(1)*</td>
                        <td style="padding: 10px; border: 1px solid #ddd;">âœ“ Huge win!</td>
                    </tr>
                    <tr style="background: #f9f9f9;">
                        <td style="padding: 10px; border: 1px solid #ddd;"><strong>Reverse traversal</strong></td>
                        <td style="padding: 10px; border: 1px solid #ddd;">O(n) + O(n)</td>
                        <td style="padding: 10px; border: 1px solid #ddd;">O(n)</td>
                        <td style="padding: 10px; border: 1px solid #ddd;">âœ“ Simpler</td>
                    </tr>
                    <tr>
                        <td style="padding: 10px; border: 1px solid #ddd;"><strong>Space per node</strong></td>
                        <td style="padding: 10px; border: 1px solid #ddd;">Data + 1 ptr</td>
                        <td style="padding: 10px; border: 1px solid #ddd;">Data + 2 ptrs</td>
                        <td style="padding: 10px; border: 1px solid #ddd;">âœ— Extra pointer</td>
                    </tr>
                    </table>
                    <p style="font-size: 12px; margin-top: 10px;">*Delete is O(1) if you have direct node pointer; O(n) if searching first</p>

                    <h3 style="color: var(--primary); margin-top: 20px;">Memory vs Functionality Trade-off</h3>
                    <p><strong>Extra Space Cost:</strong> One additional pointer (8 bytes on 64-bit system) per node. For 1000 nodes, that's 8KB overhead.</p>
                    <p><strong>Functionality Gained:</strong> Direct deletion O(1) vs O(n), efficient backward traversal, easier implementation of certain algorithms.</p>
                    <p><strong>When Worth It:</strong> Frequent deletions, bidirectional access patterns, LRU caches, priority queues. For read-only lists, singly linked is sufficient.</p>

                    <h3 style="color: var(--primary); margin-top: 20px;">Common Doubly Linked List Applications</h3>
                    <p><strong>LRU Cache:</strong> Maintain access order with doubly linked list. Move accessed items to front in O(1), remove least recent from tail.</p>
                    <p><strong>Text Editors:</strong> Store lines as doubly linked list. Move cursor up/down efficiently in both directions.</p>
                    <p><strong>Music Playlists:</strong> Previous/next navigation in both directions. Skip backward without storing history.</p>
                    <p><strong>Undo/Redo Stacks:</strong> Navigate through action history both directions efficiently.</p>
                </div>
            </section>

            <section class="section">
                <div class="section-title">ğŸ’» Code Examples</div>

                <div class="code-example">
                    <div class="code-tabs">
                        <button class="code-tab active" data-tab="simple1">Basic Doubly Linked List</button>
                        <button class="code-tab" data-tab="full1">Full Program</button>
                    </div>
                    <div data-tab-content="simple1" class="code-editor">
struct Node {
    int data;
    Node* next;
    Node* prev;
    Node(int val) : data(val), next(nullptr), 
                    prev(nullptr) {}
};

class DoublyLinkedList {
private:
    Node* head;
public:
    DoublyLinkedList() : head(nullptr) {}
    
    void insertAtBegin(int val) {
        Node* newNode = new Node(val);
        if(head == nullptr) {
            head = newNode;
            return;
        }
        newNode->next = head;
        head->prev = newNode;
        head = newNode;
    }
    
    void displayForward() {
        Node* curr = head;
        while(curr != nullptr) {
            cout << curr->data << " -> ";
            curr = curr->next;
        }
        cout << "NULL" << endl;
    }
};
                    </div>
                    <div data-tab-content="full1" style="display: none;">
                        <textarea class="code-editor" id="code1">#include <iostream>
using namespace std;

struct Node {
    int data;
    Node* next;
    Node* prev;
    Node(int val) : data(val), next(nullptr), 
                    prev(nullptr) {}
};

class DoublyLinkedList {
private:
    Node* head;
public:
    DoublyLinkedList() : head(nullptr) {}
    
    void insertAtBegin(int val) {
        Node* newNode = new Node(val);
        if(head == nullptr) {
            head = newNode;
            return;
        }
        newNode->next = head;
        head->prev = newNode;
        head = newNode;
    }
    
    void insertAtEnd(int val) {
        Node* newNode = new Node(val);
        if(head == nullptr) {
            head = newNode;
            return;
        }
        Node* curr = head;
        while(curr->next != nullptr) {
            curr = curr->next;
        }
        curr->next = newNode;
        newNode->prev = curr;
    }
    
    void displayForward() {
        cout << "Forward: ";
        Node* curr = head;
        while(curr != nullptr) {
            cout << curr->data << " -> ";
            curr = curr->next;
        }
        cout << "NULL" << endl;
    }
    
    void displayBackward() {
        cout << "Backward: ";
        Node* curr = head;
        if(curr == nullptr) {
            cout << "NULL" << endl;
            return;
        }
        while(curr->next != nullptr) {
            curr = curr->next;
        }
        while(curr != nullptr) {
            cout << curr->data << " -> ";
            curr = curr->prev;
        }
        cout << "NULL" << endl;
    }
    
    ~DoublyLinkedList() {
        Node* curr = head;
        while(curr != nullptr) {
            Node* temp = curr;
            curr = curr->next;
            delete temp;
        }
    }
};

int main() {
    DoublyLinkedList list;
    
    cout << "=== Inserting ===" << endl;
    list.insertAtEnd(10);
    list.insertAtEnd(20);
    list.insertAtEnd(30);
    
    cout << "\n=== Insert at Begin ===" << endl;
    list.insertAtBegin(5);
    list.insertAtBegin(1);
    
    list.displayForward();
    list.displayBackward();
    
    return 0;
}
                        </textarea>
                    </div>
                    <div class="code-buttons">
                        <button class="btn btn-primary" onclick="runCode(document.getElementById('code1'), document.getElementById('output1'))">â–¶ Run Code</button>
                    </div>
                    <div class="output-box" id="output1">Click "Run Code" to execute...</div>
                </div>

                <div class="code-example">
                    <div class="code-tabs">
                        <button class="code-tab active" data-tab="simple2">Deletion</button>
                        <button class="code-tab" data-tab="full2">Full Program</button>
                    </div>
                    <div data-tab-content="simple2" class="code-editor">
void deleteNode(Node* node) {
    if(node == nullptr) return;
    
    if(node->prev != nullptr) {
        node->prev->next = node->next;
    } else {
        head = node->next;
    }
    
    if(node->next != nullptr) {
        node->next->prev = node->prev;
    }
    
    delete node;
}

// Easier deletion - access both neighbors!
                    </div>
                    <div data-tab-content="full2" style="display: none;">
                        <textarea class="code-editor" id="code2">#include <iostream>
using namespace std;

struct Node {
    int data;
    Node* next;
    Node* prev;
    Node(int val) : data(val), next(nullptr), 
                    prev(nullptr) {}
};

class DoublyLinkedList {
private:
    Node* head;
public:
    DoublyLinkedList() : head(nullptr) {}
    
    void insertAtEnd(int val) {
        Node* newNode = new Node(val);
        if(head == nullptr) {
            head = newNode;
            return;
        }
        Node* curr = head;
        while(curr->next != nullptr) {
            curr = curr->next;
        }
        curr->next = newNode;
        newNode->prev = curr;
    }
    
    void deleteFromBegin() {
        if(head == nullptr) return;
        cout << "Deleting: " << head->data << endl;
        Node* temp = head;
        head = head->next;
        if(head != nullptr) {
            head->prev = nullptr;
        }
        delete temp;
    }
    
    void deleteFromEnd() {
        if(head == nullptr) return;
        
        Node* curr = head;
        while(curr->next != nullptr) {
            curr = curr->next;
        }
        cout << "Deleting: " << curr->data << endl;
        
        if(curr->prev != nullptr) {
            curr->prev->next = nullptr;
        } else {
            head = nullptr;
        }
        delete curr;
    }
    
    void displayForward() {
        cout << "Forward: ";
        Node* curr = head;
        while(curr != nullptr) {
            cout << curr->data << " -> ";
            curr = curr->next;
        }
        cout << "NULL" << endl;
    }
    
    ~DoublyLinkedList() {
        while(head != nullptr) {
            deleteFromBegin();
        }
    }
};

int main() {
    DoublyLinkedList list;
    
    cout << "=== Building ===" << endl;
    for(int i = 10; i <= 50; i += 10) {
        list.insertAtEnd(i);
    }
    list.displayForward();
    
    cout << "\n=== Delete from Begin ===" << endl;
    list.deleteFromBegin();
    list.displayForward();
    
    cout << "\n=== Delete from End ===" << endl;
    list.deleteFromEnd();
    list.displayForward();
    
    return 0;
}
                        </textarea>
                    </div>
                    <div class="code-buttons">
                        <button class="btn btn-primary" onclick="runCode(document.getElementById('code2'), document.getElementById('output2'))">â–¶ Run Code</button>
                    </div>
                    <div class="output-box" id="output2">Click "Run Code" to execute...</div>
                </div>

                <div class="code-example">
                    <div class="code-tabs">
                        <button class="code-tab active" data-tab="simple3">Bidirectional Traversal</button>
                        <button class="code-tab" data-tab="full3">Full Program</button>
                    </div>
                    <div data-tab-content="simple3" class="code-editor">
void displayBackward() {
    // Find last node
    Node* curr = head;
    while(curr->next != nullptr) {
        curr = curr->next;
    }
    
    // Traverse backward using prev
    cout << "Backward: ";
    while(curr != nullptr) {
        cout << curr->data << " -> ";
        curr = curr->prev;
    }
    cout << "NULL" << endl;
}

// Can now traverse in both directions!
                    </div>
                    <div data-tab-content="full3" style="display: none;">
                        <textarea class="code-editor" id="code3">#include <iostream>
using namespace std;

struct Node {
    int data;
    Node* next;
    Node* prev;
    Node(int val) : data(val), next(nullptr), 
                    prev(nullptr) {}
};

class DoublyLinkedList {
private:
    Node* head;
public:
    DoublyLinkedList() : head(nullptr) {}
    
    void insert(int val) {
        Node* newNode = new Node(val);
        if(head == nullptr) {
            head = newNode;
            return;
        }
        Node* curr = head;
        while(curr->next != nullptr) {
            curr = curr->next;
        }
        curr->next = newNode;
        newNode->prev = curr;
    }
    
    void displayForward() {
        cout << "Forward:  ";
        Node* curr = head;
        while(curr != nullptr) {
            cout << curr->data << " -> ";
            curr = curr->next;
        }
        cout << "NULL" << endl;
    }
    
    void displayBackward() {
        cout << "Backward: ";
        Node* curr = head;
        if(curr == nullptr) {
            cout << "NULL" << endl;
            return;
        }
        while(curr->next != nullptr) {
            curr = curr->next;
        }
        while(curr != nullptr) {
            cout << curr->data << " -> ";
            curr = curr->prev;
        }
        cout << "NULL" << endl;
    }
    
    int sumForward() {
        int sum = 0;
        Node* curr = head;
        while(curr != nullptr) {
            sum += curr->data;
            curr = curr->next;
        }
        return sum;
    }
    
    int sumBackward() {
        int sum = 0;
        Node* curr = head;
        if(curr == nullptr) return sum;
        
        while(curr->next != nullptr) {
            curr = curr->next;
        }
        while(curr != nullptr) {
            sum += curr->data;
            curr = curr->prev;
        }
        return sum;
    }
    
    ~DoublyLinkedList() {
        Node* curr = head;
        while(curr != nullptr) {
            Node* temp = curr;
            curr = curr->next;
            delete temp;
        }
    }
};

int main() {
    DoublyLinkedList list;
    
    cout << "=== Building List ===" << endl;
    for(int i = 1; i <= 5; i++) {
        list.insert(i * 10);
    }
    
    cout << "\n=== Display Both Directions ===" << endl;
    list.displayForward();
    list.displayBackward();
    
    cout << "\n=== Sum Both Directions ===" << endl;
    cout << "Forward sum: " << list.sumForward() << endl;
    cout << "Backward sum: " << list.sumBackward() << endl;
    
    return 0;
}
                        </textarea>
                    </div>
                    <div class="code-buttons">
                        <button class="btn btn-primary" onclick="runCode(document.getElementById('code3'), document.getElementById('output3'))">â–¶ Run Code</button>
                    </div>
                    <div class="output-box" id="output3">Click "Run Code" to execute...</div>
                </div>
            </section>

            <section class="section">
                <div class="section-title">âœï¸ Coding Activities</div>

                <div class="activity">
                    <div class="activity-title">âš¡ Intermediate Challenge: Search from Both Ends</div>
                    <p>Implement binary search pattern by searching from both ends simultaneously.</p>
                    <button class="btn btn-secondary" onclick="downloadDoublySearchSkeleton()">â¬‡ Download Skeleton</button>
                    <button class="collapsible">â–¼ Show Solution</button>
                    <div class="collapsible-content">
                        <div class="code-editor">
#include <iostream>
using namespace std;

struct Node {
    int data;
    Node* next;
    Node* prev;
    Node(int val) : data(val), next(nullptr), prev(nullptr) {}
};

class DoublyLinkedList {
private:
    Node* head;
public:
    DoublyLinkedList() : head(nullptr) {}
    
    void insert(int val) {
        Node* newNode = new Node(val);
        if(head == nullptr) {
            head = newNode;
            return;
        }
        Node* curr = head;
        while(curr->next != nullptr) {
            curr = curr->next;
        }
        curr->next = newNode;
        newNode->prev = curr;
    }
    
    bool searchFromBothEnds(int target) {
        Node* front = head;
        Node* back = head;
        
        if(head == nullptr) return false;
        
        while(back->next != nullptr) {
            back = back->next;
        }
        
        while(front != back && front->prev != back) {
            if(front->data == target) {
                cout << "Found " << target 
                     << " from front" << endl;
                return true;
            }
            if(back->data == target) {
                cout << "Found " << target 
                     << " from back" << endl;
                return true;
            }
            front = front->next;
            back = back->prev;
        }
        
        if(front->data == target || back->data == target) {
            cout << "Found " << target << endl;
            return true;
        }
        
        cout << target << " not found" << endl;
        return false;
    }
    
    ~DoublyLinkedList() {
        Node* curr = head;
        while(curr != nullptr) {
            Node* temp = curr;
            curr = curr->next;
            delete temp;
        }
    }
};

int main() {
    DoublyLinkedList list;
    
    for(int i = 1; i <= 10; i++) {
        list.insert(i * 10);
    }
    
    list.searchFromBothEnds(50);
    list.searchFromBothEnds(100);
    list.searchFromBothEnds(25);
    
    return 0;
}
                        </div>
                    </div>
                </div>

                <div class="activity">
                    <div class="activity-title">ğŸ”¥ Advanced Challenge: Undo/Redo System</div>
                    <p>Implement undo/redo using doubly linked list for command history.</p>
                    <button class="btn btn-secondary" onclick="downloadDoublyUndoRedoSkeleton()">â¬‡ Download Skeleton</button>
                    <button class="collapsible">â–¼ Show Solution</button>
                    <div class="collapsible-content">
                        <div class="code-editor">
#include <iostream>
#include <string>
using namespace std;

struct Node {
    string action;
    Node* next;
    Node* prev;
    Node(string a) : action(a), next(nullptr), prev(nullptr) {}
};

class CommandHistory {
private:
    Node* current;
    Node* head;
public:
    CommandHistory() : current(nullptr), head(nullptr) {}
    
    void execute(string action) {
        Node* newNode = new Node(action);
        
        if(head == nullptr) {
            head = current = newNode;
        } else {
            if(current->next != nullptr) {
                Node* temp = current->next;
                while(temp != nullptr) {
                    Node* toDelete = temp;
                    temp = temp->next;
                    delete toDelete;
                }
                current->next = nullptr;
            }
            
            current->next = newNode;
            newNode->prev = current;
            current = newNode;
        }
        
        cout << "Executed: " << action << endl;
    }
    
    void undo() {
        if(current == nullptr) {
            cout << "Nothing to undo" << endl;
            return;
        }
        cout << "Undid: " << current->action << endl;
        if(current->prev != nullptr) {
            current = current->prev;
        }
    }
    
    void redo() {
        if(current == nullptr) {
            cout << "Nothing to redo" << endl;
            return;
        }
        if(current->next != nullptr) {
            current = current->next;
            cout << "Redid: " << current->action << endl;
        } else {
            cout << "Nothing to redo" << endl;
        }
    }
    
    void showHistory() {
        Node* temp = head;
        cout << "History: ";
        while(temp != nullptr) {
            if(temp == current) cout << "[";
            cout << temp->action;
            if(temp == current) cout << "]";
            cout << " <- ";
            temp = temp->next;
        }
        cout << "END" << endl;
    }
    
    ~CommandHistory() {
        Node* temp = head;
        while(temp != nullptr) {
            Node* toDelete = temp;
            temp = temp->next;
            delete toDelete;
        }
    }
};

int main() {
    CommandHistory history;
    
    cout << "=== Commands ===" << endl;
    history.execute("CreateFile");
    history.execute("EditText");
    history.execute("SaveFile");
    history.showHistory();
    
    cout << "\n=== Undo ===" << endl;
    history.undo();
    history.showHistory();
    history.undo();
    history.showHistory();
    
    cout << "\n=== Redo ===" << endl;
    history.redo();
    history.showHistory();
    
    cout << "\n=== New Command After Undo ===" << endl;
    history.execute("DeleteText");
    history.showHistory();
    
    return 0;
}
                        </div>
                    </div>
                </div>
            </section>

            <section class="section">
                <div class="section-title">ğŸ“ Knowledge Check Quiz</div>
                <div class="quiz-container">
                    <button class="quiz-btn" onclick="initializeQuiz()">â–¶ Start Quiz</button>
                </div>
            </section>
        </main>
    </div>

    <footer><p>COS110 OOP Study Website | November 2025</p></footer>

    <script src="../../js/main.js"></script>
    <script src="../../js/compiler.js"></script>
    <script src="../../js/quiz.js"></script>

    <script>
        function downloadDoublySearchSkeleton() {
            const code = `#include <iostream>
using namespace std;

struct Node {
    int data;
    Node* prev;
    Node* next;
    Node(int val) : data(val), prev(nullptr), next(nullptr) {}
};

class DoublyLinkedList {
private:
    Node* head;
    Node* tail;
public:
    DoublyLinkedList() : head(nullptr), tail(nullptr) {}
    
    void insertEnd(int val) {
        Node* newNode = new Node(val);
        if(head == nullptr) {
            head = tail = newNode;
            return;
        }
        tail->next = newNode;
        newNode->prev = tail;
        tail = newNode;
    }
    
    // TODO: int searchBothDirections(int target)
    // Search from both head and tail simultaneously
    // Return 1 if found from head direction
    // Return 2 if found from tail direction
    // Return -1 if not found
    // HINT: Use two pointers: front=head, rear=tail
    int searchBothDirections(int target) {
        // YOUR CODE HERE
        return -1;
    }
    
    ~DoublyLinkedList() {
        Node* curr = head;
        while(curr != nullptr) {
            Node* temp = curr;
            curr = curr->next;
            delete temp;
        }
    }
};

int main() {
    DoublyLinkedList list;
    list.insertEnd(10);
    list.insertEnd(20);
    list.insertEnd(30);
    list.insertEnd(40);
    
    int result = list.searchBothDirections(30);
    cout << "Search result: " << result << endl;
    
    return 0;
}`;
            downloadSkeleton(code, 'doubly_search_both.cpp');
        }
        function downloadDoublyUndoRedoSkeleton() {
            const code = `#include <iostream>
#include <vector>
using namespace std;

class UndoRedoSystem {
private:
    vector<string> history;
    int currentState;
    
public:
    UndoRedoSystem() : currentState(-1) {}
    
    void execute(string action) {
        if(currentState < (int)history.size() - 1) {
            history.erase(history.begin() + currentState + 1, history.end());
        }
        history.push_back(action);
        currentState++;
    }
    
    // TODO: string undo()
    // Move back one step in history
    // HINT: Decrease currentState if possible
    string undo() {
        // YOUR CODE HERE
        return "";
    }
    
    // TODO: string redo()
    // Move forward one step in history
    // HINT: Increase currentState if possible
    string redo() {
        // YOUR CODE HERE
        return "";
    }
    
    void display() {
        cout << "History: ";
        for(int i = 0; i < (int)history.size(); i++) {
            if(i == currentState) cout << "[" << history[i] << "] ";
            else cout << history[i] << " ";
        }
        cout << endl;
    }
};

int main() {
    UndoRedoSystem sys;
    sys.execute("Action1");
    sys.execute("Action2");
    sys.execute("Action3");
    sys.display();
    
    sys.undo();
    sys.display();
    
    sys.redo();
    sys.display();
    
    return 0;
}`;
            downloadSkeleton(code, 'undo_redo_system.cpp');
        }
        function initializeQuiz() {
            const questions = [
                 {type: 'multiple-choice', question: 'In a doubly linked list, why must you update both predecessor->next AND successor->prev to maintain structural integrity?', options: ['Both pointers must point to valid nodes; updating only one creates a broken chain in one direction', 'It\'s purely for stylistic consistency with forward and backward traversal', 'Only updating one would cause immediate memory corruption', 'Both updates are equivalent; you could update just one'], correctAnswer: 'A', explanation: 'A doubly linked list maintains bidirectional connectivity. Updating only one direction creates an asymmetrical, broken structure where reverse traversal from successor wouldn\'t reach predecessor.'},
                {type: 'true-false', question: 'Backward traversal in a doubly linked list is as efficient as forward traversal, both being O(n) for full traversal.', correctAnswer: 'true', explanation: 'Correct. Both directions traverse through n nodes using pointer following, maintaining identical time complexity regardless of direction.'},
                {type: 'short-answer', question: 'An undo/redo system uses a doubly linked list to store commands. How does the bidirectional structure enable efficient undo/redo operations?', context: 'The current pointer can move <span style="color: red;">_______</span> through history without seeking from the beginning, enabling O(1) undo/redo.', hint: 'backward or forward', acceptableAnswers: ['backward and forward', 'in both directions', 'bidirectionally', 'forward and backward'], explanation: 'Bidirectional movement allows current position to jump backward (undo) or forward (redo) in constant time, unlike a singly linked list requiring traversal.'},
                {type: 'multiple-choice', question: 'When inserting a node between two existing nodes in a doubly linked list, what order of pointer assignments prevents data corruption?', options: ['Any order is safe; pointer assignments are atomic', 'Must assign both new node pointers first, then update surrounding nodes\' pointers', 'Order doesn\'t matter due to linked structure independence', 'Critical timing requires OS-level synchronization'], correctAnswer: 'B', explanation: 'Assign new node\'s pointers first (preserving old chain), then update surrounding nodes. Reverse order would create dangling pointers before establishing the chain.'},
                {type: 'true-false', question: 'A doubly linked list uses twice the memory per node compared to a singly linked list, but provides identical algorithmic capabilities.', correctAnswer: 'false', explanation: 'False. While memory doubles, capabilities differ. Doubly linked enables reverse traversal and deletion without predecessor lookupâ€”singly linked cannot match this.'},
                {type: 'fill-in', question: 'Search From Both Ends Optimization: When searching for a target in a sorted doubly linked list, starting from both ends simultaneously is efficient because it reduces search space by <span style="color: red;">_______</span> with each comparison.', hint: 'half or 50%', acceptableAnswers: ['half', '50%', 'by half', 'to half'], explanation: 'Two simultaneous searches from opposite ends converge faster, halving the average search distance when target is near either end.'},
                {type: 'multiple-choice', question: 'Consider a scenario where a doubly linked list node is corrupted and prev pointer becomes invalid. Which traversal direction fails first and why?', options: ['Forward traversal; the head pointer is compromised', 'Backward traversal; it depends on the corrupted node\'s position', 'Both fail simultaneously due to structural interdependency', 'Neither fails; single corruption is not catastrophic'], correctAnswer: 'B', explanation: 'Forward traversal succeeds until reaching the corrupted node from before it. Backward traversal from after the node fails immediately. The direction that must use the corrupted pointer fails.'},
                {type: 'true-false', question: 'Deleting the middle element of a doubly linked list is easier than deleting from a singly linked list because you have direct access to the predecessor without traversal.', correctAnswer: 'true', explanation: 'True. Doubly linked provides direct prev access; singly linked requires traversing from head. This is a fundamental advantage of bidirectional structure.'},
                {type: 'fill-in', question: 'Memory Overhead Trade-off: A doubly linked list\'s extra memory is justified when operations require <span style="color: red;">_______</span> traversal frequently.', hint: 'bidirectional or reverse', acceptableAnswers: ['bidirectional', 'reverse', 'backward', 'both direction'], explanation: 'Frequent backward operations (undo, reverse iteration) justify the overhead. Without it, these operations require expensive full traversals.'},
                {type: 'multiple-choice', question: 'In a doubly linked list with n nodes, deleting all even-positioned nodes while traversing backward after halfway point is more efficient than forward because <span style="color: red;">_______</span>.', options: ['Backward traversal is always faster', 'Efficiency is identical in both directions', 'Deleting from end prevents index shifts that would affect remaining deletions', 'Backward iteration has better cache performance'], correctAnswer: 'C', explanation: 'Deleting from end upward avoids position shifts affecting remaining deletions. Forward deletion requires recalculating positions after each removal.'},
                {type: 'true-false', question: 'In a doubly linked list, you can find the last node in O(1) time if you maintain a tail pointer, just like with singly linked lists.', correctAnswer: 'true', explanation: 'True. Both structures benefit from tail pointer for O(1) end access. The difference is that doubly linked provides O(1) predecessor access without tail pointer.'},
                {type: 'multiple-choice', question: 'Reversing a doubly linked list by swapping next and prev pointers is O(n). What operation would be O(1) for reversing if the entire list is pre-existing?', options: ['Swapping the head and tail pointers', 'Reversing bits in memory', 'Creating a new reversed copy', 'No O(1) reversal exists'], correctAnswer: 'A', explanation: 'If head and tail point to opposite ends, swapping them presents the list in reverse order. The structure is already reversed conceptually without pointer manipulation.'},
                {type: 'fill-in', question: 'Insertion at Both Ends: A doubly linked list with maintained head and tail pointers achieves O(1) insertion at both ends because <span style="color: red;">_______</span>.', hint: 'direct access', acceptableAnswers: ['direct access', 'you have direct pointers', 'immediate access', 'no traversal needed'], explanation: 'With head and tail pointers, both ends are directly accessible for constant-time insertion without traversal.'},
                {type: 'multiple-choice', question: 'Why is a circular doubly linked list particularly useful for implementing a buffer or queue where you need both direction traversal?', options: ['It eliminates memory allocation entirely', 'It combines circular wrapping with bidirectional navigation and O(1) operations', 'It\'s faster than standard doubly linked lists', 'All structures have identical properties'], correctAnswer: 'B', explanation: 'Circular doubly linked provides wraparound navigation in both directions while maintaining O(1) operations. It\'s ideal for buffers requiring full bidirectional access.'},
                {type: 'true-false', question: 'A doubly linked list with corruption in a single node\'s next pointer can still be traversed backward from that node if the node\'s prev pointer is valid.', correctAnswer: 'true', explanation: 'True. Backward traversal uses prev pointers. A corrupted next doesn\'t affect backward movement; only forward traversal from that node fails.'},
                {type: 'short-answer', question: 'Splice Operation: Why can you splice (move) a sublist of n nodes from one doubly linked list to another in O(n) time with constant boundary operations?', context: 'You can update the <span style="color: red;">_______</span> pointers of affected boundary nodes to disconnect and reconnect sublists efficiently.', hint: 'next/prev or pointer', acceptableAnswers: ['next/prev', 'pointer', 'boundary', 'end'], explanation: 'Only boundary nodes need pointer updates; internal nodes aren\'t modified. This enables O(n) sublist movement through constant-time pointer operations.'},
                {type: 'multiple-choice', question: 'In a doubly linked list, when you need to delete a range of nodes [i, j], why is the operation O(j-i+1) rather than O(n)?', options: ['You don\'t need to traverse outside the range', 'The operation is actually O(n) regardless', 'Pointers handle ranges automatically', 'Memory access is optimized for ranges'], correctAnswer: 'A', explanation: 'Only the range [i, j] requires traversal for deletion. Outside nodes aren\'t accessed. This bounds complexity to range size, not list size.'},
                {type: 'fill-in', question: 'LRU Cache Implementation: A doubly linked list is ideal for LRU (Least Recently Used) caches because it supports O(1) <span style="color: red;">_______</span> of nodes to indicate recency.', hint: 'movement or reordering', acceptableAnswers: ['movement', 'reordering', 'relocation', 'repositioning'], explanation: 'Moving accessed nodes to the front in O(1) time tracks usage recency. Singly linked requires traversal; doubly linked updates pointers directly.'},
                {type: 'true-false', question: 'A doubly linked list must maintain identical memory efficiency compared to a singly linked list, just with additional prev pointer overhead.', correctAnswer: 'true', explanation: 'True. The only additional memory cost is one extra pointer per node. The structural complexity doesn\'t change memory usage compared to node count.'},
            ];


            window.quizSystem = new QuizSystem('Doubly Linked Lists', questions);
            openQuizModal();
        }

        if (!document.getElementById('quizModal')) {
            const modal = document.createElement('div');
            modal.id = 'quizModal';
            modal.className = 'quiz-modal';
            modal.innerHTML = `<div class="quiz-modal-content"><div class="quiz-header"><div><div class="quiz-question-number">Quiz: Doubly Linked</div><div class="quiz-progress">Question 1 of 20</div></div><button class="quiz-close" onclick="closeQuizModal()">âœ•</button></div><div class="quiz-questions-container"></div></div>`;
            document.body.appendChild(modal);
        }
    </script>
</body>
</html>