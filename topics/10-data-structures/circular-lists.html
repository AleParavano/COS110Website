<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Circular Linked Lists - COS110 OOP Study Website</title>
    <link rel="stylesheet" href="../../css/style.css">
</head>
<body>
    <nav class="navbar">
        <a href="../../index.html" class="navbar-brand">📚 COS110 OOP</a>
        <div class="navbar-search"><input type="text" placeholder="Search ....."></div>
    </nav>

    <div class="container">
        <aside class="sidebar">
            <div class="sidebar-title">📌 Foundations</div>
            <a href="../01-pointers/part1.html" class="sidebar-item">Pointers Part 1</a>
            <a href="../01-pointers/part2.html" class="sidebar-item">Pointers Part 2</a>

            <div class="sidebar-title">🏗️ Classes & Objects</div>
            <a href="../02-classes/basics.html" class="sidebar-item">Classes Basics</a>
            <a href="../02-classes/advanced.html" class="sidebar-item">Classes Advanced</a>
            <a href="../02-classes/more.html" class="sidebar-item">Classes More</a>

            <div class="sidebar-title">🔧 Constructors</div>
            <a href="../03-copy-constructors.html" class="sidebar-item">Copy Constructors</a>
            <a href="../04-assignment-operator.html" class="sidebar-item">Assignment Operator</a>

            <div class="sidebar-title">➕ Operators</div>
            <a href="../05-operator-overloading/basics.html" class="sidebar-item">Overloading Basics</a>
            <a href="../05-operator-overloading/friends.html" class="sidebar-item">Friends</a>
            <a href="../05-operator-overloading/references.html" class="sidebar-item">References/IO</a>
            <a href="../05-operator-overloading/increment.html" class="sidebar-item">Inc/Dec/Subscript</a>

            <div class="sidebar-title">⚠️ Exception Handling</div>
            <a href="../06-exception-handling/basics.html" class="sidebar-item">Basics</a>
            <a href="../06-exception-handling/hierarchies.html" class="sidebar-item">Hierarchies</a>

            <div class="sidebar-title">👨‍👧 Inheritance</div>
            <a href="../07-inheritance/basics.html" class="sidebar-item">Basics</a>
            <a href="../07-inheritance/redefining.html" class="sidebar-item">Redefining</a>
            <a href="../07-inheritance/aggregation.html" class="sidebar-item">Aggregation</a>

            <div class="sidebar-title">🔄 Polymorphism</div>
            <a href="../08-polymorphism/virtual-functions.html" class="sidebar-item">Virtual Functions</a>
            <a href="../08-polymorphism/pointers.html" class="sidebar-item">Pointers</a>

            <div class="sidebar-title">🎨 Templates</div>
            <a href="../09-templates/classes.html" class="sidebar-item">Classes</a>
            <a href="../09-templates/functions.html" class="sidebar-item">Functions</a>

            <div class="sidebar-title">📊 Data Structures</div>
            <a href="linked-lists.html" class="sidebar-item">Linked Lists</a>
            <a href="doubly-linked.html" class="sidebar-item">Doubly Linked</a>
            <a href="circular-lists.html" class="sidebar-item">Circular Lists</a>
            <a href="stacks.html" class="sidebar-item">Stacks</a>
            <a href="queues.html" class="sidebar-item">Queues</a>
            <a href="stl.html" class="sidebar-item">STL</a>
        </aside>

        <main class="main-content">
            <h1>🔄 Circular Linked Lists</h1>

            <section class="section">
                <div class="section-title">📚 Explanation</div>
                <div class="explanation">
                    <h3 style="color: var(--primary);">Circular Linked List Structure</h3>
                    <p>In a circular linked list, the last node's next pointer points to the first node instead of nullptr. This creates a circular structure with no explicit end. You can start from any node and eventually return to it by following pointers. Only need to store head pointer, no separate tail needed.</p>

                    <h3 style="color: var(--primary); margin-top: 20px;">Traversal in Circular Lists</h3>
                    <p>Traversal uses a different termination condition. Instead of checking curr != nullptr, check if curr has returned to head (curr->next == head). Must have an initial reference to know when to stop. Any node can serve as starting point.</p>

                    <h3 style="color: var(--primary); margin-top: 20px;">Insertion in Circular Lists</h3>
                    <p>Insert at beginning: new node->next = head->next, head->next = new node (or update head). Insert at end: easier than singly linked - last node is one before head. Insert is straightforward with circular structure once head is maintained properly.</p>

                    <h3 style="color: var(--primary); margin-top: 20px;">Applications of Circular Lists</h3>
                    <p>Circular lists are ideal for round-robin scheduling, buffering, and processes that loop indefinitely. Examples: CPU scheduling queues, multiplayer game turns, music playlists. The circular nature matches these use cases naturally without artificial end conditions.</p>

                    <h3 style="color: var(--primary); margin-top: 20px;">Advantages and Trade-offs</h3>
                    <p>No null pointer dereferencing after the last node. Can easily find both ends in O(1). Disadvantage: must handle infinite loops carefully in traversal. Need explicit condition to stop. Good for cyclic applications, overhead similar to singly linked.</p>
                </div>
            </section>

            <section class="section">
                <div class="section-title">💻 Code Examples</div>

                <div class="code-example">
                    <div class="code-tabs">
                        <button class="code-tab active" data-tab="simple1">Basic Circular List</button>
                        <button class="code-tab" data-tab="full1">Full Program</button>
                    </div>
                    <div data-tab-content="simple1" class="code-editor">
struct Node {
    int data;
    Node* next;
    Node(int val) : data(val), next(nullptr) {}
};

class CircularLinkedList {
private:
    Node* head;
public:
    CircularLinkedList() : head(nullptr) {}
    
    void insertAtEnd(int val) {
        Node* newNode = new Node(val);
        if(head == nullptr) {
            head = newNode;
            newNode->next = head;
            return;
        }
        Node* curr = head;
        while(curr->next != head) {
            curr = curr->next;
        }
        curr->next = newNode;
        newNode->next = head;
    }
    
    void display() {
        if(head == nullptr) return;
        Node* curr = head;
        do {
            cout << curr->data << " -> ";
            curr = curr->next;
        } while(curr != head);
        cout << "HEAD" << endl;
    }
};
                    </div>
                    <div data-tab-content="full1" style="display: none;">
                        <textarea class="code-editor" id="code1">#include <iostream>
using namespace std;

struct Node {
    int data;
    Node* next;
    Node(int val) : data(val), next(nullptr) {}
};

class CircularLinkedList {
private:
    Node* head;
public:
    CircularLinkedList() : head(nullptr) {}
    
    void insertAtEnd(int val) {
        Node* newNode = new Node(val);
        if(head == nullptr) {
            head = newNode;
            newNode->next = head;
            cout << "Inserted " << val << " as head" << endl;
            return;
        }
        Node* curr = head;
        while(curr->next != head) {
            curr = curr->next;
        }
        curr->next = newNode;
        newNode->next = head;
        cout << "Inserted " << val << " at end" << endl;
    }
    
    void insertAtBegin(int val) {
        Node* newNode = new Node(val);
        if(head == nullptr) {
            head = newNode;
            newNode->next = head;
            return;
        }
        Node* curr = head;
        while(curr->next != head) {
            curr = curr->next;
        }
        newNode->next = head;
        curr->next = newNode;
        head = newNode;
    }
    
    void display() {
        if(head == nullptr) {
            cout << "Empty list" << endl;
            return;
        }
        cout << "Circular: ";
        Node* curr = head;
        do {
            cout << curr->data << " -> ";
            curr = curr->next;
        } while(curr != head);
        cout << "HEAD" << endl;
    }
    
    ~CircularLinkedList() {
        if(head == nullptr) return;
        Node* curr = head->next;
        while(curr != head) {
            Node* temp = curr;
            curr = curr->next;
            delete temp;
        }
        delete head;
    }
};

int main() {
    CircularLinkedList list;
    
    cout << "=== Insert at End ===" << endl;
    list.insertAtEnd(10);
    list.insertAtEnd(20);
    list.insertAtEnd(30);
    list.display();
    
    cout << "\n=== Insert at Begin ===" << endl;
    list.insertAtBegin(5);
    list.display();
    
    return 0;
}
                        </textarea>
                    </div>
                    <div class="code-buttons">
                        <button class="btn btn-primary" onclick="runCode(document.getElementById('code1'), document.getElementById('output1'))">▶ Run Code</button>
                    </div>
                    <div class="output-box" id="output1">Click "Run Code" to execute...</div>
                </div>

                <div class="code-example">
                    <div class="code-tabs">
                        <button class="code-tab active" data-tab="simple2">Traversal</button>
                        <button class="code-tab" data-tab="full2">Full Program</button>
                    </div>
                    <div data-tab-content="simple2" class="code-editor">
void display() {
    if(head == nullptr) return;
    
    Node* curr = head;
    do {
        cout << curr->data << " -> ";
        curr = curr->next;
    } while(curr != head);  // Stop when back at head
    
    cout << "HEAD" << endl;
}

// Key: use do-while and check curr != head
                    </div>
                    <div data-tab-content="full2" style="display: none;">
                        <textarea class="code-editor" id="code2">#include <iostream>
using namespace std;

struct Node {
    int data;
    Node* next;
    Node(int val) : data(val), next(nullptr) {}
};

class CircularLinkedList {
private:
    Node* head;
public:
    CircularLinkedList() : head(nullptr) {}
    
    void insert(int val) {
        Node* newNode = new Node(val);
        if(head == nullptr) {
            head = newNode;
            newNode->next = head;
            return;
        }
        Node* curr = head;
        while(curr->next != head) {
            curr = curr->next;
        }
        curr->next = newNode;
        newNode->next = head;
    }
    
    void display() {
        if(head == nullptr) return;
        Node* curr = head;
        do {
            cout << curr->data << " -> ";
            curr = curr->next;
        } while(curr != head);
        cout << "HEAD" << endl;
    }
    
    int count() {
        if(head == nullptr) return 0;
        int cnt = 0;
        Node* curr = head;
        do {
            cnt++;
            curr = curr->next;
        } while(curr != head);
        return cnt;
    }
    
    int sum() {
        if(head == nullptr) return 0;
        int total = 0;
        Node* curr = head;
        do {
            total += curr->data;
            curr = curr->next;
        } while(curr != head);
        return total;
    }
    
    ~CircularLinkedList() {
        if(head == nullptr) return;
        Node* curr = head->next;
        while(curr != head) {
            Node* temp = curr;
            curr = curr->next;
            delete temp;
        }
        delete head;
    }
};

int main() {
    CircularLinkedList list;
    
    for(int i = 10; i <= 50; i += 10) {
        list.insert(i);
    }
    
    cout << "=== Display ===" << endl;
    list.display();
    
    cout << "\n=== Statistics ===" << endl;
    cout << "Count: " << list.count() << endl;
    cout << "Sum: " << list.sum() << endl;
    
    return 0;
}
                        </textarea>
                    </div>
                    <div class="code-buttons">
                        <button class="btn btn-primary" onclick="runCode(document.getElementById('code2'), document.getElementById('output2'))">▶ Run Code</button>
                    </div>
                    <div class="output-box" id="output2">Click "Run Code" to execute...</div>
                </div>

                <div class="code-example">
                    <div class="code-tabs">
                        <button class="code-tab active" data-tab="simple3">Round-Robin Scheduling</button>
                        <button class="code-tab" data-tab="full3">Full Program</button>
                    </div>
                    <div data-tab-content="simple3" class="code-editor">
void roundRobin(int timeSlice) {
    if(head == nullptr) return;
    
    Node* curr = head;
    int process = 1;
    for(int i = 0; i < 10; i++) {
        cout << "Process " << curr->data 
             << " runs for " << timeSlice 
             << "ms" << endl;
        curr = curr->next;
    }
}

// Perfect use case for circular lists!
                    </div>
                    <div data-tab-content="full3" style="display: none;">
                        <textarea class="code-editor" id="code3">#include <iostream>
using namespace std;

struct Node {
    int data;
    Node* next;
    Node(int val) : data(val), next(nullptr) {}
};

class CircularLinkedList {
private:
    Node* head;
public:
    CircularLinkedList() : head(nullptr) {}
    
    void insert(int val) {
        Node* newNode = new Node(val);
        if(head == nullptr) {
            head = newNode;
            newNode->next = head;
            return;
        }
        Node* curr = head;
        while(curr->next != head) {
            curr = curr->next;
        }
        curr->next = newNode;
        newNode->next = head;
    }
    
    void roundRobinSchedule(int timeSlice) {
        if(head == nullptr) {
            cout << "No processes" << endl;
            return;
        }
        
        cout << "=== Round-Robin Scheduling ===" << endl;
        cout << "Time slice: " << timeSlice 
             << "ms" << endl << endl;
        
        Node* curr = head;
        int time = 0;
        for(int i = 0; i < 10; i++) {
            cout << "Time " << time << "-" 
                 << (time + timeSlice) 
                 << "ms: Process P" << curr->data 
                 << " executing" << endl;
            time += timeSlice;
            curr = curr->next;
        }
    }
    
    ~CircularLinkedList() {
        if(head == nullptr) return;
        Node* curr = head->next;
        while(curr != head) {
            Node* temp = curr;
            curr = curr->next;
            delete temp;
        }
        delete head;
    }
};

int main() {
    CircularLinkedList scheduler;
    
    for(int i = 1; i <= 4; i++) {
        scheduler.insert(i);
    }
    
    scheduler.roundRobinSchedule(10);
    
    return 0;
}
                        </textarea>
                    </div>
                    <div class="code-buttons">
                        <button class="btn btn-primary" onclick="runCode(document.getElementById('code3'), document.getElementById('output3'))">▶ Run Code</button>
                    </div>
                    <div class="output-box" id="output3">Click "Run Code" to execute...</div>
                </div>
            </section>

            <section class="section">
                <div class="section-title">✍️ Coding Activities</div>

                <div class="activity">
                    <div class="activity-title">⚡ Intermediate Challenge: Josephus Problem</div>
                    <p>Solve classic Josephus problem using circular linked list.</p>
                    <button class="btn btn-secondary" onclick="downloadCode(\`#include <iostream>
using namespace std;

// Josephus Problem: n people, every kth eliminated
// Find survivor using circular linked list

struct Node {
    int data;
    Node* next;
    Node(int val) : data(val), next(nullptr) {}
};

class Josephus {
private:
    Node* head;
public:
    Josephus() : head(nullptr) {}
    void addPerson(int id) { /* add to list */ }
    int solve(int k) { /* find survivor */ }
};

int main() {
    Josephus j;
    for(int i = 1; i <= 7; i++) {
        j.addPerson(i);
    }
    cout << \"Survivor: \" << j.solve(3) << endl;
    return 0;
}\`, 'josephus_problem.cpp')">⬇ Download Skeleton</button>
                    <button class="collapsible">▼ Show Solution</button>
                    <div class="collapsible-content">
                        <div class="code-editor">
#include <iostream>
using namespace std;

struct Node {
    int data;
    Node* next;
    Node(int val) : data(val), next(nullptr) {}
};

class Josephus {
private:
    Node* head;
public:
    Josephus() : head(nullptr) {}
    
    void addPerson(int id) {
        Node* newNode = new Node(id);
        if(head == nullptr) {
            head = newNode;
            newNode->next = head;
            return;
        }
        Node* curr = head;
        while(curr->next != head) {
            curr = curr->next;
        }
        curr->next = newNode;
        newNode->next = head;
    }
    
    int solve(int k) {
        if(head == nullptr) return -1;
        
        Node* curr = head;
        Node* prev = nullptr;
        
        while(curr->next != curr) {
            for(int i = 0; i < k - 1; i++) {
                prev = curr;
                curr = curr->next;
            }
            
            cout << "Eliminating: " << curr->data 
                 << endl;
            
            if(prev != nullptr) {
                prev->next = curr->next;
            }
            Node* temp = curr;
            curr = curr->next;
            delete temp;
        }
        
        return curr->data;
    }
    
    ~Josephus() {
        if(head == nullptr) return;
        Node* curr = head->next;
        while(curr != head) {
            Node* temp = curr;
            curr = curr->next;
            delete temp;
        }
        delete head;
    }
};

int main() {
    Josephus j;
    
    cout << "=== Josephus Problem ===" << endl;
    cout << "7 people, every 3rd eliminated:" << endl;
    for(int i = 1; i <= 7; i++) {
        j.addPerson(i);
    }
    
    int survivor = j.solve(3);
    cout << "\nSurvivor: Person " 
         << survivor << endl;
    
    return 0;
}
                        </div>
                    </div>
                </div>

                <div class="activity">
                    <div class="activity-title">🔥 Advanced Challenge: Music Playlist</div>
                    <p>Implement circular playlist with next/previous and shuffle.</p>
                    <button class="btn btn-secondary" onclick="downloadCode(\`#include <iostream>
#include <string>
using namespace std;

struct Song {
    string title;
    int duration;
    Song(string t, int d) : title(t), duration(d) {}
};

struct Node {
    Song* song;
    Node* next;
    Node(Song* s) : song(s), next(nullptr) {}
};

class Playlist {
private:
    Node* head;
    Node* current;
public:
    Playlist() : head(nullptr), current(nullptr) {}
    
    // TODO: void addSong(string title, int duration)
    // TODO: void play()
    // TODO: void next()
    // TODO: void previous()
};

int main() {
    Playlist playlist;
    playlist.addSong(\"Song1\", 180);
    playlist.play();
    playlist.next();
    return 0;
}\`, 'music_playlist.cpp')">⬇ Download Skeleton</button>
                    <button class="collapsible">▼ Show Solution</button>
                    <div class="collapsible-content">
                        <div class="code-editor">
#include <iostream>
#include <string>
using namespace std;

struct Node {
    string title;
    int duration;
    Node* next;
    Node(string t, int d) 
        : title(t), duration(d), next(nullptr) {}
};

class Playlist {
private:
    Node* head;
    Node* current;
public:
    Playlist() : head(nullptr), current(nullptr) {}
    
    void addSong(string title, int duration) {
        Node* newNode = new Node(title, duration);
        if(head == nullptr) {
            head = newNode;
            current = head;
            newNode->next = head;
            cout << "Added: " << title << endl;
            return;
        }
        Node* temp = head;
        while(temp->next != head) {
            temp = temp->next;
        }
        temp->next = newNode;
        newNode->next = head;
        cout << "Added: " << title << endl;
    }
    
    void play() {
        if(current == nullptr) return;
        cout << "Now playing: " << current->title 
             << " (" << current->duration 
             << "s)" << endl;
    }
    
    void next() {
        if(current == nullptr) return;
        current = current->next;
        cout << "Next: " << current->title << endl;
        play();
    }
    
    void previous() {
        if(current == nullptr) return;
        if(head == nullptr) return;
        
        Node* temp = head;
        while(temp->next != current) {
            temp = temp->next;
        }
        current = temp;
        cout << "Previous: " << current->title 
             << endl;
        play();
    }
    
    void displayAll() {
        if(head == nullptr) return;
        cout << "\nPlaylist:" << endl;
        Node* temp = head;
        int i = 1;
        do {
            cout << i++ << ". " << temp->title 
                 << " (" << temp->duration 
                 << "s)" << endl;
            temp = temp->next;
        } while(temp != head);
    }
    
    ~Playlist() {
        if(head == nullptr) return;
        Node* curr = head->next;
        while(curr != head) {
            Node* temp = curr;
            curr = curr->next;
            delete temp;
        }
        delete head;
    }
};

int main() {
    Playlist playlist;
    
    cout << "=== Building Playlist ===" << endl;
    playlist.addSong("Bohemian Rhapsody", 354);
    playlist.addSong("Imagine", 183);
    playlist.addSong("Hotel California", 391);
    playlist.addSong("Stairway to Heaven", 482);
    
    playlist.displayAll();
    
    cout << "\n=== Playing ===" << endl;
    playlist.play();
    
    cout << "\n=== Navigation ===" << endl;
    playlist.next();
    playlist.next();
    playlist.previous();
    
    return 0;
}
                        </div>
                    </div>
                </div>
            </section>

            <section class="section">
                <div class="section-title">📝 Knowledge Check Quiz</div>
                <div class="quiz-container">
                    <button class="quiz-btn" onclick="initializeQuiz()">▶ Start Quiz</button>
                </div>
            </section>
        </main>
    </div>

    <footer><p>COS110 OOP Study Website | November 2025</p></footer>

    <script src="../../js/main.js"></script>
    <script src="../../js/compiler.js"></script>
    <script src="../../js/quiz.js"></script>

    <script>
        function initializeQuiz() {
            const questions = [
                {type: 'multiple-choice', question: 'In a circular linked list, the traversal termination condition curr != head must execute AFTER processing the current node. Why is this ordering critical?', options: ['To ensure the head node itself is processed in traversal', 'The ordering is arbitrary; any condition works identically', 'To prevent infinite loops in the comparison logic', 'To optimize memory cache utilization'], correctAnswer: 'A', explanation: 'Using do-while ensures the head is processed before checking termination. A while loop checking before entering would skip the head node entirely due to circular structure.'},
                {type: 'true-false', question: 'A circular linked list can start traversal from any node and reach all other nodes, whereas a singly linked list must always start from the head.', correctAnswer: 'true', explanation: 'Correct. Circular structure allows entry from any node, reaching all nodes. Singly linked requires head access to reach the entire list.'},
                {type: 'short-answer', question: 'Josephus Problem: In the Josephus problem with circular linked list, every kth person is eliminated. How does circular structure fit this algorithm?', context: 'The circular topology allows continuous <span style="color: red;">_______</span> without managing artificial end conditions.', hint: 'cycling or rotation', acceptableAnswers: ['cycling', 'rotation', 'wrapping', 'continuous iteration', 'round-robin'], explanation: 'Circular structure eliminates boundary handling; elimination and advancement naturally wrap around, matching the problem\'s inherent cyclicity.'},
                {type: 'multiple-choice', question: 'When inserting a node at the end of a circular linked list, finding the last node is O(n). Why is locating end easier than in a singly list conceptually?', options: ['You can jump directly to the end', 'Last node has next == head, providing clear termination', 'Insertion at end is identical; neither is easier', 'Circular lists maintain tail pointers automatically'], correctAnswer: 'B', explanation: 'Last node\'s next == head (not nullptr) provides unambiguous termination signal. Both structures traverse in O(n), but circular has clearer semantics.'},
                {type: 'true-false', question: 'Only one pointer (head) is needed to access both the beginning and end of a circular linked list efficiently.', correctAnswer: 'true', explanation: 'Correct. Head accesses the beginning directly. The last node is always one node before head, accessible by traversing to head\'s predecessor.'},
                {type: 'fill-in', question: 'Round-Robin Scheduling: A circular linked list is ideal because each process naturally <span style="color: red;">_______</span> to the back of the queue as the pointer advances.', hint: 'cycles or rotates', acceptableAnswers: ['cycles back', 'rotates', 'wraps around', 'returns'], explanation: 'Circular structure inherently represents repeating queue nature. Pointer advancement naturally cycles processes without explicit re-queueing logic.'},
                {type: 'multiple-choice', question: 'When deleting the head node from a circular linked list, why is special handling required?', options: ['Head pointer must be updated; other deletions only modify internal pointers', 'Deletion is identical regardless of position', 'Circular lists cannot delete head', 'Head deletion requires full list reconstruction'], correctAnswer: 'A', explanation: 'Deleting head requires updating external head reference. Other deletions only affect internal pointers. Head\'s special role as external anchor necessitates special handling.'},
                {type: 'true-false', question: 'A circular linked list with only one node pointing to itself (node->next = node) is a valid, traversable structure.', correctAnswer: 'true', explanation: 'Correct. Single-node circular list is degenerate but valid and fully traversable.'},
                {type: 'fill-in', question: 'Infinite Loop Prevention: When iterating a circular list without guaranteed termination, you must track if you\'ve returned to the <span style="color: red;">_______</span> or maintain an explicit counter.', hint: 'head or starting node', acceptableAnswers: ['head', 'starting node', 'original node', 'initial head'], explanation: 'Circular structure inherently allows infinite iteration. Safe traversal requires explicit boundary: either detect return to start or count iterations.'},
                {type: 'multiple-choice', question: 'Doubly circular linked lists maintain bidirectional pointers in circular form. What synchronization challenge arises?', options: ['No additional challenge; identical to singly circular', 'Both forward and backward pointer chains must remain consistent throughout all operations', 'Only theoretical; never encountered in practice', 'Synchronization is automatic'], correctAnswer: 'B', explanation: 'Doubly circular must maintain both chains simultaneously. Each insertion/deletion requires updating both directions consistently, doubling synchronization requirements.'},
                {type: 'true-false', question: 'In a circular linked list, if you maintain a tail pointer in addition to head, you lose efficiency benefits compared to maintaining only head.', correctAnswer: 'false', explanation: 'False. Tail pointer enables O(1) insertion at end without traversal, complementing head\'s O(1) insertion at beginning.'},
                {type: 'multiple-choice', question: 'Why is detecting a cycle in a general singly linked list O(n) using Floyd\'s algorithm, but trivially O(1) for circular lists?', options: ['Circular lists are fundamentally different', 'Circular lists have no cycles by definition; they are always cyclic', 'Floyd\'s algorithm is unnecessary for circular lists', 'B and C'], correctAnswer: 'D', explanation: 'Circular lists are cyclic by definition. Floyd\'s algorithm isn\'t needed; any traversal from any node eventually returns to itself, confirming cyclicity trivially.'},
                {type: 'fill-in', question: 'Insertion After Node X: In a circular list, inserting after node X is O(1) because you directly update <span style="color: red;">_______</span> pointers without searching.', hint: 'X\'s next', acceptableAnswers: ['X\'s next', 'X next', 'next pointers'], explanation: 'With direct access to node X, you only update X->next and new node->next, bypassing any traversal.'},
                {type: 'multiple-choice', question: 'A circular linked list for process scheduling rotates through processes in order. After removing a process, why doesn\'t the scheduler need special logic to find the next process?', options: ['The list automatically adjusts', 'The current pointer already points to a valid successor after deletion', 'Scheduling stops when processes are removed', 'Additional logic is always required'], correctAnswer: 'B', explanation: 'When deleting current, the pointer still points to a remaining valid node (the successor). The list naturally continues without special next-finding logic.'},
                {type: 'true-false', question: 'A circular linked list requires more memory per node than a singly linked list to store circular pointers.', correctAnswer: 'false', explanation: 'False. Memory per node is identical. The difference is topological (circular vs. linear), not structural (same pointer count).'},
                {type: 'short-answer', question: 'Circular Buffer Application: Why is a circular linked list efficient for implementing a ring buffer compared to linear structures?', context: 'Elements wrap around naturally without requiring <<span style="color: red;">_______</span> or boundary management logic.', hint: 'modulo or wrapping calculations', acceptableAnswers: ['modulo', 'wrapping', 'boundary checks', 'index resets'], explanation: 'Circular topology inherently wraps data flow. Pointer advancement handles wraparound implicitly; no explicit modulo or index management needed.'},
                {type: 'multiple-choice', question: 'Why is traversing a circular list backward more complex than forward when using only forward pointers?', options: ['It\'s equally complex in both directions', 'You must traverse from any node to its predecessor, requiring full circle traversal', 'Backward traversal is impossible without prev pointers', 'B and C'], correctAnswer: 'D', explanation: 'Without prev pointers, finding a predecessor requires traversing the entire circle from that node backward—O(n) even for adjacent nodes.'},
                {type: 'fill-in', question: 'CPU Scheduling with Preemption: When a process\'s time slice expires in a circular queue, advancing to the next process is O(1) because the <<span style="color: red;">_______</span> pointer is already positioned correctly.', hint: 'current or scheduler', acceptableAnswers: ['current', 'scheduler pointer', 'scheduling pointer', 'pointer'], explanation: 'The current pointer maintains position after each operation. Advancing simply means moving the pointer to next, an O(1) operation.'},
                {type: 'true-false', question: 'A circular linked list with n nodes requires exactly one external pointer (head) to access the entire structure, while singly linked lists require the same.', correctAnswer: 'true', explanation: 'Correct. Both require only head pointer for complete access. The distinction is that circular can start traversal from any node, not just head.'},
            ];

            window.quizSystem = new QuizSystem('Circular Linked Lists', questions);
            openQuizModal();
        }

        if (!document.getElementById('quizModal')) {
            const modal = document.createElement('div');
            modal.id = 'quizModal';
            modal.className = 'quiz-modal';
            modal.innerHTML = `<div class="quiz-modal-content"><div class="quiz-header"><div><div class="quiz-question-number">Quiz: Circular Lists</div><div class="quiz-progress">Question 1 of 20</div></div><button class="quiz-close" onclick="closeQuizModal()">✕</button></div><div class="quiz-questions-container"></div></div>`;
            document.body.appendChild(modal);
        }
    </script>
</body>
</html>