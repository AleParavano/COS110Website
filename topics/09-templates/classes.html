<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Template Classes - COS110 OOP Study Website</title>
    <link rel="stylesheet" href="../../css/style.css">
</head>
<body>
    <nav class="navbar">
        <a href="../../index.html" class="navbar-brand">üìö COS110 OOP</a>
        <div class="navbar-search"><input type="text" placeholder="Search topics..."></div>
    </nav>

    <div class="container">
        <aside class="sidebar">
            <div class="sidebar-title">üìå Foundations</div>
            <a href="../01-pointers/part1.html" class="sidebar-item">Pointers Part 1</a>
            <a href="../01-pointers/part2.html" class="sidebar-item">Pointers Part 2</a>

            <div class="sidebar-title">üèóÔ∏è Classes & Objects</div>
            <a href="../02-classes/basics.html" class="sidebar-item">Classes Basics</a>
            <a href="../02-classes/advanced.html" class="sidebar-item">Classes Advanced</a>
            <a href="../02-classes/more.html" class="sidebar-item">Classes More</a>

            <div class="sidebar-title">üîß Constructors</div>
            <a href="../03-copy-constructors.html" class="sidebar-item">Copy Constructors</a>
            <a href="../04-assignment-operator.html" class="sidebar-item">Assignment Operator</a>

            <div class="sidebar-title">‚ûï Operators</div>
            <a href="../05-operator-overloading/basics.html" class="sidebar-item">Overloading Basics</a>
            <a href="../05-operator-overloading/friends.html" class="sidebar-item">Friends</a>
            <a href="../05-operator-overloading/references.html" class="sidebar-item">References/IO</a>
            <a href="../05-operator-overloading/increment.html" class="sidebar-item">Inc/Dec/Subscript</a>

            <div class="sidebar-title">‚ö†Ô∏è Exception Handling</div>
            <a href="../06-exception-handling/basics.html" class="sidebar-item">Basics</a>
            <a href="../06-exception-handling/hierarchies.html" class="sidebar-item">Hierarchies</a>

            <div class="sidebar-title">üë®‚Äçüëß Inheritance</div>
            <a href="../07-inheritance/basics.html" class="sidebar-item">Basics</a>
            <a href="../07-inheritance/redefining.html" class="sidebar-item">Redefining</a>
            <a href="../07-inheritance/aggregation.html" class="sidebar-item">Aggregation</a>

            <div class="sidebar-title">üîÑ Polymorphism</div>
            <a href="../08-polymorphism/virtual-functions.html" class="sidebar-item">Virtual Functions</a>
            <a href="../08-polymorphism/pointers.html" class="sidebar-item">Pointers</a>

            <div class="sidebar-title">üé® Templates</div>
            <a href="classes.html" class="sidebar-item">Classes</a>
            <a href="functions.html" class="sidebar-item">Functions</a>

            <div class="sidebar-title">üìä Data Structures</div>
            <a href="../10-data-structures/linked-lists.html" class="sidebar-item">Linked Lists</a>
            <a href="../10-data-structures/doubly-linked.html" class="sidebar-item">Doubly Linked</a>
            <a href="../10-data-structures/circular-lists.html" class="sidebar-item">Circular Lists</a>
            <a href="../10-data-structures/stacks.html" class="sidebar-item">Stacks</a>
            <a href="../10-data-structures/queues.html" class="sidebar-item">Queues</a>
            <a href="../10-data-structures/stl.html" class="sidebar-item">STL</a>
        </aside>

        <main class="main-content">
            <h1>üì¶ Template Classes - Generic Programming</h1>

            <section class="section">
                <div class="section-title">üìö Explanation</div>
                <div class="explanation">
                    <h3 style="color: var(--primary);">What are Template Classes?</h3>
                    <p>Template classes are <strong>blueprints for generating code</strong> at compile time. Instead of writing separate classes for <code>Stack&lt;int&gt;</code>, <code>Stack&lt;double&gt;</code>, <code>Stack&lt;string&gt;</code>, you write one template that generates all of them automatically. This is the foundation of <strong>generic programming</strong> in C++ and powers the entire Standard Template Library (STL).</p>
                    
                    <div style="background: #f0f0f0; padding: 15px; border-radius: 8px; margin: 15px 0;">
                    <strong>The Problem Templates Solve:</strong><br><br>
                    Without templates (terrible approach):<br>
                    class StackInt { /* for int */ }<br>
                    class StackDouble { /* for double */ }<br>
                    class StackString { /* for string */ }<br>
                    ‚Üê Code duplication nightmare!<br><br>
                    
                    With templates (elegant solution):<br>
                    template&lt;typename T&gt; class Stack { /* works for ANY type! */ }<br>
                    Stack&lt;int&gt; s1; // Compiler generates for int<br>
                    Stack&lt;double&gt; s2; // Compiler generates for double<br>
                    Stack&lt;string&gt; s3; // Compiler generates for string
                    </div>

                    <h3 style="color: var(--primary); margin-top: 25px;">Template Parameters - The Core Concept</h3>
                    <p><strong>Template Parameters:</strong> Placeholders for types (or values) that the compiler fills in. Think of them like function parameters, but for types instead of values.</p>
                    
                    <div style="background: #e8f4f8; padding: 15px; border-radius: 8px; margin: 10px 0; font-family: 'Courier New', monospace;">
                    <strong>Syntax Variations:</strong><br><br>
                    template&lt;typename T&gt; ‚Üê Modern, preferred<br>
                    template&lt;class T&gt; ‚Üê Old style, but still works<br><br>
                    
                    Multiple parameters:<br>
                    template&lt;typename T, typename U&gt;<br>
                    template&lt;typename T, int N&gt;  // Value parameter!<br><br>
                    
                    <strong>Inside the template, T can be used like a type:</strong><br>
                    T value;          // T is the template parameter<br>
                    T* ptr;           // Pointer to T<br>
                    vector&lt;T&gt; vec;  // Vector of T
                    </div>

                    <h3 style="color: var(--primary); margin-top: 20px;">Template Instantiation - Compiler Magic</h3>
                    <p><strong>What happens when you use a template:</strong> The compiler reads your template definition and creates a <strong>concrete version</strong> for each type you use. This is called <strong>instantiation</strong>.</p>
                    
                    <div style="background: #f0f0f0; padding: 15px; border-radius: 8px; margin: 10px 0;">
                    <strong>Example Flow:</strong><br><br>
                    1. You write: template&lt;typename T&gt; class Container { T data; };<br><br>
                    
                    2. You use it: Container&lt;int&gt; c1; Container&lt;string&gt; c2;<br><br>
                    
                    3. Compiler generates at compile-time:<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;class Container_int { int data; }; // For int<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;class Container_string { string data; }; // For string<br><br>
                    
                    4. Linker combines everything into final binary<br><br>
                    
                    <strong>Key Point:</strong> This happens at COMPILE time, not runtime. By runtime, only concrete versions exist!
                    </div>

                    <h3 style="color: var(--primary); margin-top: 20px;">Why Template Definition Must Be in Header Files</h3>
                    <div style="background: #ffe8e8; padding: 15px; border-radius: 8px; margin: 10px 0;">
                    <strong>The Problem:</strong> The compiler needs the complete template definition to instantiate it. If you put implementation in a .cpp file, when the compiler tries to instantiate for a new type, it won't see the implementation!<br><br>
                    
                    WRONG APPROACH:<br>
                    // Stack.h<br>
                    template&lt;typename T&gt; class Stack; // Declaration only!<br><br>
                    // Stack.cpp<br>
                    template&lt;typename T&gt;<br>
                    void Stack&lt;T&gt;::push(T val) { ... } // Compiler can't see this when instantiating!<br><br>
                    
                    CORRECT APPROACHES:<br>
                    1. Put everything in header file<br>
                    2. Use explicit instantiation in .cpp<br>
                    3. Use export keyword (rarely used)
                    </div>

                    <h3 style="color: var(--primary); margin-top: 20px;">Member Functions in Templates</h3>
                    <p><strong>Each instantiation creates separate copies:</strong> When you instantiate <code>Stack&lt;int&gt;</code> and <code>Stack&lt;double&gt;</code>, the compiler generates separate copies of <strong>all</strong> member functions. This means: Stack&lt;int&gt;::push() and Stack&lt;double&gt;::push() are different functions!</p>
                    
                    <table style="width: 100%; border-collapse: collapse; margin: 15px 0;">
                    <tr style="background: var(--primary); color: white;">
                        <th style="padding: 10px; border: 1px solid #999;">Aspect</th>
                        <th style="padding: 10px; border: 1px solid #999;">Regular Class</th>
                        <th style="padding: 10px; border: 1px solid #999;">Template Class</th>
                    </tr>
                    <tr style="background: #f9f9f9;">
                        <td style="padding: 10px; border: 1px solid #ddd;"><strong>Compilation</strong></td>
                        <td style="padding: 10px; border: 1px solid #ddd;">One binary version</td>
                        <td style="padding: 10px; border: 1px solid #ddd;">One per instantiation</td>
                    </tr>
                    <tr>
                        <td style="padding: 10px; border: 1px solid #ddd;"><strong>Memory</strong></td>
                        <td style="padding: 10px; border: 1px solid #ddd;">Single copy of code</td>
                        <td style="padding: 10px; border: 1px solid #ddd;">Multiple copies (one per type)</td>
                    </tr>
                    <tr style="background: #f9f9f9;">
                        <td style="padding: 10px; border: 1px solid #ddd;"><strong>Header Location</strong></td>
                        <td style="padding: 10px; border: 1px solid #ddd;">Can separate .cpp</td>
                        <td style="padding: 10px; border: 1px solid #ddd;">Must be in .h file</td>
                    </tr>
                    <tr>
                        <td style="padding: 10px; border: 1px solid #ddd;"><strong>Compile Time</strong></td>
                        <td style="padding: 10px; border: 1px solid #ddd;">Fast</td>
                        <td style="padding: 10px; border: 1px solid #ddd;">Slower (more code generated)</td>
                    </tr>
                    <tr style="background: #f9f9f9;">
                        <td style="padding: 10px; border: 1px solid #ddd;"><strong>Binary Size</strong></td>
                        <td style="padding: 10px; border: 1px solid #ddd;">Smaller</td>
                        <td style="padding: 10px; border: 1px solid #ddd;">Larger (code bloat)</td>
                    </tr>
                    </table>

                    <h3 style="color: var(--primary); margin-top: 20px;">Template Specialization - Special Cases</h3>
                    <p><strong>Partial Specialization:</strong> Provide a specialized implementation for specific types or patterns while keeping the generic version for others.</p>
                    
                    <div style="background: #f0f0f0; padding: 15px; border-radius: 8px; margin: 10px 0; font-family: 'Courier New', monospace;">
                    <strong>Example: Optimize for bool:</strong><br><br>
                    // Generic template<br>
                    template&lt;typename T&gt;<br>
                    class Container { /* stores T directly */ };<br><br>
                    
                    // Specialized for bool (might use bitpack)<br>
                    template&lt;&gt;<br>
                    class Container&lt;bool&gt; { /* special bit-packing */ };<br><br>
                    
                    Now Container&lt;int&gt; uses generic, but Container&lt;bool&gt; uses optimized version!
                    </div>

                    <h3 style="color: var(--primary); margin-top: 20px;">Template Instantiation Methods</h3>
                    <p><strong>Implicit Instantiation (Most Common):</strong> Compiler automatically instantiates templates when you use them. This is automatic and usually what you want.</p>
                    <p><strong>Explicit Instantiation:</strong> Manually tell compiler to generate specific versions. Used to control code generation or split into .cpp files with explicit templates.</p>
                    <p><strong>Example:</strong> <code>template class Stack&lt;int&gt;;</code> tells compiler to generate Stack&lt;int&gt; now.</p>

                    <h3 style="color: var(--primary); margin-top: 20px;">Common Template Mistakes & Solutions</h3>
                    <p><strong>‚ùå Error: Putting template in .cpp</strong> ‚Üí ‚úÖ Solution: Keep in header file</p>
                    <p><strong>‚ùå Error: Forgetting template&lt;&gt;</strong> ‚Üí ‚úÖ Solution: Always start with template&lt;typename T&gt;</p>
                    <p><strong>‚ùå Error: Circular includes</strong> ‚Üí ‚úÖ Solution: Use include guards, avoid cycles</p>
                    <p><strong>‚ùå Error: Binary size bloat</strong> ‚Üí ‚úÖ Solution: Use explicit instantiation for known types</p>
                    <p><strong>‚ùå Error: Template error hard to debug</strong> ‚Üí ‚úÖ Solution: Enable verbose compiler errors</p>

                    <h3 style="color: var(--primary); margin-top: 20px;">When to Use Templates</h3>
                    <p><strong>‚úÖ USE Templates for:</strong> Generic containers (Stack, Queue), algorithms that work on any type, type-safe collections, STL implementation</p>
                    <p><strong>‚ùå AVOID Templates for:</strong> One-off classes, performance-critical code without profiling, when you only need one type, excessive specialization</p>
                </div>
            </section>

            <section class="section">
                <div class="section-title">üíª Code Examples</div>

                <div class="code-example">
                    <div class="code-tabs">
                        <button class="code-tab active" data-tab="simple1">Simple Template</button>
                        <button class="code-tab" data-tab="full1">Full Program</button>
                    </div>
                    <div data-tab-content="simple1" class="code-editor">
// ===== BASIC TEMPLATE CLASS =====
template<typename T>  // T is a type parameter
class Container {
private:
    T data;           // Can hold ANY type!
public:
    Container(T val) : data(val) {}
    
    T get() { return data; }              // Returns type T
    void set(T val) { data = val; }       // Accepts type T
};

// Usage:
Container<int> c1(42);        // T = int
Container<string> c2("hello"); // T = string
cout << c1.get() << endl;     // 42
cout << c2.get() << endl;     // hello
                    </div>
                    <div data-tab-content="full1" style="display: none;">
                        <textarea class="code-editor" id="code1">#include <iostream>
#include <string>
using namespace std;

// ===== TEMPLATE CLASS DEFINITION =====
// template<typename T> tells compiler this is a template
// T is a placeholder that will be replaced with actual types

template<typename T>
class Container {
private:
    T data;                     // Member variable of type T
    
public:
    // Constructor: initialize with value of type T
    Container(T val) : data(val) {
        cout << "Container created" << endl;
    }
    
    // Getter: returns value of type T
    T get() const {
        return data;
    }
    
    // Setter: accepts value of type T
    void set(T val) {
        data = val;
    }
    
    // Display: works differently for different types
    void display() {
        cout << "Value: " << data << endl;
    }
};

// ===== USAGE IN MAIN =====
int main() {
    cout << "=== Template Instantiation ===" << endl;
    
    // When we write Container<int>, compiler generates:
    // class Container_int { int data; ... };
    Container<int> intContainer(100);
    intContainer.display();
    intContainer.set(200);
    intContainer.display();
    
    cout << "\n=== Different Type Same Template ===" << endl;
    
    // When we write Container<double>, compiler generates NEW version:
    // class Container_double { double data; ... };
    Container<double> doubleContainer(3.14);
    doubleContainer.display();
    doubleContainer.set(2.71);
    doubleContainer.display();
    
    cout << "\n=== String Template ===" << endl;
    
    // When we write Container<string>, compiler generates:
    // class Container_string { string data; ... };
    Container<string> stringContainer("Hello");
    stringContainer.display();
    stringContainer.set("Templates!");
    stringContainer.display();
    
    return 0;
}
                        </textarea>
                    </div>
                    <div class="code-buttons">
                        <button class="btn btn-primary" onclick="runCode(document.getElementById('code1'), document.getElementById('output1'))">‚ñ∂ Run Code</button>
                        <button class="btn btn-secondary" onclick="downloadCode(document.getElementById('code1'))">‚¨á Download Code</button>
                    </div>
                    <div class="output-box" id="output1">Click "Run Code" to execute...</div>
                </div>

                <div class="code-example">
                    <div class="code-tabs">
                        <button class="code-tab active" data-tab="simple2">Stack Template</button>
                        <button class="code-tab" data-tab="full2">Full Program</button>
                    </div>
                    <div data-tab-content="simple2" class="code-editor">
template<typename T>
class Stack {
private:
    T* data;      // Dynamic array of type T
    int top;      // Top index
    int capacity; // Maximum size
public:
    Stack(int cap = 10) 
        : capacity(cap), top(-1) {
        data = new T[capacity];
    }
    
    void push(T val) {
        if(top < capacity - 1) {
            data[++top] = val;
        }
    }
    
    T pop() {
        if(top >= 0) return data[top--];
        return T();  // Default value for type T
    }
    
    ~Stack() { delete[] data; }  // Clean up!
};
                    </div>
                    <div data-tab-content="full2" style="display: none;">
                        <textarea class="code-editor" id="code2">#include <iostream>
using namespace std;

// ===== GENERIC STACK TEMPLATE =====
// This single template works for ANY type!

template<typename T>
class Stack {
private:
    T* data;              // Dynamic array of type T (works for any type!)
    int top;              // Index of top element
    int capacity;         // Maximum capacity
    
public:
    // Constructor: initialize stack with given capacity
    Stack(int cap = 10) : capacity(cap), top(-1) {
        data = new T[capacity];  // Allocate array of T
        cout << "Stack created with capacity " << capacity << endl;
    }
    
    // Push: add element of type T to stack
    void push(T val) {
        if(top < capacity - 1) {  // Check if space available
            data[++top] = val;    // Increment top, then insert
            cout << "Pushed element" << endl;
        } else {
            cout << "Stack full!" << endl;
        }
    }
    
    // Pop: remove and return element of type T
    T pop() {
        if(top >= 0) {
            return data[top--];   // Return top, then decrement
        }
        return T();  // Return default value for type T
    }
    
    // Display: output all elements
    void display() {
        cout << "Stack contents: ";
        for(int i = 0; i <= top; i++) {
            cout << data[i] << " ";  // Works for any type with << operator
        }
        cout << endl;
    }
    
    // Check if empty
    bool isEmpty() {
        return top == -1;
    }
    
    // Destructor: cleanup dynamic memory (CRITICAL!)
    ~Stack() {
        delete[] data;  // Free the array of T
        cout << "Stack destroyed" << endl;
    }
};

int main() {
    // ===== DEMONSTRATE WITH INTEGERS =====
    cout << "=== Stack<int> ===" << endl;
    Stack<int> intStack(5);  // Compiler generates Stack with T=int
    
    intStack.push(10);
    intStack.push(20);
    intStack.push(30);
    intStack.display();
    
    cout << "Popped: " << intStack.pop() << endl;  // 30 (LIFO!)
    intStack.display();
    
    // ===== DEMONSTRATE WITH DOUBLES =====
    cout << "\n=== Stack<double> ===" << endl;
    Stack<double> doubleStack(5);  // Compiler generates Stack with T=double
    
    doubleStack.push(3.14);
    doubleStack.push(2.71);
    doubleStack.push(1.41);
    doubleStack.display();
    
    cout << "Popped: " << doubleStack.pop() << endl;  // 1.41
    doubleStack.display();
    
    return 0;
}
                        </textarea>
                    </div>
                    <div class="code-buttons">
                        <button class="btn btn-primary" onclick="runCode(document.getElementById('code2'), document.getElementById('output2'))">‚ñ∂ Run Code</button>
                        <button class="btn btn-secondary" onclick="downloadCode(document.getElementById('code2'))">‚¨á Download Code</button>
                    </div>
                    <div class="output-box" id="output2">Click "Run Code" to execute...</div>
                </div>

                <div class="code-example">
                    <div class="code-tabs">
                        <button class="code-tab active" data-tab="simple3">Multiple Parameters</button>
                        <button class="code-tab" data-tab="full3">Full Program</button>
                    </div>
                    <div data-tab-content="simple3" class="code-editor">
template<typename Key, typename Value>
class Pair {
private:
    Key k;
    Value v;
public:
    Pair(Key key, Value val) 
        : k(key), v(val) {}
    
    Key getKey() { return k; }
    Value getValue() { return v; }
    
    void display() {
        cout << "Key: " << k 
             << ", Value: " << v << endl;
    }
};

// Usage with different types:
Pair<string, int> p1("age", 25);
Pair<int, double> p2(1, 3.14);
                    </div>
                    <div data-tab-content="full3" style="display: none;">
                        <textarea class="code-editor" id="code3">#include <iostream>
#include <string>
using namespace std;

// ===== TEMPLATE WITH MULTIPLE PARAMETERS =====
// Templates can have MORE than one type parameter!
// This lets us create generic key-value pairs

template<typename Key, typename Value>
class Pair {
private:
    Key k;           // First template parameter
    Value v;         // Second template parameter
    
public:
    // Constructor: accepts both Key and Value types
    Pair(Key key, Value val) : k(key), v(val) {
        cout << "Pair created" << endl;
    }
    
    // Get key: returns Key type
    Key getKey() const {
        return k;
    }
    
    // Get value: returns Value type
    Value getValue() const {
        return v;
    }
    
    // Display: works with any types that support <<
    void display() {
        cout << "Key: " << k << ", Value: " << v << endl;
    }
};

int main() {
    // ===== STRING TO INT MAPPING =====
    cout << "=== Pair<string, int> ===" << endl;
    
    // Compiler generates Pair with Key=string, Value=int
    Pair<string, int> person("Alice", 30);
    person.display();
    
    cout << "Key: " << person.getKey() << endl;      // "Alice"
    cout << "Value: " << person.getValue() << endl;  // 30
    
    // ===== INT TO DOUBLE MAPPING =====
    cout << "\n=== Pair<int, double> ===" << endl;
    
    // Different instantiation: Key=int, Value=double
    Pair<int, double> point(1, 3.14);
    point.display();
    
    cout << "Key: " << point.getKey() << endl;       // 1
    cout << "Value: " << point.getValue() << endl;   // 3.14
    
    // ===== STRING TO STRING MAPPING =====
    cout << "\n=== Pair<string, string> ===" << endl;
    
    // Both parameters same type is OK!
    Pair<string, string> mapping("color", "blue");
    mapping.display();
    
    return 0;
}
                        </textarea>
                    </div>
                    <div class="code-buttons">
                        <button class="btn btn-primary" onclick="runCode(document.getElementById('code3'), document.getElementById('output3'))">‚ñ∂ Run Code</button>
                        <button class="btn btn-secondary" onclick="downloadCode(document.getElementById('code3'))">‚¨á Download Code</button>
                    </div>
                    <div class="output-box" id="output3">Click "Run Code" to execute...</div>
                </div>
            </section>

            <section class="section">
                <div class="section-title">‚úçÔ∏è Coding Challenges with Skeleton Code</div>
                <div style="background: #f0f0f0; padding: 20px; border-radius: 8px;">
                    
                    <h4 style="color: var(--primary);">Challenge 1: Create a Vector Template</h4>
                    <p>Implement a simple Vector template that stores elements and supports push_back(). Make sure it works with int, double, and string.</p>
                    <button class="btn btn-secondary" onclick="downloadClassesVectorSkeleton()">‚¨á Download Vector Skeleton</button>

                    <h4 style="color: var(--primary); margin-top: 20px;">Challenge 2: Pair Template Extension</h4>
                    <p>Extend the Pair template to support setKey(), setValue(), swap(), and equality comparison.</p>
                    <button class="btn btn-secondary" onclick="downloadClassesPairSkeleton()">‚¨á Download Pair Extension Skeleton</button>

                    <h4 style="color: var(--primary); margin-top: 20px;">Challenge 3: Template Specialization</h4>
                    <p>Create a general Container&lt;T&gt; and then specialize it for bool to use bitpacking (store 8 bools per byte).</p>
                    <button class="btn btn-secondary" onclick="downloadClassesSpecializationSkeleton()">‚¨á Download Specialization Skeleton</button>

                    <h4 style="color: var(--primary); margin-top: 20px;">Challenge 4: Linked List Template</h4>
                    <p>Implement a LinkedList&lt;T&gt; template with insert(), delete(), and search() for any type T.</p>
                    <button class="btn btn-secondary" onclick="downloadClassesLinkedListSkeleton()">‚¨á Download LinkedList Skeleton</button>
                </div>
            </section>

            <section class="section">
                <div class="section-title">üìù Knowledge Check Quiz</div>
                <div class="quiz-container">
                    <button class="quiz-btn" onclick="initializeQuiz()">‚ñ∂ Start Quiz</button>
                </div>
            </section>
        </main>
    </div>

    <footer><p>COS110 OOP Study Website | November 2025</p></footer>

    <script src="../../js/main.js"></script>
    <script src="../../js/compiler.js"></script>
    <script src="../../js/quiz.js"></script>

    <script>
        function downloadClassesVectorSkeleton() {
            const code = `#include <iostream>
#include <string>
using namespace std;

// ===== YOUR VECTOR TEMPLATE HERE =====
template<typename T>
class Vector {
private:
    T* data;
    int size;
    int capacity;
    
public:
    Vector(int cap = 10) {
        // TODO: Initialize data, size, capacity
    }
    
    void push_back(T value) {
        // TODO: If size < capacity, add to end
        // TODO: If full, need to expand (optional)
    }
    
    T get(int index) {
        // TODO: Return element at index (with bounds check)
    }
    
    void display() {
        // TODO: Print all elements
    }
    
    ~Vector() {
        // TODO: Clean up dynamic memory
    }
};

int main() {
    Vector<int> v1(5);
    v1.push_back(10);
    v1.push_back(20);
    v1.push_back(30);
    v1.display();
    
    Vector<string> v2(5);
    v2.push_back("Hello");
    v2.push_back("World");
    v2.display();
    
    return 0;
}`;
            downloadSkeleton(code, 'vector_skeleton.cpp');
        }

        function downloadClassesPairSkeleton() {
            const code = `#include <iostream>
#include <string>
using namespace std;

template<typename Key, typename Value>
class Pair {
private:
    Key k;
    Value v;
    
public:
    Pair(Key key, Value val) : k(key), v(val) {}
    
    Key getKey() const { return k; }
    Value getValue() const { return v; }
    
    // TODO: Implement setKey(Key key)
    void setKey(Key key) {
        // YOUR CODE HERE
    }
    
    // TODO: Implement setValue(Value val)
    void setValue(Value val) {
        // YOUR CODE HERE
    }
    
    // TODO: Implement swap()
    void swap() {
        // YOUR CODE HERE
    }
    
    // TODO: Implement operator==(const Pair& other)
    bool operator==(const Pair& other) const {
        // YOUR CODE HERE
        return false;
    }
};

int main() {
    Pair<string, int> p1("Alice", 25);
    cout << p1.getKey() << ": " << p1.getValue() << endl;
    
    p1.setKey("Bob");
    p1.setValue(30);
    cout << p1.getKey() << ": " << p1.getValue() << endl;
    
    return 0;
}`;
            downloadSkeleton(code, 'pair_skeleton.cpp');
        }

        function downloadClassesSpecializationSkeleton() {
            const code = `#include <iostream>
using namespace std;

// TODO: Implement a general Container<T> template
// Store elements in a vector-like structure
template<typename T>
class Container {
private:
    T* data;
    int size;
    int capacity;
    
public:
    Container() {
        // TODO: Initialize
    }
    
    void add(T value) {
        // TODO: Add element to container
    }
    
    void display() {
        // TODO: Display all elements
    }
};

// TODO: Specialize Container for bool to use bitpacking
// Store 8 bools in each byte
template<>
class Container<bool> {
private:
    unsigned char* data;
    int numBits;
    int capacity;
    
public:
    Container() {
        // TODO: Initialize for bitpacking
    }
    
    void add(bool value) {
        // TODO: Pack boolean into bits
    }
    
    bool get(int index) {
        // TODO: Extract boolean from packed bits
        return false;
    }
    
    void display() {
        // TODO: Display all boolean values
    }
};

int main() {
    Container<int> intContainer;
    intContainer.add(10);
    intContainer.add(20);
    intContainer.display();
    
    Container<bool> boolContainer;
    boolContainer.add(true);
    boolContainer.add(false);
    boolContainer.add(true);
    boolContainer.display();
    
    return 0;
}`;
            downloadSkeleton(code, 'template_specialization.cpp');
        }

        function downloadClassesLinkedListSkeleton() {
            const code = `#include <iostream>
using namespace std;

template<typename T>
struct Node {
    T data;
    Node<T>* next;
    Node(T val) : data(val), next(nullptr) {}
};

// TODO: Implement LinkedList<T> template
template<typename T>
class LinkedList {
private:
    Node<T>* head;
    
public:
    LinkedList() : head(nullptr) {}
    
    // TODO: Implement insert(T value)
    void insert(T value) {
        // YOUR CODE HERE
    }
    
    // TODO: Implement delete(T value)
    bool deleteNode(T value) {
        // YOUR CODE HERE
        return false;
    }
    
    // TODO: Implement search(T value)
    bool search(T value) {
        // YOUR CODE HERE
        return false;
    }
    
    // TODO: Implement display()
    void display() {
        // YOUR CODE HERE
    }
    
    ~LinkedList() {
        // TODO: Clean up all nodes
    }
};

int main() {
    LinkedList<int> intList;
    intList.insert(10);
    intList.insert(20);
    intList.insert(30);
    intList.display();
    
    cout << "Search for 20: " << (intList.search(20) ? "Found" : "Not found") << endl;
    
    LinkedList<string> strList;
    strList.insert("Alice");
    strList.insert("Bob");
    strList.display();
    
    return 0;
}`;
            downloadSkeleton(code, 'linkedlist_template.cpp');
        }

        function initializeQuiz() {
            const questions = [
                {type: 'multiple-choice', question: 'What is the primary advantage of template classes?', options: ['Reduce code duplication for multiple types', 'Faster execution speed', 'Smaller binary files', 'Easier to debug'], correctAnswer: 'A', explanation: 'Templates eliminate code duplication by generating type-specific versions from one template.'},
                {type: 'true-false', question: 'Template member functions can be defined in a separate .cpp file.', correctAnswer: 'false', explanation: 'False. Compiler needs complete template definition to instantiate. Either keep in header or use explicit instantiation.'},
                {type: 'multiple-choice', question: 'When you write Stack<int> s; and Stack<double> s2;, what happens?', options: ['Compiler generates two different Stack classes', 'Same Stack class used for both', 'Stack is generated at runtime', 'Compiler error: cannot use same template twice'], correctAnswer: 'A', explanation: 'Compiler generates separate concrete classes for each instantiation during compile time.'},
                {type: 'fill-in', question: 'Syntax for template class definition', context: 'template<_____ T> class Container { ... }', hint: 'typename or class', acceptableAnswers: ['typename', 'class'], explanation: 'Both typename and class work for template parameters in class definitions.'},
                {type: 'true-false', question: 'Template specialization allows optimizing for specific types while keeping generic version.', correctAnswer: 'true', explanation: 'True. You can provide specialized implementations for certain types like bool while others use generic version.'},
                {type: 'multiple-choice', question: 'What is the main disadvantage of using templates?', options: ['Code bloat - multiple instantiations increase binary size', 'Always slower than normal classes', 'Cannot use multiple types', 'Must always use pointers'], correctAnswer: 'A', explanation: 'Each instantiation creates separate code, potentially increasing binary size significantly.'},
                {type: 'short-answer', question: 'Explain why template definitions must be in header files.', context: 'The compiler needs _______ definition when instantiating templates.', hint: 'complete', acceptableAnswers: ['complete', 'the', 'full', 'entire'], explanation: 'Compiler needs complete template source to generate code for new types. .cpp files are compiled separately.'},
                {type: 'multiple-choice', question: 'What does template<typename T, typename U> mean?', options: ['T and U are names of classes', 'Template with two different type parameters', 'Two templates must be combined', 'U is default version of T'], correctAnswer: 'B', explanation: 'This template has two independent type parameters that can be different types.'},
                {type: 'true-false', question: 'Each instantiation of a template creates separate member function copies.', correctAnswer: 'true', explanation: 'Yes. Stack<int>::push() and Stack<double>::push() are different functions.'},
                {type: 'multiple-choice', question: 'What is explicit instantiation?', options: ['Manually declaring a specific template version', 'Automatic generation of templates', 'Compiler error prevention', 'Runtime template generation'], correctAnswer: 'A', explanation: 'Using syntax like "template class Stack<int>;" to explicitly tell compiler to generate that version.'},
            ];

            window.quizSystem = new QuizSystem('Template Classes', questions);
            openQuizModal();
        }

        if (!document.getElementById('quizModal')) {
            const modal = document.createElement('div');
            modal.id = 'quizModal';
            modal.className = 'quiz-modal';
            modal.innerHTML = `<div class="quiz-modal-content"><div class="quiz-header"><div><div class="quiz-question-number">Quiz: Template Classes</div><div class="quiz-progress">Question 1 of 10</div></div><button class="quiz-close" onclick="closeQuizModal()">‚úï</button></div><div class="quiz-questions-container"></div></div>`;
            document.body.appendChild(modal);
        }
    </script>
</body>
</html>