<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Template Functions - COS110 OOP Study Website</title>
    <link rel="stylesheet" href="../../css/style.css">
</head>
<body>
    <nav class="navbar">
        <a href="../../index.html" class="navbar-brand">üìö COS110 OOP</a>
        <div class="navbar-search"><input type="text" placeholder="Search topics..."></div>
    </nav>

    <div class="container">
        <aside class="sidebar">
            <div class="sidebar-title">üìå Foundations</div>
            <a href="../01-pointers/part1.html" class="sidebar-item">Pointers Part 1</a>
            <a href="../01-pointers/part2.html" class="sidebar-item">Pointers Part 2</a>

            <div class="sidebar-title">üèóÔ∏è Classes & Objects</div>
            <a href="../02-classes/basics.html" class="sidebar-item">Classes Basics</a>
            <a href="../02-classes/advanced.html" class="sidebar-item">Classes Advanced</a>
            <a href="../02-classes/more.html" class="sidebar-item">Classes More</a>

            <div class="sidebar-title">üîß Constructors</div>
            <a href="../03-copy-constructors.html" class="sidebar-item">Copy Constructors</a>
            <a href="../04-assignment-operator.html" class="sidebar-item">Assignment Operator</a>

            <div class="sidebar-title">‚ûï Operators</div>
            <a href="../05-operator-overloading/basics.html" class="sidebar-item">Overloading Basics</a>
            <a href="../05-operator-overloading/friends.html" class="sidebar-item">Friends</a>
            <a href="../05-operator-overloading/references.html" class="sidebar-item">References/IO</a>
            <a href="../05-operator-overloading/increment.html" class="sidebar-item">Inc/Dec/Subscript</a>

            <div class="sidebar-title">‚ö†Ô∏è Exception Handling</div>
            <a href="../06-exception-handling/basics.html" class="sidebar-item">Basics</a>
            <a href="../06-exception-handling/hierarchies.html" class="sidebar-item">Hierarchies</a>

            <div class="sidebar-title">üë®‚Äçüëß Inheritance</div>
            <a href="../07-inheritance/basics.html" class="sidebar-item">Basics</a>
            <a href="../07-inheritance/redefining.html" class="sidebar-item">Redefining</a>
            <a href="../07-inheritance/aggregation.html" class="sidebar-item">Aggregation</a>

            <div class="sidebar-title">üîÑ Polymorphism</div>
            <a href="../08-polymorphism/virtual-functions.html" class="sidebar-item">Virtual Functions</a>
            <a href="../08-polymorphism/pointers.html" class="sidebar-item">Pointers</a>

            <div class="sidebar-title">üé® Templates</div>
            <a href="classes.html" class="sidebar-item">Classes</a>
            <a href="functions.html" class="sidebar-item">Functions</a>

            <div class="sidebar-title">üìä Data Structures</div>
            <a href="../10-data-structures/linked-lists.html" class="sidebar-item">Linked Lists</a>
            <a href="../10-data-structures/doubly-linked.html" class="sidebar-item">Doubly Linked</a>
            <a href="../10-data-structures/circular-lists.html" class="sidebar-item">Circular Lists</a>
            <a href="../10-data-structures/stacks.html" class="sidebar-item">Stacks</a>
            <a href="../10-data-structures/queues.html" class="sidebar-item">Queues</a>
            <a href="../10-data-structures/stl.html" class="sidebar-item">STL</a>
        </aside>

        <main class="main-content">
            <h1>‚ö° Template Functions - Generic Algorithms</h1>

            <section class="section">
                <div class="section-title">üìö Explanation</div>
                <div class="explanation">
                    <h3 style="color: var(--primary);">What are Template Functions?</h3>
                    <p>Template functions allow you to write <strong>generic algorithms</strong> that work with any type. Instead of writing separate <code>swapInt()</code>, <code>swapDouble()</code>, <code>swapString()</code> functions, you write one template function that the compiler instantiates for each type. This is simpler than template classes and is commonly used for algorithms in STL.</p>
                    
                    <div style="background: #f0f0f0; padding: 15px; border-radius: 8px; margin: 15px 0;">
                    <strong>The Problem Without Templates:</strong><br><br>
                    void swapInt(int&a, int&b) { int t=a; a=b; b=t; }<br>
                    void swapDouble(double&a, double&b) { double t=a; a=b; b=t; }<br>
                    void swapString(string&a, string&b) { string t=a; a=b; b=t; }<br>
                    ‚Üê Massive code duplication!<br><br>
                    
                    <strong>With Template Functions (Elegant!):</strong><br>
                    template&lt;typename T&gt;<br>
                    void swap(T&a, T&b) { T t=a; a=b; b=t; }<br>
                    ‚Üê One function works for ANY type!
                    </div>

                    <h3 style="color: var(--primary); margin-top: 25px;">Template Function Syntax</h3>
                    <p><strong>Basic Pattern:</strong> Start with <code>template&lt;typename T&gt;</code>, then write your function using T as if it were a real type.</p>
                    
                    <div style="background: #e8f4f8; padding: 15px; border-radius: 8px; margin: 10px 0; font-family: 'Courier New', monospace;">
                    <strong>Syntax Examples:</strong><br><br>
                    // Single parameter:<br>
                    template&lt;typename T&gt;<br>
                    T max(T a, T b) { return a > b ? a : b; }<br><br>
                    
                    // Multiple parameters:<br>
                    template&lt;typename T, typename U&gt;<br>
                    void print(T t, U u) { cout << t << ", " << u; }<br><br>
                    
                    // Multiple same type:<br>
                    template&lt;typename T&gt;<br>
                    void swap(T&a, T&b) { T t=a; a=b; b=t; }<br><br>
                    
                    // Template with iterator (STL style):<br>
                    template&lt;typename Iterator&gt;<br>
                    void printAll(Iterator begin, Iterator end) { ... }
                    </div>

                    <h3 style="color: var(--primary); margin-top: 20px;">Template Argument Deduction</h3>
                    <p><strong>Automatic Type Inference:</strong> The compiler can often figure out the template parameter from the arguments you pass. You don't always need to write <code>max&lt;int&gt;(5, 10)</code>; just write <code>max(5, 10)</code> and compiler deduces <code>T=int</code>.</p>
                    
                    <div style="background: #f0f0f0; padding: 15px; border-radius: 8px; margin: 10px 0;">
                    <strong>Deduction vs Explicit Specification:</strong><br><br>
                    // Compiler deduces T=int from arguments<br>
                    int a = 5, b = 10;<br>
                    cout << max(a, b);  // Calls max&lt;int&gt; automatically<br><br>
                    
                    // Explicit specification (rarely needed)<br>
                    cout << max&lt;int&gt;(a, b);  // Same result, more verbose<br><br>
                    
                    // Needed when compiler can't deduce:<br>
                    vector&lt;int&gt; v;  // Must specify type<br>
                    sort&lt;vector&lt;int&gt;::iterator&gt;(v.begin(), v.end());
                    </div>

                    <h3 style="color: var(--primary); margin-top: 20px;">Key Differences: Template Functions vs Classes</h3>
                    <table style="width: 100%; border-collapse: collapse; margin: 15px 0;">
                    <tr style="background: var(--primary); color: white;">
                        <th style="padding: 10px; border: 1px solid #999;">Aspect</th>
                        <th style="padding: 10px; border: 1px solid #999;">Template Functions</th>
                        <th style="padding: 10px; border: 1px solid #999;">Template Classes</th>
                    </tr>
                    <tr style="background: #f9f9f9;">
                        <td style="padding: 10px; border: 1px solid #ddd;"><strong>Purpose</strong></td>
                        <td style="padding: 10px; border: 1px solid #ddd;">Generic algorithms</td>
                        <td style="padding: 10px; border: 1px solid #ddd;">Generic data containers</td>
                    </tr>
                    <tr>
                        <td style="padding: 10px; border: 1px solid #ddd;"><strong>Usage</strong></td>
                        <td style="padding: 10px; border: 1px solid #ddd;">swap(a, b), sort(v)</td>
                        <td style="padding: 10px; border: 1px solid #ddd;">Stack&lt;int&gt;, Vector&lt;string&gt;</td>
                    </tr>
                    <tr style="background: #f9f9f9;">
                        <td style="padding: 10px; border: 1px solid #ddd;"><strong>Deduction</strong></td>
                        <td style="padding: 10px; border: 1px solid #ddd;">Automatic from arguments</td>
                        <td style="padding: 10px; border: 1px solid #ddd;">Must explicitly specify</td>
                    </tr>
                    <tr>
                        <td style="padding: 10px; border: 1px solid #ddd;"><strong>Header Placement</strong></td>
                        <td style="padding: 10px; border: 1px solid #ddd;">Must be in .h file</td>
                        <td style="padding: 10px; border: 1px solid #ddd;">Must be in .h file</td>
                    </tr>
                    <tr style="background: #f9f9f9;">
                        <td style="padding: 10px; border: 1px solid #ddd;"><strong>Specialization</strong></td>
                        <td style="padding: 10px; border: 1px solid #ddd;">Function overloading possible</td>
                        <td style="padding: 10px; border: 1px solid #ddd;">Template specialization</td>
                    </tr>
                    </table>

                    <h3 style="color: var(--primary); margin-top: 20px;">Function Overloading vs Specialization</h3>
                    <p><strong>Key Distinction:</strong> With template functions, you can use function overloading AND template specialization.</p>
                    
                    <div style="background: #ffe8e8; padding: 15px; border-radius: 8px; margin: 10px 0;">
                    <strong>Function Overloading (preferred for templates):</strong><br>
                    // General template<br>
                    template&lt;typename T&gt; void process(T val) { /* generic */ }<br><br>
                    
                    // Overload for specific type<br>
                    void process(int val) { /* special for int */ }<br><br>
                    
                    When you call process(5), compiler uses specialized int version!<br><br>
                    
                    <strong>Advantage:</strong> Compiler tries overload first, then template. Gives you fine control.
                    </div>

                    <h3 style="color: var(--primary); margin-top: 20px;">Common STL Template Functions</h3>
                    <div style="background: #f0f0f0; padding: 15px; border-radius: 8px; margin: 10px 0; font-family: 'Courier New', monospace;">
                    sort(begin, end)  // Sort any container<br>
                    find(begin, end, value)  // Find in any range<br>
                    count(begin, end, value)  // Count occurrences<br>
                    max(a, b)  // Maximum of two values<br>
                    min(a, b)  // Minimum of two values<br>
                    swap(a, b)  // Exchange two values<br>
                    copy(begin, end, dest)  // Copy range<br>
                    reverse(begin, end)  // Reverse order<br><br>
                    
                    <strong>All work for ANY type that supports necessary operations!</strong>
                    </div>

                    <h3 style="color: var(--primary); margin-top: 20px;">Constraints on Template Functions</h3>
                    <p><strong>‚ö†Ô∏è Important:** Template function must work with the operations it uses. If your template calls <code>a > b</code>, type T must support <code>&gt;</code> operator. Compiler will complain if you try <code>sort(vector&lt;CustomObject&gt;)</code> without <code>&lt;</code> operator defined.</p>
                    
                    <p><strong>Example:</strong> <code>template&lt;typename T&gt; T max(T a, T b)</code> requires T to support <code>&gt;</code>. Won't compile for types lacking this operator.</p>

                    <h3 style="color: var(--primary); margin-top: 20px;">Template Function Specialization</h3>
                    <p><strong>Full Specialization:</strong> Provide complete alternative implementation for specific type combination.</p>
                    
                    <div style="background: #f0f0f0; padding: 15px; border-radius: 8px; margin: 10px 0; font-family: 'Courier New', monospace;">
                    // General template<br>
                    template&lt;typename T&gt;<br>
                    void print(T val) { cout << val << endl; }<br><br>
                    
                    // Specialization for const char*<br>
                    template&lt;&gt;<br>
                    void print&lt;const char*&gt;(const char* str) {<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;cout << "String: " << str << endl;<br>
                    }<br><br>
                    
                    Now print("hello") uses specialized version!
                    </div>

                    <h3 style="color: var(--primary); margin-top: 20px;">Variadic Templates (C++11 and Later)</h3>
                    <p><strong>Advanced Feature:</strong> Functions with variable number of template parameters. Enables extremely generic functions that work with any number of any types.</p>
                    
                    <div style="background: #f0f0f0; padding: 15px; border-radius: 8px; margin: 10px 0; font-family: 'Courier New', monospace;">
                    template&lt;typename... Args&gt;  // ... means variable arguments<br>
                    void printAll(Args... args) { /* process all args */ }<br><br>
                    
                    printAll(1, 2.5, "hello", true);  // Works with any types!<br><br>
                    
                    <strong>Use Case:</strong> printf-like functions, tuple operations, advanced metaprogramming
                    </div>

                    <h3 style="color: var(--primary); margin-top: 20px;">Best Practices for Template Functions</h3>
                    <p><strong>‚úÖ DO:</strong> Keep templates focused and simple. Use clear parameter names. Document requirements (what operators must T support?). Provide specializations for common types.</p>
                    <p><strong>‚ùå DON'T:</strong> Create overly complex templates. Don't mix template logic with specialization excessively. Avoid template metaprogramming unless necessary.</p>
                </div>
            </section>

            <section class="section">
                <div class="section-title">üíª Code Examples</div>

                <div class="code-example">
                    <div class="code-tabs">
                        <button class="code-tab active" data-tab="simple1">Simple Swap Function</button>
                        <button class="code-tab" data-tab="full1">Full Program</button>
                    </div>
                    <div data-tab-content="simple1" class="code-editor">
// ===== SIMPLE TEMPLATE FUNCTION =====
template<typename T>  // T will be any type
void mySwap(T& a, T& b) {
    T temp = a;  // Create temporary of type T
    a = b;       // Swap
    b = temp;
}

// Usage - compiler deduces type!
int x = 5, y = 10;
mySwap(x, y);  // T=int automatically

string s1 = "Hello", s2 = "World";
mySwap(s1, s2);  // T=string automatically
                    </div>
                    <div data-tab-content="full1" style="display: none;">
                        <textarea class="code-editor" id="code1">#include <iostream>
#include <string>
using namespace std;

// ===== TEMPLATE FUNCTION DEFINITION =====
// template<typename T> at the start tells compiler this is generic
// T becomes the actual type when function is called

template<typename T>
void mySwap(T& a, T& b) {
    // This works for ANY type that can be assigned!
    T temp = a;   // Save first value (type T)
    a = b;        // Move second to first
    b = temp;     // Move saved to second
}

// ===== HELPER FUNCTION =====
template<typename T>
void displayValues(T a, T b) {
    cout << "First: " << a << ", Second: " << b << endl;
}

int main() {
    // ===== SWAP INTEGERS =====
    cout << "=== Swapping Integers ===" << endl;
    int x = 5, y = 10;
    
    cout << "Before: ";
    displayValues(x, y);
    
    mySwap(x, y);  // Compiler generates mySwap<int> automatically!
    
    cout << "After:  ";
    displayValues(x, y);
    
    // ===== SWAP DOUBLES =====
    cout << "\n=== Swapping Doubles ===" << endl;
    double a = 3.14, b = 2.71;
    
    cout << "Before: ";
    displayValues(a, b);
    
    mySwap(a, b);  // Compiler generates mySwap<double>!
    
    cout << "After:  ";
    displayValues(a, b);
    
    // ===== SWAP STRINGS =====
    cout << "\n=== Swapping Strings ===" << endl;
    string s1 = "Hello", s2 = "World";
    
    cout << "Before: ";
    displayValues(s1, s2);
    
    mySwap(s1, s2);  // Compiler generates mySwap<string>!
    
    cout << "After:  ";
    displayValues(s1, s2);
    
    return 0;
}
                        </textarea>
                    </div>
                    <div class="code-buttons">
                        <button class="btn btn-primary" onclick="runCode(document.getElementById('code1'), document.getElementById('output1'))">‚ñ∂ Run Code</button>
                        <button class="btn btn-secondary" onclick="downloadCode(document.getElementById('code1'))">‚¨á Download Code</button>
                    </div>
                    <div class="output-box" id="output1">Click "Run Code" to execute...</div>
                </div>

                <div class="code-example">
                    <div class="code-tabs">
                        <button class="code-tab active" data-tab="simple2">Min/Max Functions</button>
                        <button class="code-tab" data-tab="full2">Full Program</button>
                    </div>
                    <div data-tab-content="simple2" class="code-editor">
template<typename T>
T getMax(T a, T b) {
    return (a > b) ? a : b;
}

template<typename T>
T getMin(T a, T b) {
    return (a < b) ? a : b;
}

// Usage:
int max_int = getMax(5, 10);      // 10
double max_dbl = getMax(3.1, 3.2); // 3.2

string max_str = getMax("apple", "banana");
// "banana" (lexicographic comparison)
                    </div>
                    <div data-tab-content="full2" style="display: none;">
                        <textarea class="code-editor" id="code2">#include <iostream>
#include <string>
using namespace std;

// ===== GENERIC MAX FUNCTION =====
// Works with ANY type that supports > operator
template<typename T>
T getMax(T a, T b) {
    // Return larger of two values
    // T must support > operator!
    return (a > b) ? a : b;
}

// ===== GENERIC MIN FUNCTION =====
// Works with ANY type that supports < operator
template<typename T>
T getMin(T a, T b) {
    // Return smaller of two values
    // T must support < operator!
    return (a < b) ? a : b;
}

// ===== GENERIC SORT-3 FUNCTION =====
// Arrange three values in ascending order
template<typename T>
void sort3(T& a, T& b, T& c) {
    // Simple bubble-sort-like logic for 3 elements
    if(a > b) {
        T temp = a; a = b; b = temp;  // Swap a and b
    }
    if(b > c) {
        T temp = b; b = c; c = temp;  // Swap b and c
    }
    if(a > b) {
        T temp = a; a = b; b = temp;  // Swap a and b again
    }
}

int main() {
    // ===== MAX WITH INTEGERS =====
    cout << "=== Integer Min/Max ===" << endl;
    int x = 15, y = 8;
    
    cout << "Numbers: " << x << ", " << y << endl;
    cout << "Max: " << getMax(x, y) << endl;  // Calls getMax<int>
    cout << "Min: " << getMin(x, y) << endl;  // Calls getMin<int>
    
    // ===== MAX WITH DOUBLES =====
    cout << "\n=== Double Min/Max ===" << endl;
    double a = 2.71, b = 3.14;
    
    cout << "Numbers: " << a << ", " << b << endl;
    cout << "Max: " << getMax(a, b) << endl;  // Calls getMax<double>
    cout << "Min: " << getMin(a, b) << endl;  // Calls getMin<double>
    
    // ===== MAX WITH STRINGS =====
    cout << "\n=== String Min/Max ===" << endl;
    string s1 = "apple", s2 = "zebra";
    
    cout << "Strings: " << s1 << ", " << s2 << endl;
    cout << "Max (lexicographic): " << getMax(s1, s2) << endl;
    cout << "Min (lexicographic): " << getMin(s1, s2) << endl;
    
    // ===== SORT 3 NUMBERS =====
    cout << "\n=== Sort Three Numbers ===" << endl;
    int v1 = 30, v2 = 10, v3 = 20;
    
    cout << "Before: " << v1 << ", " << v2 << ", " << v3 << endl;
    sort3(v1, v2, v3);  // Calls sort3<int>
    cout << "After:  " << v1 << ", " << v2 << ", " << v3 << endl;
    
    return 0;
}
                        </textarea>
                    </div>
                    <div class="code-buttons">
                        <button class="btn btn-primary" onclick="runCode(document.getElementById('code2'), document.getElementById('output2'))">‚ñ∂ Run Code</button>
                        <button class="btn btn-secondary" onclick="downloadCode(document.getElementById('code2'))">‚¨á Download Code</button>
                    </div>
                    <div class="output-box" id="output2">Click "Run Code" to execute...</div>
                </div>

                <div class="code-example">
                    <div class="code-tabs">
                        <button class="code-tab active" data-tab="simple3">Array Search</button>
                        <button class="code-tab" data-tab="full3">Full Program</button>
                    </div>
                    <div data-tab-content="simple3" class="code-editor">
template<typename T>
int findIndex(T arr[], int size, T target) {
    for(int i = 0; i < size; i++) {
        if(arr[i] == target) {
            return i;  // Found at index i
        }
    }
    return -1;  // Not found
}

// Usage:
int nums[] = {1, 2, 3, 4, 5};
int idx = findIndex(nums, 5, 3);  // Returns 2

string words[] = {"cat", "dog", "bird"};
int pos = findIndex(words, 3, "dog");  // Returns 1
                    </div>
                    <div data-tab-content="full3" style="display: none;">
                        <textarea class="code-editor" id="code3">#include <iostream>
#include <string>
using namespace std;

// ===== GENERIC SEARCH FUNCTION =====
// Find index of target element in array of type T
template<typename T>
int findIndex(T arr[], int size, T target) {
    // Linear search: compare each element with target
    // T must support == operator
    
    for(int i = 0; i < size; i++) {
        if(arr[i] == target) {  // Element matches target
            return i;  // Return index (0-based)
        }
    }
    return -1;  // Not found, return -1
}

// ===== GENERIC COUNT FUNCTION =====
// Count how many times target appears in array
template<typename T>
int countOccurrences(T arr[], int size, T target) {
    int count = 0;
    
    for(int i = 0; i < size; i++) {
        if(arr[i] == target) {
            count++;  // Increment count when found
        }
    }
    return count;
}

int main() {
    // ===== SEARCH IN INTEGER ARRAY =====
    cout << "=== Search Integer Array ===" << endl;
    
    int numbers[] = {10, 20, 30, 40, 50};
    int size = 5;
    
    cout << "Array: ";
    for(int i = 0; i < size; i++) {
        cout << numbers[i] << " ";
    }
    cout << endl;
    
    int idx = findIndex(numbers, size, 30);  // Calls findIndex<int>
    if(idx != -1) {
        cout << "Found 30 at index: " << idx << endl;
    } else {
        cout << "30 not found" << endl;
    }
    
    // ===== SEARCH IN STRING ARRAY =====
    cout << "\n=== Search String Array ===" << endl;
    
    string fruits[] = {"apple", "banana", "cherry", "apple", "date"};
    int numFruits = 5;
    
    cout << "Array: ";
    for(int i = 0; i < numFruits; i++) {
        cout << fruits[i] << " ";
    }
    cout << endl;
    
    int pos = findIndex(fruits, numFruits, "cherry");  // findIndex<string>
    if(pos != -1) {
        cout << "Found 'cherry' at index: " << pos << endl;
    }
    
    // ===== COUNT OCCURRENCES =====
    cout << "\n=== Count Occurrences ===" << endl;
    
    int appearances = countOccurrences(fruits, numFruits, "apple");
    cout << "'apple' appears " << appearances << " times" << endl;
    
    int numCount = countOccurrences(numbers, size, 40);
    cout << "40 appears " << numCount << " times in numbers" << endl;
    
    return 0;
}
                        </textarea>
                    </div>
                    <div class="code-buttons">
                        <button class="btn btn-primary" onclick="runCode(document.getElementById('code3'), document.getElementById('output3'))">‚ñ∂ Run Code</button>
                        <button class="btn btn-secondary" onclick="downloadCode(document.getElementById('code3'))">‚¨á Download Code</button>
                    </div>
                    <div class="output-box" id="output3">Click "Run Code" to execute...</div>
                </div>
            </section>

            <section class="section">
                <div class="section-title">‚úçÔ∏è Coding Challenges with Skeleton Code</div>
                <div style="background: #f0f0f0; padding: 20px; border-radius: 8px;">
                    
                    <h4 style="color: var(--primary);">Challenge 1: Generic Sort Function</h4>
                    <p>Implement a template function bubbleSort&lt;T&gt;() that sorts an array of any type supporting &lt; operator. Works for int, double, string, etc.</p>
                    <button class="btn btn-secondary" onclick="downloadFunctionsSortSkeleton()">‚¨á Download Sort Skeleton</button>

                    <h4 style="color: var(--primary); margin-top: 20px;">Challenge 2: Generic Sum Function</h4>
                    <p>Create a template function sum&lt;T&gt;() that takes an array and returns sum of all elements. Works for int, double, but fails gracefully for string.</p>
                    <button class="btn btn-secondary" onclick="downloadFunctionsSumSkeleton()">‚¨á Download Sum Skeleton</button>

                    <h4 style="color: var(--primary); margin-top: 20px;">Challenge 3: Reverse Array Function</h4>
                    <p>Write a template function reverse&lt;T&gt;() that reverses an array in-place using your knowledge of swapping.</p>
                    <button class="btn btn-secondary" onclick="downloadFunctionsReverseSkeleton()">‚¨á Download Reverse Skeleton</button>

                    <h4 style="color: var(--primary); margin-top: 20px;">Challenge 4: Generic Print with Separator</h4>
                    <p>Implement printArray&lt;T&gt;(arr, size, separator) that prints elements separated by custom delimiter for any type supporting &lt;&lt;.</p>
                    <button class="btn btn-secondary" onclick="downloadFunctionsPrintSkeleton()">‚¨á Download Print Skeleton</button>
                </div>
            </section>

            <section class="section">
                <div class="section-title">üìù Knowledge Check Quiz</div>
                <div class="quiz-container">
                    <button class="quiz-btn" onclick="initializeQuiz()">‚ñ∂ Start Quiz</button>
                </div>
            </section>
        </main>
    </div>

    <footer><p>COS110 OOP Study Website | November 2025</p></footer>

    <script src="../../js/main.js"></script>
    <script src="../../js/compiler.js"></script>
    <script src="../../js/quiz.js"></script>

    <script>
        function downloadFunctionsTemplateSkeleton() {
            const code = `#include <iostream>
using namespace std;

// TODO: Implement a generic swap template function
// Should work with any data type
template<typename T>
void swap(T& a, T& b) {
    // YOUR CODE HERE
}

// TODO: Implement a generic max template function
// Should work with any comparable data type
template<typename T>
T max(T a, T b) {
    // YOUR CODE HERE
    return a;
}

// TODO: Implement a generic min template function
template<typename T>
T min(T a, T b) {
    // YOUR CODE HERE
    return a;
}

int main() {
    // Test swap
    int x = 5, y = 10;
    swap(x, y);
    cout << "After swap: x = " << x << ", y = " << y << endl;
    
    // Test max
    cout << "Max of 15 and 20: " << max(15, 20) << endl;
    
    // Test min
    cout << "Min of 15 and 20: " << min(15, 20) << endl;
    
    // Test with doubles
    double a = 3.5, b = 2.8;
    cout << "Max of " << a << " and " << b << ": " << max(a, b) << endl;
    
    return 0;
}`;
            downloadSkeleton(code, 'function_templates.cpp');
        }

        function downloadFunctionsGenericSkeleton() {
            const code = `#include <iostream>
#include <string>
using namespace std;

// TODO: Implement a generic print function template
// Should work with arrays of any type
template<typename T>
void printArray(T arr[], int size) {
    // YOUR CODE HERE
}

// TODO: Implement a generic search function template
// Should return the index if found, -1 otherwise
template<typename T>
int search(T arr[], int size, T value) {
    // YOUR CODE HERE
    return -1;
}

// TODO: Implement a generic sum function template
// Should sum all elements in an array
template<typename T>
T sum(T arr[], int size) {
    // YOUR CODE HERE
    return 0;
}

int main() {
    // Test with integers
    int intArr[] = {1, 2, 3, 4, 5};
    cout << "Integer array: ";
    printArray(intArr, 5);
    
    cout << "Sum of integers: " << sum(intArr, 5) << endl;
    cout << "Search for 3: " << search(intArr, 5, 3) << endl;
    
    // Test with doubles
    double dblArr[] = {1.5, 2.5, 3.5, 4.5};
    cout << "\\nDouble array: ";
    printArray(dblArr, 4);
    
    cout << "Sum of doubles: " << sum(dblArr, 4) << endl;
    
    return 0;
}`;
            downloadSkeleton(code, 'generic_functions.cpp');
        }

        function downloadFunctionsSortSkeleton() {
            const code = `#include <iostream>
using namespace std;

// TODO: Implement generic bubbleSort template function
// Should work with any type that supports < operator
template<typename T>
void bubbleSort(T arr[], int size) {
    // YOUR CODE HERE
    // Use nested loops for bubble sort
    // Compare with < operator
}

int main() {
    // Test with integers
    int intArr[] = {64, 34, 25, 12, 22, 11, 90};
    cout << "Original: ";
    for(int i = 0; i < 7; i++) cout << intArr[i] << " ";
    
    bubbleSort(intArr, 7);
    
    cout << "\\nSorted: ";
    for(int i = 0; i < 7; i++) cout << intArr[i] << " ";
    cout << endl;
    
    // Test with doubles
    double dblArr[] = {3.2, 1.5, 4.8, 2.1};
    bubbleSort(dblArr, 4);
    
    cout << "Sorted doubles: ";
    for(int i = 0; i < 4; i++) cout << dblArr[i] << " ";
    cout << endl;
    
    return 0;
}`;
            downloadSkeleton(code, 'sort_template.cpp');
        }

        function downloadFunctionsSumSkeleton() {
            const code = `#include <iostream>
using namespace std;

// TODO: Implement generic sum template function
// Should work with numeric types (int, double, float)
// Should handle string gracefully (or static_assert prevent)
template<typename T>
T sum(T arr[], int size) {
    // YOUR CODE HERE
    // Initialize result to 0 (or T())
    // Sum all elements
}

int main() {
    // Test with integers
    int intArr[] = {1, 2, 3, 4, 5};
    cout << "Sum of integers: " << sum(intArr, 5) << endl;
    
    // Test with doubles
    double dblArr[] = {1.5, 2.5, 3.5, 4.5};
    cout << "Sum of doubles: " << sum(dblArr, 4) << endl;
    
    // Test with floats
    float fltArr[] = {1.1f, 2.2f, 3.3f};
    cout << "Sum of floats: " << sum(fltArr, 3) << endl;
    
    return 0;
}`;
            downloadSkeleton(code, 'sum_template.cpp');
        }

        function downloadFunctionsReverseSkeleton() {
            const code = `#include <iostream>
using namespace std;

// TODO: Implement generic reverse template function
// Reverse array in-place using swap technique
template<typename T>
void swap(T& a, T& b) {
    T temp = a;
    a = b;
    b = temp;
}

template<typename T>
void reverse(T arr[], int size) {
    // YOUR CODE HERE
    // Use two pointers: one at start, one at end
    // Swap elements moving towards middle
}

int main() {
    // Test with integers
    int intArr[] = {1, 2, 3, 4, 5};
    cout << "Original: ";
    for(int i = 0; i < 5; i++) cout << intArr[i] << " ";
    
    reverse(intArr, 5);
    
    cout << "\\nReversed: ";
    for(int i = 0; i < 5; i++) cout << intArr[i] << " ";
    cout << endl;
    
    // Test with doubles
    double dblArr[] = {1.1, 2.2, 3.3, 4.4};
    reverse(dblArr, 4);
    
    cout << "Reversed doubles: ";
    for(int i = 0; i < 4; i++) cout << dblArr[i] << " ";
    cout << endl;
    
    return 0;
}`;
            downloadSkeleton(code, 'reverse_template.cpp');
        }

        function downloadFunctionsPrintSkeleton() {
            const code = `#include <iostream>
#include <string>
using namespace std;

// TODO: Implement generic printArray template function
// Print array elements separated by custom separator
template<typename T>
void printArray(T arr[], int size, string separator = ", ") {
    // YOUR CODE HERE
    // Print first element
    // Loop through remaining elements
    // Print separator before each element
}

int main() {
    // Test with integers
    int intArr[] = {10, 20, 30, 40, 50};
    cout << "Integers with comma separator: ";
    printArray(intArr, 5);
    cout << endl;
    
    cout << "Integers with dash separator: ";
    printArray(intArr, 5, " - ");
    cout << endl;
    
    // Test with doubles
    double dblArr[] = {1.5, 2.5, 3.5};
    cout << "Doubles: ";
    printArray(dblArr, 3, " | ");
    cout << endl;
    
    // Test with strings
    string strArr[] = {"Hello", "World", "C++"};
    cout << "Strings: ";
    printArray(strArr, 3, " :: ");
    cout << endl;
    
    return 0;
}`;
            downloadSkeleton(code, 'print_template.cpp');
        }

        function initializeQuiz() {
            const questions = [
                {type: 'multiple-choice', question: 'What is template argument deduction?', options: ['Compiler automatically figures out template parameter from function arguments', 'Manual specification of template parameters', 'A compiler error', 'Function overloading'], correctAnswer: 'A', explanation: 'Compiler can infer T=int from max(5, 10) without explicitly writing max<int>.'},
                {type: 'true-false', question: 'Template functions can be defined in a separate .cpp file.', correctAnswer: 'false', explanation: 'False. Compiler needs complete definition when instantiating. Must be in header file.'},
                {type: 'multiple-choice', question: 'What does template<typename T> swap(T& a, T& b) require of type T?', options: ['Must support assignment and swap', 'Can be any type without restrictions', 'Must support operator=', 'Must be a primitive type'], correctAnswer: 'C', explanation: 'The template needs assignment (operator=) to work.'},
                {type: 'fill-in', question: 'When compiler sees max(5, 10), it deduces T=___', context: 'T=_____', hint: 'int', acceptableAnswers: ['int'], explanation: 'The compiler infers T is int from the argument types.'},
                {type: 'true-false', question: 'Template functions can be overloaded with non-template functions.', correctAnswer: 'true', explanation: 'Yes! Non-template function takes priority. Compiler tries overload first, then template.'},
                {type: 'multiple-choice', question: 'What is function template specialization?', options: ['Providing specialized version for specific type', 'Automatic deduction of template parameters', 'Compiler error', 'A template that never instantiates'], correctAnswer: 'A', explanation: 'You can provide alternative implementation for specific types like const char*.'},
                {type: 'short-answer', question: 'Why does sort(begin, end) work with any container type?', context: 'It is a ______ function that works on iterators', hint: 'template', acceptableAnswers: ['template'], explanation: 'sort() is a template function that works with any iterator type.'},
                {type: 'multiple-choice', question: 'What happens when max(5, 10.5) is called?', options: ['Compiler error: deduction fails with mixed types', 'Implicitly converts one to other', 'Returns 10.5', 'Compilation succeeds with implicit conversion'], correctAnswer: 'A', explanation: 'Compiler cannot deduce single T when arguments are different types.'},
                {type: 'true-false', question: 'Each template function instantiation creates separate function copies.', correctAnswer: 'true', explanation: 'Yes. swap<int> and swap<double> are separate functions in the binary.'},
                {type: 'multiple-choice', question: 'Which constraint applies to template functions?', options: ['Must specify all template parameters explicitly', 'Type must support operations used in function', 'Can only work with primitive types', 'No constraints exist'], correctAnswer: 'B', explanation: 'If your template uses >, type T must support > operator.'},
            ];

            window.quizSystem = new QuizSystem('Template Functions', questions);
            openQuizModal();
        }

        if (!document.getElementById('quizModal')) {
            const modal = document.createElement('div');
            modal.id = 'quizModal';
            modal.className = 'quiz-modal';
            modal.innerHTML = `<div class="quiz-modal-content"><div class="quiz-header"><div><div class="quiz-question-number">Quiz: Template Functions</div><div class="quiz-progress">Question 1 of 10</div></div><button class="quiz-close" onclick="closeQuizModal()">‚úï</button></div><div class="quiz-questions-container"></div></div>`;
            document.body.appendChild(modal);
        }
    </script>
</body>
</html>